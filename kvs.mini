
import func builtin_arraySwap(a: []anytype, b: uint, c: anytype) ([]anytype, anytype);

type ShtItem = struct {
	key: bytes32,
	value: anytype,
}

type SimpleHashtable = struct {
	salt: bytes32,
	size: uint,
	contents: []ShtItem,
}

func simpleHashtable_new(salt: bytes32) SimpleHashtable {
	return struct {
		salt: salt,
		size: 8,
		contents: unsafecast(newarray(8, anytype), []ShtItem),
	};
}

func simpleHashtable_get(table: SimpleHashtable, key: bytes32) (anytype, bool) {
	let salted_key = hash(table.salt, key);
	let slot = uint(salted_key) % table.size;
	let item = table.contents[slot];
	if ((item == null) || (key != item.key)) {
		return (null, false,);
	} else {
		return (item.value, true,);
	}
}

func simpleHashtable_set(table:SimpleHashtable, key: bytes32, val: anytype) SimpleHashtable {
	let salted_key = hash(table.salt, key);
	let slot = uint(salted_key) % table.size;
	let newitem = struct { key: key, value: val, }; 
	return table with { contents: table.contents with {[slot] = newitem} };
}

func simpleHashtable_delete(table: SimpleHashtable, key: bytes32) SimpleHashtable {
	let salted_key = hash(table.salt, key);
	let slot = uint(salted_key) % table.size;
	let item = table.contents[slot];
	if ((item != null) && (key == item.key)) {
		return table with { contents: table.contents with {[slot] = unsafecast(null, ShtItem) } };
	} else {
		return table;
	}
}

func simpleHashtable_swap(
	table: SimpleHashtable, 
	key: bytes32, 
	val: anytype
) (SimpleHashtable, ShtItem) {
	let salted_key = hash(table.salt, key);
	let sres = unsafecast(
		builtin_arraySwap(
			table.contents, 
			uint(salted_key) % table.size, 
			struct {
				key: key,
				value: val,
			}
		),
		([]ShtItem, ShtItem)
	);
	return (
		table with { contents: sres.0 },
		sres.1,
	);
}

func simpleHashtable_expand(table: SimpleHashtable) SimpleHashtable {
	let newSize = 2*table.size;
	let newTable = struct {
		salt: table.salt,
		size: newSize,
		contents: unsafecast(newarray(newSize, anytype), []ShtItem),
	};
	let i = 0;
	while (i < table.size) {
		let oldItem = table.contents[i];
		if (oldItem != null) {
			newTable = simpleHashtable_set(newTable, oldItem.key, oldItem.value);
		}
		i = i+1;
	}
	return newTable;
}

type KeyValueStore = [2]SimpleHashtable

public func kvs_new() KeyValueStore {
	return newfixedarray(2, simpleHashtable_new(bytes32(0))) with { [1] = simpleHashtable_new(bytes32(1)) };
}

public func kvs_get(kvs: KeyValueStore, key: anytype) (anytype, bool) {
	let val1 = simpleHashtable_get(kvs[0], hash(key));
	if (val1.1) {
		return val1;
	}
	return simpleHashtable_get(kvs[1], hash(key));
}

public func kvs_hasKey(kvs: KeyValueStore, key: anytype) bool {
	return kvs_get(kvs, key).1;
}

public func kvs_set(kvs: KeyValueStore, key: anytype, value:anytype) KeyValueStore {
	let which = 0;
	let retries = 0;
	let item = struct {
		key: hash(key),
		value: value,
	};
	while (retries < 5) {
		let res = simpleHashtable_swap(kvs[which], item.key, item.value);
		kvs = kvs with { [which] = res.0 };
		if ((res.1 == null) || (res.1.key == item.key) ) {
			return kvs;
		}
		item = res.1;
		which = 1-which;
		retries = 1+retries;
	}
	return kvs_set(
		kvs with { [0] = simpleHashtable_expand(kvs[0]) } 
	        with { [1] = simpleHashtable_expand(kvs[1]) },
		item.key,
		item.value
	);
}

public func kvs_delete(kvs: KeyValueStore, key: anytype) KeyValueStore {
	let val = simpleHashtable_get(kvs[0], hash(key));
	if (val != null) {
		return kvs with { [0] = simpleHashtable_delete(kvs[0], hash(key)) };
	}
	if (val != null) {
		return kvs with { [1] = simpleHashtable_delete(kvs[1], hash(key)) };
	}
	return kvs;
}
