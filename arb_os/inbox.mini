//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type Queue;
import func queue_new() -> Queue;
import func queue_isEmpty(q: Queue) -> bool;
import func queue_get(q: Queue) -> option<(Queue, any)>;
import func queue_put(q: Queue, val: any) -> Queue;

import impure func chainParams_gotParamsMessage(sender: address, data: MarshalledBytes);

import type MarshalledBytes;

// This is the structure that the Arbitrum protocol gives us, for each incoming message.
// It is declared identically in messages.mini
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,          // sequence number in L1 inbox
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

type Inbox = struct {
    queue: Queue,     // Queue of messages that haven't yet been retrieved from the inbox
    blockNum: uint,   // Highest blocknum of messages that we have retrieved from the inbox
    timestamp: uint,  // Highest timestamp of messages that we have retrieved from the inbox
    needToPeek: bool, // true iff we should be doing an inboxpeek before inbox instruction
}

var globalInbox: Inbox;

public impure func inbox_init() {
    globalInbox = struct {
        queue: queue_new(),
        blockNum: 0,
        timestamp: 0,
        needToPeek: false,   // don't peek before the first message
    };
}

public impure func inbox_get() -> IncomingRequest {
    // Get the next message, in order of arrival.
    // If no messages have arrived, this will block until one arrives.
    // This is a loop because some events don't generate a message that we can return,
    //       so we keep trying until we find something we can return.

    loop {
        while (queue_isEmpty(globalInbox.queue)) {
            globalInbox = getFromL1Inbox(globalInbox);
        }

        let (updatedQ, ret,) = queueGetOrDie(globalInbox.queue);
        globalInbox = globalInbox with { queue: updatedQ };
        let ebMsg = unsafecast<IncomingRequest>(ret);
        if (ebMsg.kind == 4) {
            chainParams_gotParamsMessage(ebMsg.sender, ebMsg.msgData);
        } else {
            return ebMsg;
        }
    }
}

func queueGetOrDie(q: Queue) -> (Queue, any) {
    if let Some(res) = queue_get(q) {
        return res;
    } else {
        panic;
    }
}

impure func getFromL1Inbox(inbox: Inbox) -> Inbox {
    // Get a message from the L1 inbox, and append it to the inbox.
    // If there are no messages available in the L1 inbox, this blocks until one is available.
    if (inbox.needToPeek) {
        let sameBlockNum = asm(inbox.blockNum,) bool { inboxpeek };
        if ( ! sameBlockNum) {
            // peek says we hit end of L1 block, so insert end-of-block message and return
            return inbox with {
                queue: queue_put(
                    inbox.queue,
                    struct {
                        kind: 6,   // special kind that is reserved for these synthetic end-of-block messages
                        blockNumber: inbox.blockNum,
                        timestamp: inbox.timestamp,
                        sender: address(0),
                        requestId: 0,
                        msgData: unsafecast<MarshalledBytes>(0),
                    }
                )
            } with {
                needToPeek: false   // don't peek next time, because we already sent end-of-block
            };
        }
    }
    let newMsg = asm() IncomingRequest { inbox };
    return inbox with {
        queue: queue_put(inbox.queue, newMsg)
    } with {
        needToPeek: true
    } with {
        blockNum: newMsg.blockNumber
    } with {
        timestamp: newMsg.timestamp
    };
}

public impure func inbox_currentTimestamp() -> uint {
    return globalInbox.timestamp;
}

public impure func inbox_currentBlockNumber() -> uint {
    return globalInbox.blockNum;
}
