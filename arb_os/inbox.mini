//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::queue::Queue;
use std::queue::queue_new;
use std::queue::queue_isEmpty;
use std::queue::queue_get;
use std::queue::queue_getOrDie;
use std::queue::queue_put;
use std::queue::QueueStack;
use std::queue::queuestack_new;
use std::queue::queuestack_push;
use std::queue::queuestack_get;

use chainParameters::chainParams_gotParamsMessage;
use chainParameters::chainParams_chainId;

use messages::TxRequestData;

use messageBatch::MessageBatch;
use messageBatch::messageBatch_tryNew;
use messageBatch::messageBatch_get;

use output::outputStats_endOfBlock;

use std::bytearray::ByteArray;
use std::bytearray::MarshalledBytes;
use std::bytearray::marshalledBytes_firstByte;
use std::bytearray::marshalledBytes_hash;
use std::bytearray::bytearray_marshalFull;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytearray::bytearray_new;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_get256;

use std::bytestream::ByteStream;
use std::bytestream::bytestream_new;
use std::bytestream::bytestream_getByte;
use std::bytestream::bytestream_get256;
use std::bytestream::bytestream_getRemainingBytes;
use std::bytestream::bytestream_skipBytes;

use decompression::decompressAndVerifyEcdsaSignedTx;

use signedTx::hashUnsignedL2messageInfo;
use signedTx::translateSignedTx;


type Inbox = struct {
    queue: IncomingRequestQueue,  // Queue of requests that haven't yet been retrieved from the inbox
    blockNum: uint,               // Highest blocknum of messages that we have retrieved from the inbox
    timestamp: uint,              // Highest timestamp of messages that we have retrieved from the inbox
    seenMsgAtThisBlockNum: bool,  // true iff we have seen a message at this block number
    sequencer: option<SequencerState>,
}

type SequencerState = struct {
    sequencerAddr: address,
    delayBlocks: uint,
    delayTime: uint,
    delayQueue: Queue,
    lastBlockNumSeen: uint,      // Highest actual blocknum of message we have seen
    lastTimestampSeen: uint,     // Highest actual timestamp of message we have seen
    lastBlockNumReleased: uint,  // Highest blocknum we have released to inbox queue
    lastTimestampReleased: uint, // Highest timestamp we have released to inbox queue
}

var globalInbox: Inbox;
var globalInputQueue: struct {
    txQ: IncomingRequestQueue,
    batchQ: IncomingRequestQueueStack,
};

public impure func inbox_init() {
    globalInbox = struct {
        queue: incomingRequestQueue_new(),
        blockNum: 0,
        timestamp: 0,
        seenMsgAtThisBlockNum: false,
        sequencer: None<SequencerState>,
    };
    globalInputQueue = struct {
        txQ: incomingRequestQueue_new(),
        batchQ: incomingRequestQueueStack_new()
    };
}

public impure func inbox_addSequencer(addr: address, delayBlocks: uint, delayTime: uint) {
    // deliver messages from old sequencer, if any (shouldn't be needed, but doing it just to be extra cautious)
    let bnum = globalInbox.blockNum;
    let ts = globalInbox.timestamp;
    if let Some(oldSeq) = globalInbox.sequencer {
        bnum = oldSeq.lastBlockNumSeen;
        ts = oldSeq.lastTimestampSeen;
        let oldq = oldSeq.delayQueue;
        while( ! queue_isEmpty(oldq) ){
            let (uq, rawMsg) = queue_getOrDie(oldq);
            oldq = uq;
            let msg = unsafecast<IncomingRequest>(rawMsg);
            globalInbox = globalInbox with {
                queue: queue_put(globalInbox.queue, msg)
            };
        }
    }

    // set up the new sequencer
    if (delayBlocks > 128*256) {
        delayBlocks = 128*256;
    }
    if (delayTime > 128*256*30) {
        delayTime = 128*256*30;
    }
    globalInbox = globalInbox with {
        sequencer: Some(struct {
            sequencerAddr: addr,
            delayBlocks: delayBlocks,
            delayTime: delayTime,
            delayQueue: queue_new(),
            lastBlockNumSeen: bnum,
            lastTimestampSeen: ts,
            lastBlockNumReleased: bnum,
            lastTimestampReleased: ts,
        })
    };
}

public impure func inbox_get() -> IncomingRequest {
    // Get the next message, in order of arrival.
    // If no messages have arrived, this will block until one arrives.
    // This is a loop because some events don't generate a message that we can return,
    //       so we keep trying until we find something we can return.

    loop {
        while (incomingRequestQueue_isEmpty(globalInbox.queue)) {
            if let Some(seqInfo) = globalInbox.sequencer {
                globalInbox = getFromL1InboxSequencer(globalInbox, seqInfo);
            } else {
                globalInbox = getFromL1Inbox(globalInbox);
            }
        }

        let (updatedQ, rawMsg,) = incomingRequestQueue_getOrDie(globalInbox.queue);

        globalInbox = globalInbox with { queue: updatedQ };
        let ebMsg = unsafecast<IncomingRequest>(rawMsg);
        if (ebMsg.blockNumber > globalInbox.blockNum) {
            if ((globalInbox.sequencer != None<SequencerState>) && globalInbox.seenMsgAtThisBlockNum) {
                let eobMsg = endOfBlockMessage(globalInbox.blockNum, globalInbox.timestamp);
                globalInbox = globalInbox with {
                    blockNum: ebMsg.blockNumber
                } with {
                    timestamp: ebMsg.timestamp
                } with {
                    seenMsgAtThisBlockNum: false
                };
                return eobMsg;
            } else {
                globalInbox = globalInbox with {
                    blockNum: ebMsg.blockNumber
                } with {
                    timestamp: ebMsg.timestamp
                } with {
                    seenMsgAtThisBlockNum: true
                };
            }
        }

        if (ebMsg.kind == 4) {
            chainParams_gotParamsMessage(ebMsg.sender, ebMsg.msgData);
        } else {
            return ebMsg with {
                requestId: uint(hash(bytes32(chainParams_chainId()), bytes32(ebMsg.requestId)))
            };
        }
    }
}

impure func getFromL1Inbox(inbox: Inbox) -> Inbox {
    // Get a message from the L1 inbox, and append it to the inbox (assuming no sequencer).
    // If there are no messages available in the L1 inbox, this blocks until one is available.
    if (inbox.seenMsgAtThisBlockNum) {
        let sameBlockNum = asm(inbox.blockNum,) bool { inboxpeek };
        if ( ! sameBlockNum) {
            // peek says we hit end of L1 block, so insert end-of-block message and return
            return inbox with {
                queue: incomingRequestQueue_put(
                    inbox.queue,
                    endOfBlockMessage(inbox.blockNum, inbox.timestamp),
                )
            } with {
                blockNum: inbox.blockNum+1
            } with {
                seenMsgAtThisBlockNum: false
            };
        }
    }

    let newMsgRaw = asm() IncomingRequestFromInbox { inbox };
    if let Some(msgData) = bytearray_unmarshalBytes(newMsgRaw.msgData) {
        let newMsg = struct {
            kind: newMsgRaw.kind,
            blockNumber: newMsgRaw.blockNumber,
            timestamp: newMsgRaw.timestamp,
            sender: newMsgRaw.sender,
            requestId: newMsgRaw.requestId,
            msgData: msgData,
            provenance: struct {
                l1SeqNum: newMsgRaw.requestId,
                parentRequestId: 0,
                indexInParent: ~0,
            },
        };

        if (newMsg.blockNumber == 0) {
            newMsg = newMsg with { blockNumber: inbox.blockNum };
        }
        if (newMsg.timestamp == 0) {
            newMsg = newMsg with { timestamp: inbox.timestamp };
        }


        return inbox with {
            queue: incomingRequestQueue_put(inbox.queue, newMsg)
        } with {
            blockNum: newMsg.blockNumber
        } with {
            timestamp: newMsg.timestamp
        } with {
            seenMsgAtThisBlockNum: true
        };
    } else {
        // message was malformatted; ignore it and return; caller will call this function again
        return inbox;
    }
}

impure func getFromL1InboxSequencer(inbox: Inbox, seq: SequencerState) -> Inbox {
    let newMsgRaw = asm() IncomingRequestFromInbox { inbox };
    let newMsg = unsafecast<IncomingRequest>(0);
    if let Some(msgData) = bytearray_unmarshalBytes(newMsgRaw.msgData) {
        newMsg = struct {
            kind: newMsgRaw.kind,
            blockNumber: newMsgRaw.blockNumber,
            timestamp: newMsgRaw.timestamp,
            sender: newMsgRaw.sender,
            requestId: newMsgRaw.requestId,
            msgData: msgData,
            provenance: struct {
                l1SeqNum: newMsgRaw.requestId,
                parentRequestId: 0,
                indexInParent: ~0,
            },
        };
    } else {
        return inbox;
    }

    let blockNum = newMsg.blockNumber;
    if (blockNum == 0) {
        blockNum = seq.lastBlockNumSeen;
    } else {
        seq = seq with { lastBlockNumSeen: blockNum };
    }
    let timestamp = newMsg.timestamp;
    if (timestamp == 0) {
        timestamp = seq.lastBlockNumSeen;
    } else {
        seq = seq with { lastTimestampSeen: timestamp };
    }

    let isSequencerMsg = (newMsg.kind == 3)
                         && (bytearray_getByte(newMsg.msgData, 0) == 5)
                         && (newMsg.sender == seq.sequencerAddr);
    if (isSequencerMsg) {
        // get low-order two bytes of blockNum assigned to this message, and reconstruct that blockNum
        let bnum = (blockNum & ~0xffff)
                         + asm (256-16, bytearray_get256(newMsg.msgData, 1)) uint { shr };
        if ((bnum <= blockNum) || (bnum < 256*256)) {
            blockNum = bnum;
        } else {
            blockNum = bnum-256*256;
        }
        // get low-order three bytes of timestamp assigned to this message, and reconstruct that timestamp
        let ts = (timestamp & ~0xffffff)
                        + asm (256-24, bytearray_get256(newMsg.msgData, 3)) uint { shr };
        if ((ts <= timestamp) || (ts < 256*256*256)) {
            timestamp = ts;
        } else {
            timestamp = ts - 256*256*256;
        }

        if (blockNum+seq.delayBlocks < seq.lastBlockNumSeen) {
            blockNum = seq.lastBlockNumSeen - seq.delayBlocks;
        }
        if (timestamp+seq.delayTime < seq.lastTimestampSeen) {
            timestamp = seq.lastTimestampSeen - seq.delayTime;
        }

        let (uSeq, uInboxQ) = releaseDelayedRequests(
            seq,
            inbox.queue,
            blockNum,
            timestamp,
        );
        seq = uSeq;
        inbox = inbox with { queue: uInboxQ };

        if (blockNum < seq.lastBlockNumReleased) {
            blockNum = seq.lastBlockNumReleased;
        }
        if (timestamp < seq.lastTimestampReleased) {
            timestamp = seq.lastTimestampReleased;
        }

        return inbox with {
            queue: queue_put(inbox.queue, newMsg with { blockNumber: blockNum } with { timestamp: timestamp })
        } with {
            sequencer: Some(
                seq with {
                    lastBlockNumReleased: blockNum
                } with {
                    lastTimestampReleased: timestamp
                }
            )
        };
    } else {
        if ((blockNum >= seq.delayBlocks) && (timestamp >= seq.delayTime)) {
            let (uSeq, uInboxQ) = releaseDelayedRequests(
                seq,
                inbox.queue,
                blockNum - seq.delayBlocks,
                timestamp - seq.delayTime,
            );
            seq = uSeq;
            inbox = inbox with { queue: uInboxQ };
        }

        return inbox with {
            sequencer: Some(seq with {
                delayQueue: queue_put(
                    seq.delayQueue,
                    newMsg with {
                        blockNumber: blockNum
                    } with {
                        timestamp: timestamp
                    }
                )
            } with {
                lastBlockNumSeen: blockNum
            } with {
                lastTimestampSeen: timestamp
            })
        };
    }
}

func endOfBlockMessage(blockNum: uint, timestamp: uint) -> IncomingRequest {
    return struct {
        kind: 6,
        blockNumber: blockNum,
        timestamp: timestamp,
        sender: address(0),
        requestId: 0,
        msgData: bytearray_new(0),
        provenance: struct {
            l1SeqNum: 0,
            parentRequestId: 0,
            indexInParent: ~0,
        },
    };
}

func releaseDelayedRequests(
    seqInfo: SequencerState,
    inQ: Queue,
    blockNum: uint,
    timestamp: uint,
) -> (SequencerState, Queue) {
    loop {
        if let Some(res) = queue_get(seqInfo.delayQueue) {
            let (udq, rawMsg) = res;
            let msg = unsafecast<IncomingRequest>(rawMsg);
            if ((msg.blockNumber <= blockNum) || (msg.timestamp <= timestamp)) {
                seqInfo = seqInfo with {
                    delayQueue: udq
                } with {
                    lastBlockNumReleased: msg.blockNumber
                } with {
                    lastTimestampReleased: msg.timestamp
                };
                inQ = queue_put(inQ, msg);
            } else {
                return (seqInfo, inQ);
            }
        } else {
            return (seqInfo, inQ);
        }
    }
}


public impure func inbox_currentTimestamp() -> uint {
    return globalInbox.timestamp;
}

public impure func inbox_currentBlockNumber() -> uint {
    return globalInbox.blockNum;
}

type IncomingRequestFromInbox = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: MarshalledBytes, // kind-specific data, as a marshalled bytearray
}

type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: ByteArray,       // kind-specific data
    provenance: RequestProvenance,
}

type RequestProvenance = struct {
    l1SeqNum: uint,
    parentRequestId: uint,
    indexInParent: uint,
}

public impure func inbox_getNextUnpackedRequest() -> (
    option<IncomingRequest>,  // if it was an L1 message
    option<TxRequestData>,    // if it was an L2 tx message
) {
    let msg = unsafecast<IncomingRequest>(());   // value will be re-initialized before use
    loop {
        if let Some(res) = incomingRequestQueue_get(globalInputQueue.txQ) {
            let (newQ, tx) = res;
            globalInputQueue = globalInputQueue with {
                txQ: newQ
            };
            return (None<IncomingRequest>, Some(unsafecast<TxRequestData>(tx)));
        }
        if let Some(res) = incomingRequestQueueStack_get(globalInputQueue.batchQ) {
            let (newQ, umsg) = res;
            globalInputQueue = globalInputQueue with {
                batchQ: newQ
            };
            msg = umsg;
        } else {
            msg = inbox_get();
        }

        if let Some(batch) = messageBatch_tryNew(msg) {
            // it's a batch message, so unpack its components and queue them
            let moreToDo = true;
            let queue = incomingRequestQueue_new();
            while (moreToDo) {
                if let Some(res) = messageBatch_get(batch) {
                    let (newMsg, restOfBatch) = res;
                    queue = incomingRequestQueue_put(queue, newMsg);
                    batch = restOfBatch;
                } else {
                    moreToDo = false;
                }
            }
            globalInputQueue = globalInputQueue with {
                batchQ: incomingRequestQueueStack_push(globalInputQueue.batchQ, queue)
            };
        } else {
            // it's not a batch, so process it immediately
            if (msg.kind == 6) {
                // it's an end-of-block message, so just trigger end-of-block processing
                outputStats_endOfBlock(msg.blockNumber, msg.timestamp);
            } elseif (msg.kind == 3) {
                // it's an L2 message, so switch based on the L2 type
                let firstByte = bytearray_getByte(msg.msgData, 0);
                if (firstByte == 6) {
                    // it's a heartbeat message, don't do anything
                } elseif (firstByte == 4) {
                    // it's a signed tx; verify sig and then process request or discard
                    if let Some(txRequest) = translateSignedTx(msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else signature was invalid, ignore msg and execute loop again to get another
                } elseif (firstByte == 7) {
                    // it's a single message with compressed headers
                    if let Some(txRequest) = decompressAndVerifyEcdsaSignedTx(msg.msgData, msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else signature was invalid, ignore msg and execute loop again to get another
                } else {
                    // subtype must be 0, 1, or 2
                    if let Some(txRequest) = translateUnsignedTx(msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else request was malformatted, ignore it and execute loop again to get another
                }
            } elseif (msg.kind == 5) {
                if let Some(txRequest) = translateBuddyDeployTx(msg) {
                    return (None<IncomingRequest>, Some(txRequest));
                }
                // else request was malformatted, ignore it and execute loop again to get another
            } else {
                return (Some(msg), None<TxRequestData>);
            }
        }
    }
}

impure func translateUnsignedTx(request: IncomingRequest) -> option<TxRequestData> {
    let inStream = bytestream_new(request.msgData);
    let (us, subtype) = bytestream_getByte(inStream)?;
    inStream = us;

    let (us, maxGas) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, gasPrice) = bytestream_get256(inStream)?;
    inStream = us;

    let seqNum = None<uint>;
    if (subtype == 0) {
        let (us, sn) = bytestream_get256(inStream)?;
        inStream = us;
        seqNum = Some(sn);
    }

    let (us, destAddrAsUint) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, value) = bytestream_get256(inStream)?;
    inStream = us;

    let calldata = bytestream_getRemainingBytes(inStream);

    if (subtype == 0) {
        request = request with {
            requestId: uint(hash(
                bytes32(request.sender),
                hash(bytes32(chainParams_chainId()), marshalledBytes_hash(bytearray_marshalFull(request.msgData)))
            ))
        };
    }
    return Some(
        struct {
            maxGas: maxGas,
            gasPrice: gasPrice,
            seqNum: seqNum,
            caller: request.sender,
            calleeAddr: address(destAddrAsUint),
            value: value,
            calldata: calldata,
            nonMutating: (subtype == 2),
            incomingRequest: request
        }
    );
}

func translateBuddyDeployTx(request: IncomingRequest) -> option<TxRequestData> {
    let inStream = bytestream_new(request.msgData);

    let (us, maxGas) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, gasPrice) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, value) = bytestream_get256(inStream)?;
    inStream = us;

    let calldata = bytestream_getRemainingBytes(inStream);

    return Some(
        struct {
            maxGas: maxGas,
            gasPrice: gasPrice,
            seqNum: None<uint>,
            caller: request.sender,
            calleeAddr: address(0),
            value: value,
            calldata: calldata,
            nonMutating: false,
            incomingRequest: request
        }
    );
}

// below are specialized queue and queuestack types, to facilitate typechecking in the code above
// we can eliminate these if/when the Mini language supports generics

type IncomingRequestQueue = struct {
    q: Queue,
}

func incomingRequestQueue_new() -> IncomingRequestQueue {
    return struct { q: queue_new() };
}

func incomingRequestQueue_isEmpty(q: IncomingRequestQueue) -> bool {
    return queue_isEmpty(q.q);
}

func incomingRequestQueue_get(q: IncomingRequestQueue) -> option<(IncomingRequestQueue, IncomingRequest)> {
    let (uq, item) = queue_get(q.q)?;
    return Some((struct{ q: uq }, unsafecast<IncomingRequest>(item)));
}

func incomingRequestQueue_getOrDie(q: IncomingRequestQueue) -> (IncomingRequestQueue, IncomingRequest) {
    if let Some(res) = incomingRequestQueue_get(q) {
        return res;
    } else {
        panic;
    }
}

func incomingRequestQueue_put(q: IncomingRequestQueue, req: IncomingRequest) -> IncomingRequestQueue {
    return struct { q: queue_put(q.q, req) };
}

type IncomingRequestQueueStack = struct {
    qs: QueueStack,
}

func incomingRequestQueueStack_new() -> IncomingRequestQueueStack {
    return struct { qs: queuestack_new() };
}

func incomingRequestQueueStack_get(qs: IncomingRequestQueueStack) -> option<(IncomingRequestQueueStack, IncomingRequest)> {
    let (uqs, rawMsg) = queuestack_get(qs.qs)?;
    return Some((struct { qs: uqs }, unsafecast<IncomingRequest>(rawMsg)));
}

func incomingRequestQueueStack_push(qs: IncomingRequestQueueStack, q: IncomingRequestQueue) -> IncomingRequestQueueStack {
    return struct { qs: queuestack_push(qs.qs, q.q) };
}
