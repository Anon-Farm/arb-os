//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::queue::Queue;
use std::queue::queue_new;
use std::queue::queue_isEmpty;
use std::queue::queue_get;
use std::queue::queue_put;
use std::queue::QueueStack;
use std::queue::queuestack_new;
use std::queue::queuestack_push;
use std::queue::queuestack_get;

use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::account_addToEthBalance;

use chainParameters::chainParams_gotParamsMessage;
use chainParameters::chainParams_chainId;

use messages::TxRequestData;

use messageBatch::MessageBatch;
use messageBatch::messageBatch_tryNew;
use messageBatch::messageBatch_get;

use output::outputStats_endOfBlock;

use std::bytearray::ByteArray;
use std::bytearray::MarshalledBytes;
use std::bytearray::marshalledBytes_firstByte;
use std::bytearray::marshalledBytes_hash;
use std::bytearray::bytearray_marshalFull;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytearray::bytearray_new;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_get256;

use std::bytestream::ByteStream;
use std::bytestream::bytestream_new;
use std::bytestream::bytestream_getByte;
use std::bytestream::bytestream_get256;
use std::bytestream::bytestream_getRemainingBytes;
use std::bytestream::bytestream_skipBytes;

use decompression::decompressAndVerifyEcdsaSignedTx;

use signedTx::hashUnsignedL2messageInfo;
use signedTx::translateSignedTx;


type Inbox = struct {
    queue: IncomingRequestQueue,  // Queue of requests that haven't yet been retrieved from the inbox
    blockNum: uint,               // Highest blocknum of messages that we have retrieved from the inbox
    timestamp: uint,              // Highest timestamp of messages that we have retrieved from the inbox
    needToPeek: bool,             // true iff we should be doing an inboxpeek before inbox instruction
}

var globalInbox: Inbox;
var globalInputQueue: struct {
    txQ: IncomingRequestQueue,
    batchQ: IncomingRequestQueueStack,
};

public impure func inbox_init() {
    globalInbox = struct {
        queue: incomingRequestQueue_new(),
        blockNum: 0,
        timestamp: 0,
        needToPeek: false,   // don't peek before the first message
    };
    globalInputQueue = struct {
        txQ: incomingRequestQueue_new(),
        batchQ: incomingRequestQueueStack_new()
    };
}

public impure func inbox_get() -> IncomingRequest {
    // Get the next message, in order of arrival.
    // If no messages have arrived, this will block until one arrives.
    // This is a loop because some events don't generate a message that we can return,
    //       so we keep trying until we find something we can return.

    loop {
        while (incomingRequestQueue_isEmpty(globalInbox.queue)) {
            globalInbox = getFromL1Inbox(globalInbox);
        }

        let (updatedQ, ret,) = incomingRequestQueue_getOrDie(globalInbox.queue);
        globalInbox = globalInbox with { queue: updatedQ };
        let ebMsg = unsafecast<IncomingRequest>(ret);
        if (ebMsg.kind == const::L1MessageType_chainInit) {
            chainParams_gotParamsMessage(ebMsg.sender, ebMsg.msgData);
        } else {
            return ebMsg with {
                requestId: uint(hash(bytes32(chainParams_chainId()), bytes32(ebMsg.requestId)))
            };
        }
    }
}

impure func getFromL1Inbox(inbox: Inbox) -> Inbox {
    // Get a message from the L1 inbox, and append it to the inbox.
    // If there are no messages available in the L1 inbox, this blocks until one is available.
    if (inbox.needToPeek) {
        let sameBlockNum = asm(inbox.blockNum,) bool { inboxpeek };
        if ( ! sameBlockNum) {
            // peek says we hit end of L1 block, so insert end-of-block message and return
            return inbox with {
                queue: incomingRequestQueue_put(
                    inbox.queue,
                    struct {
                        kind: 6,   // special kind that is reserved for these synthetic end-of-block messages
                        blockNumber: inbox.blockNum,
                        timestamp: inbox.timestamp,
                        sender: address(0),
                        requestId: 0,
                        msgData: bytearray_new(0),
                        provenance: struct {   // this won't be used
                            l1SeqNum: 0,
                            parentRequestId: 0,
                            indexInParent: ~0,
                        },
                    }
                )
            } with {
                needToPeek: false   // don't peek next time, because we already sent end-of-block
            };
        }
    }
    let newMsgRaw = asm() IncomingRequestFromInbox { inbox };
    if let Some(msgData) = bytearray_unmarshalBytes(newMsgRaw.msgData) {
        let newMsg = struct {
            kind: newMsgRaw.kind,
            blockNumber: newMsgRaw.blockNumber,
            timestamp: newMsgRaw.timestamp,
            sender: newMsgRaw.sender,
            requestId: newMsgRaw.requestId,
            msgData: msgData,
            provenance: struct {
                l1SeqNum: newMsgRaw.requestId,
                parentRequestId: 0,
                indexInParent: ~0,
            },
        };

        if (newMsg.blockNumber == 0) {
            newMsg = newMsg with { blockNumber: inbox.blockNum };
        }
        if (newMsg.timestamp == 0) {
            newMsg = newMsg with { timestamp: inbox.timestamp };
        }


        return inbox with {
            queue: incomingRequestQueue_put(inbox.queue, newMsg)
        } with {
            needToPeek: true
        } with {
            blockNum: newMsg.blockNumber
        } with {
            timestamp: newMsg.timestamp
        };
    } else {
        // message was malformatted; ignore it and return; caller will call this function again
        return inbox;
    }
}

public impure func inbox_currentTimestamp() -> uint {
    return globalInbox.timestamp;
}

public impure func inbox_currentBlockNumber() -> uint {
    return globalInbox.blockNum;
}

type IncomingRequestFromInbox = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: MarshalledBytes, // kind-specific data, as a marshalled bytearray
}

type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: ByteArray,       // kind-specific data
    provenance: RequestProvenance,
}

type RequestProvenance = struct {
    l1SeqNum: uint,
    parentRequestId: uint,
    indexInParent: uint,
}

public impure func inbox_getNextUnpackedRequest() -> (
    option<IncomingRequest>,  // if it was an L1 message
    option<TxRequestData>,    // if it was an L2 tx message
) {
    let msg = unsafecast<IncomingRequest>(());   // value will be re-initialized before use
    loop {
        if let Some(res) = incomingRequestQueue_get(globalInputQueue.txQ) {
            let (newQ, tx) = res;
            globalInputQueue = globalInputQueue with {
                txQ: newQ
            };
            return (None<IncomingRequest>, Some(unsafecast<TxRequestData>(tx)));
        }
        if let Some(res) = incomingRequestQueueStack_get(globalInputQueue.batchQ) {
            let (newQ, umsg) = res;
            globalInputQueue = globalInputQueue with {
                batchQ: newQ
            };
            msg = umsg;
        } else {
            msg = inbox_get();
        }

        if let Some(batch) = messageBatch_tryNew(msg) {
            // it's a batch message, so unpack its components and queue them
            let moreToDo = true;
            let queue = incomingRequestQueue_new();
            while (moreToDo) {
                if let Some(res) = messageBatch_get(batch) {
                    let (newMsg, restOfBatch) = res;
                    queue = incomingRequestQueue_put(queue, newMsg);
                    batch = restOfBatch;
                } else {
                    moreToDo = false;
                }
            }
            globalInputQueue = globalInputQueue with {
                batchQ: incomingRequestQueueStack_push(globalInputQueue.batchQ, queue)
            };
        } else {
            // it's not a batch, so process it immediately
            if (msg.kind == const::L1MessageType_L2FundedByL1) {
                // the message carries an ETH deposit
                // verify the validity of the message, process the deposit, then process the tx
                let firstByte = bytearray_getByte(msg.msgData, 0);
                if (firstByte == const::L2MessageType_unsignedEOATx) {
                    let callvalue = bytearray_get256(msg.msgData, 1+4*32);
                    let gAcctStore = getGlobalAccountStore();
                    setGlobalAccountStore(
                        accountStore_set(
                            gAcctStore,
                            msg.sender,
                            account_addToEthBalance(accountStore_get(gAcctStore, msg.sender), callvalue)
                        )
                    );
                    if let Some(txRequest) = translateUnsignedTx(msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else request was malformatted, ignore it and execute loop again to get another
                    //     but don't undo the deposit
                } elseif (firstByte == const::L2MessageType_unsignedContractTx) {
                    let callvalue = bytearray_get256(msg.msgData, 1+3*32);
                    let gAcctStore = getGlobalAccountStore();
                    setGlobalAccountStore(
                        accountStore_set(
                            gAcctStore,
                            msg.sender,
                            account_addToEthBalance(accountStore_get(gAcctStore, msg.sender), callvalue)
                        )
                    );
                    if let Some(txRequest) = translateUnsignedTx(msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else request was malformatted, ignore it and execute loop again to get another
                    //     but don't undo the deposit
                }
                // else L2 msg type is invalid in ETH deposit message, ignore msg and execute loop again to get another
                //      note that deposit doesn't happen in this case
            } elseif (msg.kind == const::L1MessageType_endOfBlock) {
                // it's an end-of-block message, so just trigger end-of-block processing
                outputStats_endOfBlock(msg.blockNumber, msg.timestamp);
            } elseif (msg.kind == const::L1MessageType_L2) {
                // it's an L2 message, so switch based on the L2 type
                let firstByte = bytearray_getByte(msg.msgData, 0);
                if (firstByte == const::L2MessageType_heartbeat) {
                    // it's a heartbeat message, don't do anything
                } elseif (firstByte == const::L2MessageType_signedTx) {
                    // it's a signed tx; verify sig and then process request or discard
                    if let Some(txRequest) = translateSignedTx(msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else signature was invalid, ignore msg and execute loop again to get another
                } elseif (firstByte == const::L2MessageType_signedCompressedTx) {
                    // it's a single message with compressed headers
                    if let Some(txRequest) = decompressAndVerifyEcdsaSignedTx(msg.msgData, msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else signature was invalid, ignore msg and execute loop again to get another
                } else {
                    // subtype must be unsigned EOA, unsigned contract, or nonmutating
                    if let Some(txRequest) = translateUnsignedTx(msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else request was malformatted, ignore it and execute loop again to get another
                }
            } elseif (msg.kind == const::L1MessageType_buddyDeploy) {
                if let Some(txRequest) = translateBuddyDeployTx(msg) {
                    return (None<IncomingRequest>, Some(txRequest));
                }
                // else request was malformatted, ignore it and execute loop again to get another
            } else {
                return (Some(msg), None<TxRequestData>);
            }
        }
    }
}

impure func translateUnsignedTx(request: IncomingRequest) -> option<TxRequestData> {
    let inStream = bytestream_new(request.msgData);
    let (us, subtype) = bytestream_getByte(inStream)?;
    inStream = us;

    let (us, maxGas) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, gasPrice) = bytestream_get256(inStream)?;
    inStream = us;

    let seqNum = None<uint>;
    if (subtype == const::L2MessageType_unsignedEOATx) {
        let (us, sn) = bytestream_get256(inStream)?;
        inStream = us;
        seqNum = Some(sn);
    }

    let (us, destAddrAsUint) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, value) = bytestream_get256(inStream)?;
    inStream = us;

    let calldata = bytestream_getRemainingBytes(inStream);

    if (subtype == const::L2MessageType_unsignedEOATx) {
        request = request with {
            requestId: uint(hash(
                bytes32(request.sender),
                hash(bytes32(chainParams_chainId()), marshalledBytes_hash(bytearray_marshalFull(request.msgData)))
            ))
        };
    }
    return Some(
        struct {
            maxGas: maxGas,
            gasPrice: gasPrice,
            seqNum: seqNum,
            caller: request.sender,
            calleeAddr: address(destAddrAsUint),
            value: value,
            calldata: calldata,
            nonMutating: (subtype == const::L2MessageType_nonmutatingCall),
            incomingRequest: request
        }
    );
}

func translateBuddyDeployTx(request: IncomingRequest) -> option<TxRequestData> {
    let inStream = bytestream_new(request.msgData);

    let (us, maxGas) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, gasPrice) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, value) = bytestream_get256(inStream)?;
    inStream = us;

    let calldata = bytestream_getRemainingBytes(inStream);

    return Some(
        struct {
            maxGas: maxGas,
            gasPrice: gasPrice,
            seqNum: None<uint>,
            caller: request.sender,
            calleeAddr: address(0),
            value: value,
            calldata: calldata,
            nonMutating: false,
            incomingRequest: request
        }
    );
}

// below are specialized queue and queuestack types, to facilitate typechecking in the code above
// we can eliminate these if/when the Mini language supports generics

type IncomingRequestQueue = struct {
    q: Queue,
}

func incomingRequestQueue_new() -> IncomingRequestQueue {
    return struct { q: queue_new() };
}

func incomingRequestQueue_isEmpty(q: IncomingRequestQueue) -> bool {
    return queue_isEmpty(q.q);
}

func incomingRequestQueue_get(q: IncomingRequestQueue) -> option<(IncomingRequestQueue, IncomingRequest)> {
    let (uq, item) = queue_get(q.q)?;
    return Some((struct{ q: uq }, unsafecast<IncomingRequest>(item)));
}

func incomingRequestQueue_getOrDie(q: IncomingRequestQueue) -> (IncomingRequestQueue, IncomingRequest) {
    if let Some(res) = incomingRequestQueue_get(q) {
        return res;
    } else {
        panic;
    }
}

func incomingRequestQueue_put(q: IncomingRequestQueue, req: IncomingRequest) -> IncomingRequestQueue {
    return struct { q: queue_put(q.q, req) };
}

type IncomingRequestQueueStack = struct {
    qs: QueueStack,
}

func incomingRequestQueueStack_new() -> IncomingRequestQueueStack {
    return struct { qs: queuestack_new() };
}

func incomingRequestQueueStack_get(qs: IncomingRequestQueueStack) -> option<(IncomingRequestQueueStack, IncomingRequest)> {
    let (uqs, rawMsg) = queuestack_get(qs.qs)?;
    return Some((struct { qs: uqs }, unsafecast<IncomingRequest>(rawMsg)));
}

func incomingRequestQueueStack_push(qs: IncomingRequestQueueStack, q: IncomingRequestQueue) -> IncomingRequestQueueStack {
    return struct { qs: queuestack_push(qs.qs, q.q) };
}
