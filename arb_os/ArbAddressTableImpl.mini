//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use evmCallStack::EvmCallFrame;
use accounts::Account;
use std::bytearray::ByteArray;
use std::bytearray::MarshalledBytes;
use std::stack::Stack;
use accounts::AccountStore;
use std::bytestream::ByteStream;

use chainParameters::chainParams_chainId;

use evmCallStack::evmCallStack_stackDepth;
use evmCallStack::evmCallStack_topFrame;
use evmCallStack::evmCallStack_setAccount;
use evmCallStack::evmCallStack_getTopFrameMemoryOrDie;
use evmCallStack::evmCallStack_setTopFrameMemory;
use evmCallStack::evmCallStack_callHitError;
use evmCallStack::evmCallStack_addEvmLogToCurrent;
use evmCallStack::evmCallStack_addStorageCharge;

use evmCallStack::evmCallFrame_getCalldata;
use evmCallStack::evmCallFrame_getCallvalue;
use evmCallStack::evmCallFrame_getAccount;
use evmCallStack::evmCallFrame_runningAsAddress;
use evmCallStack::evmCallFrame_runningAsAccount;
use evmCallStack::evmCallFrame_getParent;
use evmCallStack::evmCallFrame_getCaller;

use evmOps::evmOp_log4;
use evmOps::evmOp_return;
use evmOps::evmOp_revert_knownCodePc;
use evmOps::evmOp_sload;
use evmOps::evmOp_sstore;

use accounts::account_getAddress;
use accounts::account_getNextSeqNum;
use accounts::account_getStorageCell;
use accounts::account_deductFromEthBalance;
use accounts::account_setBlsKey;
use accounts::account_getBlsKey;
use accounts::account_getAggregatorDecompressionState;
use accounts::account_setAggregatorDecompressionState;

use std::bytearray::bytearray_new;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_setByte;
use std::bytearray::bytearray_get256;
use std::bytearray::bytearray_set256;
use std::bytearray::bytearray_extract;
use std::bytearray::bytearray_extract;
use std::bytearray::bytearray_copy;

use std::bytestream::bytestream_new;
use std::bytestream::bytestream_bytesReadSoFar;

use inbox::inbox_currentArbBlockNumber;
use inbox::inbox_currentEthBlockNumber;
use inbox::inbox_currentTimestamp;

use std::stack::stack_pop;

use output::queueMessageForSend;

use decompression::getGlobalAddressTable;
use decompression::setGlobalAddressTable;
use decompression::addressTable_size;
use decompression::addressTable_getByAddressAlloc;
use decompression::addressTable_getByAddress;
use decompression::addressTable_getByIndex;
use decompression::decompressAddress;
use decompression::getFromFunctionTable;
use decompression::functionTableSize;
use decompression::getFromFunctionTable;

use std::rlp::rlp_encodeUint;
use std::rlp::rlp_encodeAddress;

use std::bls::bls_makeKey;
use std::bls::bls_marshalPublicKey;

use decompression::parseAggregatorFunctionTable;

use codeSegment::pcTableForCode;


impure func ArbAddressTable_register(_topFrame: EvmCallFrame, addr: address) -> uint {
// return the index of addr in the address table
// if addr isn't in the table already, add it to the table and return its new index
    let (atab, idx, changed) = addressTable_getByAddressAlloc(getGlobalAddressTable(), addr);
    if (changed) {
        evmCallStack_addStorageCharge(2);   // charge current tx for 2 storage cells
        setGlobalAddressTable(atab);
    }
    return idx;
}

impure func ArbAddressTable_lookup(_topFrame: EvmCallFrame, addr: address) -> uint {
// return the index of addr in the address table; revert if it's not in the table
    if let Some(idx) = addressTable_getByAddress(getGlobalAddressTable(), addr) {
        return idx;
    } else {
        evmOp_revert_knownCodePc(address(const::Address_ArbAddressTable), 122, 0, 0);
    }
}

impure func ArbAddressTable_addressExists(_topFrame: EvmCallFrame, addr: address) -> bool {
// return true iff addr is in the address table
    return addressTable_getByAddress(getGlobalAddressTable(), addr) != None<uint>;
}

impure func ArbAddressTable_size(_topFrame: EvmCallFrame) -> uint {
// return the number of items in the address table
    return addressTable_size(getGlobalAddressTable());
}

impure func ArbAddressTable_lookupIndex(_topFrame: EvmCallFrame, index: uint) -> address {
// return the address at slot index in the address table, or revert if index is beyond the end of the table
    if let Some(addr) = addressTable_getByIndex(getGlobalAddressTable(), index) {
        return addr;
    } else {
        evmOp_revert_knownCodePc(address(const::Address_ArbAddressTable), 152, 0, 0);
    }
}

impure func ArbAddressTable_decompress(_topFrame: EvmCallFrame, buf: ByteArray, offset: uint) -> (address, uint) {
    // read a compressed address from buf at offset, return (resulting address, updated offset)
    // revert if buf is too short
    let stream = bytestream_new(buf);
    if let Some(res) = decompressAddress(stream) {
        let (ustr, addr) = res;
        stream = ustr;
        return (addr, offset+bytestream_bytesReadSoFar(stream));
    } else {
        // input was too short
        evmOp_revert_knownCodePc(address(const::Address_ArbAddressTable), 163, 0, 0);
    }
}

impure func ArbAddressTable_compress(_topFrame: EvmCallFrame, addr: address) -> ByteArray {
// compress addr, based on the current address table contents, and return the resulting buffer
    let compressedData = bytearray_new(0);
    let compressedDataLen = 0;
    if let Some(index) = addressTable_getByAddress(getGlobalAddressTable(), addr) {
        let (ba, sz) = rlp_encodeUint(index, compressedData, 0);
        compressedData = ba;
        compressedDataLen = sz;
    } else {
        let (ba, sz) = rlp_encodeAddress(addr, compressedData, 0);
        compressedData = ba;
        compressedDataLen = sz;
    }
    return compressedData;
}
