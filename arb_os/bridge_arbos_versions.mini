
//
// This file is machine-generated. Don't edit it unless you know what you're doing.
//
// Copyright 2020-2021, Offchain Labs, Inc. All rights reserved.
//

use customize_arbos_bridge_versions::set_addressRemapExceptions_onUpgrade;
use customize_arbos_bridge_versions::set_chainOwners_onUpgrade;
use customize_arbos_bridge_versions::set_globalAccountStore_onUpgrade;
use customize_arbos_bridge_versions::set_globalBlockReceiptData_onUpgrade;
use customize_arbos_bridge_versions::set_globalCallStack_onUpgrade;
use customize_arbos_bridge_versions::set_globalCurrentRetryableRequest_onUpgrade;
use customize_arbos_bridge_versions::set_globalCurrentTxRequest_onUpgrade;
use customize_arbos_bridge_versions::set_globalInputQueue_onUpgrade;
use customize_arbos_bridge_versions::set_globalChainParameters_onUpgrade;

type before__accounts_Account = struct {
    addr: address,
    blsKey: option<before__accounts_BLSKey> ,
    nextSeqNum: uint,
    ethBalance: uint,
    contractInfo: option<before__accounts_AccountContractInfo> ,
    aggregatorInfo: option<before__accounts_AggregatorInfo> ,
    aggregatorToPay: option<address> ,
};
type before__accounts_AccountContractInfo = struct {
    code: before__accounts_ByteArray,
    evmJumpTable: map<uint,view write func()>,
    startCodePoint: view write func(),
    storage: before__accounts_StorageMap,
};
type before__accounts_AggregatorDecompressionState = struct {
    functionTable: before__decompression_FunctionTable,
};
type before__accounts_AggregatorInfo = struct {
    decompressionState: option<before__accounts_AggregatorDecompressionState> ,
    feeCollector: address,
    baseTxFeeL1Gas: uint,
};
type before__accounts_BLSKey = struct {
    ax: uint,
    ay: uint,
    bx: uint,
    by: uint,
};
type before__accounts_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type before__accounts_CodeRef = struct {
    refCount: uint,
    code: before__accounts_ByteArray,
    evmJumpTable: map<uint,view write func()>,
    startCodePoint: view write func(),
};
type before__accounts_EscrowStore = struct {
    nextKey: uint,
    escrowedValues: before__accounts_StorageMap,
};
type before__accounts_RetryBuffer = struct {
    byTxId: map<uint,before__retrybuffer_RetryableTx>,
    fifo: before__retrybuffer_Queue,
    txLifetimeSeconds: uint,
};
type before__accounts_StorageMap = struct {
    tree: before__std_storageMap_StorageMapNode,
    size: uint,
};
type before__arbowner_AvmCodeBuilder = struct {
    requireSafe: bool,
    code: before__std_avmcodebuilder_AvmCodePoint,
    size: uint,
    codeMap: map<uint,before__std_avmcodebuilder_AvmCodePoint>,
};
type before__codeSegment_AvmCodePoint = view write func();
type before__decompression_ExpandingIntArray = struct {
    size: uint,
    chunk: uint,
    contents: [8]any,
};
type before__decompression_FunctionTable = []before__decompression_FunctionTableEntry;
type before__decompression_FunctionTableEntry = struct {
    callDataPrefix: any,
    maxGas: uint,
    payable: bool,
};
type before__evmCallStack_Account = struct {
    addr: address,
    blsKey: option<before__accounts_BLSKey> ,
    nextSeqNum: uint,
    ethBalance: uint,
    contractInfo: option<before__accounts_AccountContractInfo> ,
    aggregatorInfo: option<before__accounts_AggregatorInfo> ,
    aggregatorToPay: option<address> ,
};
type before__evmCallStack_AccountStore = struct {
    accounts: map<address,before__accounts_Account>,
    retryBuffer: before__accounts_RetryBuffer,
    numContracts: uint,
    codeRefTable: map<bytes32,before__accounts_CodeRef>,
    escrowStore: before__accounts_EscrowStore,
};
type before__evmCallStack_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type before__evmCallStack_EvmCallFrame = struct {
    runningAs: address,
    runningCodeFrom: address,
    accountStore: before__evmCallStack_AccountStore,
    runningAsAccount: before__evmCallStack_Account,
    caller: address,
    static: bool,
    calldata: before__evmCallStack_ByteArray,
    callvalue: uint,
    returnInfo: option<before__evmCallStack_ReturnInfo> ,
    memory: before__evmCallStack_ByteArray,
    storageDelta: int,
    revertOnStorageWrite: bool,
    evmLogs: before__evmCallStack_EvmLogs,
    selfDestructQueue: before__evmCallStack_Queue,
    resumeInfo: option<before__evmCallStack_ResumeInfo> ,
    sendQueue: before__evmCallStack_Queue,
    sendOnFailure: option<before__evmCallStack_ByteArray> ,
    parent: option<before__evmCallStack_EvmCallFrame> ,
};
type before__evmCallStack_EvmLogs = struct {
    last: any,
    rest: any,
};
type before__evmCallStack_IncomingRequest = struct {
    kind: uint,
    arbBlockNumber: uint,
    ethBlockNumber: uint,
    timestamp: uint,
    sender: address,
    requestId: uint,
    msgData: before__inbox_ByteArray,
    provenance: before__inbox_RequestProvenance,
    aggregator: option<before__inbox_AggregatorInfo> ,
    adminMode: bool,
    gasEstimationParams: option<before__inbox_GasEstimationParams> ,
};
type before__evmCallStack_IncomingRequestAndLogs = struct {
    req: before__evmCallStack_IncomingRequest,
    evmLogs: before__evmCallStack_EvmLogs,
};
type before__evmCallStack_Queue = before__std_queue_BoundedQueue;
type before__evmCallStack_ResumeInfo = struct {
    codePoint: func(),
    stackContents: before__evmCallStack_Stack,
    auxStackContents: option<before__evmCallStack_Stack> ,
    returnDataOffset: uint,
    returnDataNbytes: uint,
    callType: uint,
    savedGas: uint,
    givenGas: uint,
};
type before__evmCallStack_ReturnInfo = struct {
    data: before__evmCallStack_ByteArray,
    status: bool,
};
type before__evmCallStack_Stack = option<before__std_stack_StackCell> ;
type before__gasAccounting_CongestionState = struct {
    gasPool: int,
    lastArbBlockNumSeen: uint,
    lastTimestampSeen: uint,
    congestionPriceWei: uint,
};
type before__gasAccounting_FeeConfig = struct {
    baseFeeMultiplier: before__gasAccounting_FixedPoint,
    shareForNetFee: before__gasAccounting_FixedPoint,
};
type before__gasAccounting_FixedPoint = struct {
    val: uint,
    shiftFactor: uint,
};
type before__gasAccounting_FourResources = struct {
    tx: uint,
    calldataUnit: uint,
    storage: uint,
    compute: uint,
};
type before__gasAccounting_GasPrices = struct {
    perL1CalldataUnit: uint,
    perStorageCell: uint,
    perArbGasBase: uint,
    perArbGasCongestion: uint,
    perArbGasTotal: uint,
};
type before__gasAccounting_PricingParameters = struct {
    l1GasPerL1CalldataUnit: uint,
    l1GasPerStorage: uint,
    arbGasDivisor: uint,
};
type before__gasAccounting_RetryablePrices = struct {
    perTx: uint,
    perCalldataByte: uint,
    nextUpdateTimestamp: uint,
};
type before__gasAccounting_SetOfAddresses = struct {
    contents: before__std_addressSet_StorageMap,
    inverted: bool,
};
type before__gasAccounting_TxGasState = struct {
    gasInReserve: uint,
    gasReservedForStorage: uint,
    originalMax: uint,
    price: uint,
    weiHeldForGas: uint,
    refundTo: address,
};
type before__inbox_AggregatorInfo = struct {
    aggregator: option<address> ,
    calldataUnits: uint,
};
type before__inbox_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type before__inbox_GasEstimationParams = struct {
    computeGasLimit: uint,
    ignoreGasPrice: bool,
    ignoreMaxGas: bool,
};
type before__inbox_IncomingRequest = struct {
    kind: uint,
    arbBlockNumber: uint,
    ethBlockNumber: uint,
    timestamp: uint,
    sender: address,
    requestId: uint,
    msgData: before__inbox_ByteArray,
    provenance: before__inbox_RequestProvenance,
    aggregator: option<before__inbox_AggregatorInfo> ,
    adminMode: bool,
    gasEstimationParams: option<before__inbox_GasEstimationParams> ,
};
type before__inbox_IncomingRequestQueue = struct {
    q: before__inbox_Queue,
};
type before__inbox_IncomingRequestQueueStack = struct {
    qs: before__inbox_QueueStack,
};
type before__inbox_Queue = before__std_queue_BoundedQueue;
type before__inbox_QueueStack = option<before__std_queue_QueueStackCell> ;
type before__inbox_RequestProvenance = struct {
    l1SeqNum: uint,
    parentRequestId: uint,
    indexInParent: uint,
};
type before__inbox_TxRequestQueue = struct {
    q: before__inbox_Queue,
};
type before__messages_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type before__messages_IncomingRequest = struct {
    kind: uint,
    arbBlockNumber: uint,
    ethBlockNumber: uint,
    timestamp: uint,
    sender: address,
    requestId: uint,
    msgData: before__inbox_ByteArray,
    provenance: before__inbox_RequestProvenance,
    aggregator: option<before__inbox_AggregatorInfo> ,
    adminMode: bool,
    gasEstimationParams: option<before__inbox_GasEstimationParams> ,
};
type before__messages_RetryableTx = struct {
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    callvalueEscrowKey: uint,
    beneficiary: address,
    calldata: before__retrybuffer_ByteArray,
    expiryTime: uint,
    l1Message: before__retrybuffer_IncomingRequest,
};
type before__messages_TxFeeStats = struct {
    price: before__gasAccounting_FourResources,
    units: before__gasAccounting_FourResources,
    weiPaid: before__gasAccounting_FourResources,
    paidAggregator: address,
    noFeeGasEstimationMode: bool,
};
type before__output_EvmTracer = struct {
    recordStack: before__tracing_Stack,
};
type before__output_MerkleTreeBuilder = struct {
    contents: before__std_merkletree_Queue,
};
type before__output_OutputStatistics = struct {
    totalGasUsed: uint,
    numTx: uint,
    numEvmLogs: uint,
    numLogs: uint,
    numSends: uint,
};
type before__output_PerBlockReceiptData = struct {
    totalGasUsed: uint,
    numTx: uint,
    numEvmLogs: uint,
};
type before__pluggables_ModuleFunction = view write func(any, any, bool, view write func(uint, any, ) -> option<any> , ) -> (any, any, );
type before__pluggables_ModuleState = struct {
    code: before__pluggables_ModuleFunction,
    state: any,
    neverBeenCalled: bool,
};
type before__retrybuffer_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type before__retrybuffer_IncomingRequest = struct {
    kind: uint,
    arbBlockNumber: uint,
    ethBlockNumber: uint,
    timestamp: uint,
    sender: address,
    requestId: uint,
    msgData: before__inbox_ByteArray,
    provenance: before__inbox_RequestProvenance,
    aggregator: option<before__inbox_AggregatorInfo> ,
    adminMode: bool,
    gasEstimationParams: option<before__inbox_GasEstimationParams> ,
};
type before__retrybuffer_Queue = before__std_queue_BoundedQueue;
type before__retrybuffer_RetryableTx = struct {
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    callvalueEscrowKey: uint,
    beneficiary: address,
    calldata: before__retrybuffer_ByteArray,
    expiryTime: uint,
    l1Message: before__retrybuffer_IncomingRequest,
};
type before__std_addressSet_StorageMap = struct {
    tree: before__std_storageMap_StorageMapNode,
    size: uint,
};
type before__std_avmcodebuilder_AvmCodePoint = view write func();
type before__std_merkletree_Queue = before__std_queue_BoundedQueue;
type before__std_queue_Queue = before__std_queue_BoundedQueue;
type before__std_queue_QueueStack = option<before__std_queue_QueueStackCell> ;
type before__std_queue_QueueStackCell = struct {
    head: before__std_queue_Queue,
    rest: before__std_queue_QueueStack,
};
type before__std_stack_StackCell = struct {
    top: [8]any,
    num: uint,
    rest: option<before__std_stack_StackCell> ,
};
type before__std_storageMap_StorageMapNode = [8]any;
type before__tracing_Stack = option<before__std_stack_StackCell> ;
type before__std_queue_BoundedQueue = struct {
    capacity: uint,
    nextPut: uint,
    nextGet: uint,
    contents: []any,
};
type after__accounts_Account = struct {
    addr: address,
    blsKey: option<after__accounts_BLSKey> ,
    nextSeqNum: uint,
    ethBalance: uint,
    contractInfo: option<after__accounts_AccountContractInfo> ,
    aggregatorInfo: option<after__accounts_AggregatorInfo> ,
    aggregatorToPay: option<address> ,
};
type after__accounts_AccountContractInfo = struct {
    code: after__accounts_ByteArray,
    evmJumpTable: map<uint,view write func()>,
    startCodePoint: view write func(),
    storage: after__accounts_StorageMap,
};
type after__accounts_AggregatorDecompressionState = struct {
    functionTable: after__decompression_FunctionTable,
};
type after__accounts_AggregatorInfo = struct {
    decompressionState: option<after__accounts_AggregatorDecompressionState> ,
    feeCollector: address,
    baseTxFeeL1Gas: uint,
};
type after__accounts_BLSKey = struct {
    ax: uint,
    ay: uint,
    bx: uint,
    by: uint,
};
type after__accounts_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type after__accounts_CodeRef = struct {
    refCount: uint,
    code: after__accounts_ByteArray,
    evmJumpTable: map<uint,view write func()>,
    startCodePoint: view write func(),
};
type after__accounts_EscrowStore = struct {
    nextKey: uint,
    escrowedValues: after__accounts_StorageMap,
};
type after__accounts_RetryBuffer = struct {
    byTxId: map<uint,after__retrybuffer_RetryableTx>,
    fifo: after__retrybuffer_Queue,
    txLifetimeSeconds: uint,
};
type after__accounts_StorageMap = struct {
    tree: after__std_storageMap_StorageMapNode,
    size: uint,
};
type after__arbowner_AvmCodeBuilder = struct {
    requireSafe: bool,
    code: after__std_avmcodebuilder_AvmCodePoint,
    size: uint,
    codeMap: map<uint,after__std_avmcodebuilder_AvmCodePoint>,
};
type after__decompression_ExpandingIntArray = struct {
    size: uint,
    chunk: uint,
    contents: [8]any,
};
type after__decompression_FunctionTable = []after__decompression_FunctionTableEntry;
type after__decompression_FunctionTableEntry = struct {
    callDataPrefix: any,
    maxGas: uint,
    payable: bool,
};
type after__evmCallStack_Account = struct {
    addr: address,
    blsKey: option<after__accounts_BLSKey> ,
    nextSeqNum: uint,
    ethBalance: uint,
    contractInfo: option<after__accounts_AccountContractInfo> ,
    aggregatorInfo: option<after__accounts_AggregatorInfo> ,
    aggregatorToPay: option<address> ,
};
type after__evmCallStack_AccountStore = struct {
    accounts: map<address,after__accounts_Account>,
    retryBuffer: after__accounts_RetryBuffer,
    numContracts: uint,
    codeRefTable: map<bytes32,after__accounts_CodeRef>,
    escrowStore: after__accounts_EscrowStore,
};
type after__evmCallStack_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type after__evmCallStack_EvmCallFrame = struct {
    runningAs: address,
    runningCodeFrom: address,
    accountStore: after__evmCallStack_AccountStore,
    runningAsAccount: after__evmCallStack_Account,
    caller: address,
    isConstructor: bool,
    static: bool,
    calldata: after__evmCallStack_ByteArray,
    callvalue: uint,
    returnInfo: option<after__evmCallStack_ReturnInfo> ,
    memory: after__evmCallStack_ByteArray,
    maxMemoryOffsetTouched: uint,
    storageDelta: int,
    revertOnStorageWrite: bool,
    evmLogs: after__evmCallStack_EvmLogs,
    selfDestructQueue: after__evmCallStack_Queue,
    resumeInfo: option<after__evmCallStack_ResumeInfo> ,
    sendQueue: after__evmCallStack_Queue,
    sendOnFailure: option<after__evmCallStack_ByteArray> ,
    parent: option<after__evmCallStack_EvmCallFrame> ,
};
type after__evmCallStack_EvmLogs = struct {
    last: any,
    rest: after__evmlogs_EvmLogs,
};
type after__evmCallStack_IncomingRequest = struct {
    kind: uint,
    arbBlockNumber: uint,
    ethBlockNumber: uint,
    timestamp: uint,
    sender: address,
    requestId: uint,
    msgData: after__inbox_ByteArray,
    provenance: after__inbox_RequestProvenance,
    aggregator: option<after__inbox_AggregatorInfo> ,
    adminMode: bool,
    gasEstimationParams: option<after__inbox_GasEstimationParams> ,
};
type after__evmCallStack_IncomingRequestAndLogs = struct {
    req: after__evmCallStack_IncomingRequest,
    evmLogs: after__evmCallStack_EvmLogs,
    originalSender: address,
};
type after__evmCallStack_Queue = after__std_queue_BoundedQueue;
type after__evmCallStack_ResumeInfo = struct {
    codePoint: func(),
    stackContents: after__evmCallStack_Stack,
    auxStackContents: option<after__evmCallStack_Stack> ,
    returnDataOffset: uint,
    returnDataNbytes: uint,
    callType: uint,
    savedGas: uint,
    givenGas: uint,
};
type after__evmCallStack_ReturnInfo = struct {
    data: after__evmCallStack_ByteArray,
    status: bool,
};
type after__evmCallStack_Stack = option<after__std_stack_StackCell> ;
type after__evmlogs_EvmLogs = struct {
    last: any,
    rest: after__evmlogs_EvmLogs,
};
type after__gasAccounting_CongestionState = struct {
    gasPool: int,
    lastArbBlockNumSeen: uint,
    lastTimestampSeen: uint,
    congestionPriceWei: uint,
};
type after__gasAccounting_FeeConfig = struct {
    baseFeeMultiplier: after__gasAccounting_FixedPoint,
    shareForNetFee: after__gasAccounting_FixedPoint,
};
type after__gasAccounting_FixedPoint = struct {
    val: uint,
    shiftFactor: uint,
};
type after__gasAccounting_FourResources = struct {
    tx: uint,
    calldataUnit: uint,
    storage: uint,
    compute: uint,
};
type after__gasAccounting_GasPrices = struct {
    perL1CalldataUnit: uint,
    perStorageCell: uint,
    perArbGasBase: uint,
    perArbGasCongestion: uint,
    perArbGasTotal: uint,
};
type after__gasAccounting_PricingParameters = struct {
    l1GasPerL1CalldataUnit: uint,
    l1GasPerStorage: uint,
    arbGasDivisor: uint,
};
type after__gasAccounting_RetryablePrices = struct {
    perTx: uint,
    perCalldataByte: uint,
    nextUpdateTimestamp: uint,
};
type after__gasAccounting_SetOfAddresses = struct {
    contents: after__std_addressSet_StorageMap,
    inverted: bool,
};
type after__gasAccounting_TxGasState = struct {
    gasInReserve: uint,
    gasReservedForStorage: uint,
    originalMax: uint,
    price: uint,
    weiHeldForGas: uint,
    refundTo: address,
};
type after__inbox_AggregatorInfo = struct {
    aggregator: option<address> ,
    calldataUnits: uint,
};
type after__inbox_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type after__inbox_GasEstimationParams = struct {
    computeGasLimit: uint,
    ignoreGasPrice: bool,
    ignoreMaxGas: bool,
};
type after__inbox_IncomingRequest = struct {
    kind: uint,
    arbBlockNumber: uint,
    ethBlockNumber: uint,
    timestamp: uint,
    sender: address,
    requestId: uint,
    msgData: after__inbox_ByteArray,
    provenance: after__inbox_RequestProvenance,
    aggregator: option<after__inbox_AggregatorInfo> ,
    adminMode: bool,
    gasEstimationParams: option<after__inbox_GasEstimationParams> ,
};
type after__inbox_IncomingRequestQueue = struct {
    q: after__inbox_Queue,
};
type after__inbox_IncomingRequestQueueStack = struct {
    qs: after__inbox_QueueStack,
};
type after__inbox_Queue = after__std_queue_BoundedQueue;
type after__inbox_QueueStack = option<after__std_queue_QueueStackCell> ;
type after__inbox_RequestProvenance = struct {
    l1SeqNum: uint,
    parentRequestId: uint,
    indexInParent: uint,
};
type after__inbox_TxRequestQueue = struct {
    q: after__inbox_Queue,
};
type after__messages_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type after__messages_IncomingRequest = struct {
    kind: uint,
    arbBlockNumber: uint,
    ethBlockNumber: uint,
    timestamp: uint,
    sender: address,
    requestId: uint,
    msgData: after__inbox_ByteArray,
    provenance: after__inbox_RequestProvenance,
    aggregator: option<after__inbox_AggregatorInfo> ,
    adminMode: bool,
    gasEstimationParams: option<after__inbox_GasEstimationParams> ,
};
type after__messages_RetryableTx = struct {
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    callvalueEscrowKey: uint,
    beneficiary: address,
    calldata: after__retrybuffer_ByteArray,
    expiryTime: uint,
    l1Message: after__retrybuffer_IncomingRequest,
    originalSender: address,
};
type after__messages_TxFeeStats = struct {
    price: after__gasAccounting_FourResources,
    units: after__gasAccounting_FourResources,
    weiPaid: after__gasAccounting_FourResources,
    paidAggregator: address,
    noFeeGasEstimationMode: bool,
};
type after__output_EvmTracer = struct {
    recordStack: after__tracing_Stack,
};
type after__output_MerkleTreeBuilder = struct {
    contents: after__std_merkletree_Queue,
};
type after__output_OutputStatistics = struct {
    totalGasUsed: uint,
    numTx: uint,
    numEvmLogs: uint,
    numLogs: uint,
    numSends: uint,
};
type after__output_PerBlockReceiptData = struct {
    totalGasUsed: uint,
    numTx: uint,
    numEvmLogs: uint,
};
type after__retrybuffer_ByteArray = struct {
    size: uint,
    sliceOffset: uint,
    contents: buffer,
};
type after__retrybuffer_IncomingRequest = struct {
    kind: uint,
    arbBlockNumber: uint,
    ethBlockNumber: uint,
    timestamp: uint,
    sender: address,
    requestId: uint,
    msgData: after__inbox_ByteArray,
    provenance: after__inbox_RequestProvenance,
    aggregator: option<after__inbox_AggregatorInfo> ,
    adminMode: bool,
    gasEstimationParams: option<after__inbox_GasEstimationParams> ,
};
type after__retrybuffer_Queue = after__std_queue_BoundedQueue;
type after__retrybuffer_RetryableTx = struct {
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    callvalueEscrowKey: uint,
    beneficiary: address,
    calldata: after__retrybuffer_ByteArray,
    expiryTime: uint,
    l1Message: after__retrybuffer_IncomingRequest,
    originalSender: address,
};
type after__std_addressSet_StorageMap = struct {
    tree: after__std_storageMap_StorageMapNode,
    size: uint,
};
type after__std_avmcodebuilder_AvmCodePoint = view write func();
type after__std_codeSegment_AvmCodePoint = view write func();
type after__std_merkletree_Queue = after__std_queue_BoundedQueue;
type after__std_queue_Queue = after__std_queue_BoundedQueue;
type after__std_queue_QueueStack = option<after__std_queue_QueueStackCell> ;
type after__std_queue_QueueStackCell = struct {
    head: after__std_queue_Queue,
    rest: after__std_queue_QueueStack,
};
type after__std_stack_StackCell = struct {
    top: [8]any,
    num: uint,
    rest: option<after__std_stack_StackCell> ,
};
type after__std_storageMap_StorageMapNode = [8]any;
type after__tracing_Stack = option<after__std_stack_StackCell> ;
type after__std_queue_BoundedQueue = struct {
    capacity: uint,
    nextPut: uint,
    nextGet: uint,
    contents: []any,
};

type GlobalsBeforeUpgrade = struct {
    __fixedLocationGlobal: view write func(uint, ),
    moduleManager: struct {
        capacity: uint,
        modules: []option<struct {
            code: view write func(any, any, bool, view write func(uint, any, ) -> option<any> , ) -> (any, any, ),
            state: any,
            neverBeenCalled: bool,
        }> ,
    },
    globalBlockReceiptData: struct {
        data: struct {
            totalGasUsed: uint,
            numTx: uint,
            numEvmLogs: uint,
        },
        statsThisBlock: struct {
            totalGasUsed: uint,
            numTx: uint,
            numEvmLogs: uint,
            numLogs: uint,
            numSends: uint,
        },
        statsAllTime: struct {
            totalGasUsed: uint,
            numTx: uint,
            numEvmLogs: uint,
            numLogs: uint,
            numSends: uint,
        },
        lastBlockNum: uint,
        nextSendTime: uint,
    },
    logsQueuedForEndOfBlock: before__std_queue_BoundedQueue,
    globalOutbox: struct {
        batch: struct {
            contents: before__std_queue_BoundedQueue,
        },
        batchNumber: uint,
        numInBatch: uint,
        evmTracer: struct {
            recordStack: option<struct {
                top: [8]any,
                num: uint,
                rest: option<before__std_stack_StackCell> ,
            }> ,
        },
    },
    globalInbox: struct {
        queue: struct {
            q: before__std_queue_BoundedQueue,
        },
        arbBlockNum: uint,
        ethBlockNum: uint,
        timestamp: uint,
        atStartOfBlock: bool,
        inboxHashAccumulator: bytes32,
        pendingMessage: option<struct {
            kind: uint,
            arbBlockNumber: uint,
            ethBlockNumber: uint,
            timestamp: uint,
            sender: address,
            requestId: uint,
            msgData: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            provenance: struct {
                l1SeqNum: uint,
                parentRequestId: uint,
                indexInParent: uint,
            },
            aggregator: option<struct {
                aggregator: option<address> ,
                calldataUnits: uint,
            }> ,
            adminMode: bool,
            gasEstimationParams: option<struct {
                computeGasLimit: uint,
                ignoreGasPrice: bool,
                ignoreMaxGas: bool,
            }> ,
        }> ,
    },
    globalInputQueue: struct {
        txQ: struct {
            q: before__std_queue_BoundedQueue,
        },
        batchQ: struct {
            qs: option<struct {
                head: before__std_queue_BoundedQueue,
                rest: option<before__std_queue_QueueStackCell> ,
            }> ,
        },
    },
    gasAccountingInfo: struct {
        txState: option<struct {
            gasInReserve: uint,
            gasReservedForStorage: uint,
            originalMax: uint,
            price: uint,
            weiHeldForGas: uint,
            refundTo: address,
        }> ,
        feeConfig: struct {
            baseFeeMultiplier: struct {
                val: uint,
                shiftFactor: uint,
            },
            shareForNetFee: struct {
                val: uint,
                shiftFactor: uint,
            },
        },
        currentPrices: struct {
            perL1CalldataUnit: uint,
            perStorageCell: uint,
            perArbGasBase: uint,
            perArbGasCongestion: uint,
            perArbGasTotal: uint,
        },
        gasRemainingThisBlock: uint,
        congestionState: struct {
            gasPool: int,
            lastArbBlockNumSeen: uint,
            lastTimestampSeen: uint,
            congestionPriceWei: uint,
        },
        speedLimitPerSecond: uint,
        pricingParams: struct {
            l1GasPerL1CalldataUnit: uint,
            l1GasPerStorage: uint,
            arbGasDivisor: uint,
        },
        gasAllocatedToThisBlock: uint,
        retryablePrices: struct {
            perTx: uint,
            perCalldataByte: uint,
            nextUpdateTimestamp: uint,
        },
        allowedSenders: struct {
            contents: struct {
                tree: [8]any,
                size: uint,
            },
            inverted: bool,
        },
    },
    globalL1GasPriceEstimator: struct {
        estimateWei: uint,
        fairGasPriceSenders: struct {
            contents: struct {
                tree: [8]any,
                size: uint,
            },
            inverted: bool,
        },
    },
    evmOpJumpTable: [48]view write func(),
    globalCallStack: option<struct {
        runningAs: address,
        runningCodeFrom: address,
        accountStore: struct {
            accounts: map<address,struct {
                addr: address,
                blsKey: option<struct {
                    ax: uint,
                    ay: uint,
                    bx: uint,
                    by: uint,
                }> ,
                nextSeqNum: uint,
                ethBalance: uint,
                contractInfo: option<struct {
                    code: struct {
                        size: uint,
                        sliceOffset: uint,
                        contents: buffer,
                    },
                    evmJumpTable: map<uint,view write func()>,
                    startCodePoint: view write func(),
                    storage: struct {
                        tree: [8]any,
                        size: uint,
                    },
                }> ,
                aggregatorInfo: option<struct {
                    decompressionState: option<struct {
                        functionTable: []struct {
                            callDataPrefix: any,
                            maxGas: uint,
                            payable: bool,
                        },
                    }> ,
                    feeCollector: address,
                    baseTxFeeL1Gas: uint,
                }> ,
                aggregatorToPay: option<address> ,
            }>,
            retryBuffer: struct {
                byTxId: map<uint,struct {
                    txId: uint,
                    sender: address,
                    destination: address,
                    callvalue: uint,
                    callvalueEscrowKey: uint,
                    beneficiary: address,
                    calldata: struct {
                        size: uint,
                        sliceOffset: uint,
                        contents: buffer,
                    },
                    expiryTime: uint,
                    l1Message: struct {
                        kind: uint,
                        arbBlockNumber: uint,
                        ethBlockNumber: uint,
                        timestamp: uint,
                        sender: address,
                        requestId: uint,
                        msgData: struct {
                            size: uint,
                            sliceOffset: uint,
                            contents: buffer,
                        },
                        provenance: struct {
                            l1SeqNum: uint,
                            parentRequestId: uint,
                            indexInParent: uint,
                        },
                        aggregator: option<struct {
                            aggregator: option<address> ,
                            calldataUnits: uint,
                        }> ,
                        adminMode: bool,
                        gasEstimationParams: option<struct {
                            computeGasLimit: uint,
                            ignoreGasPrice: bool,
                            ignoreMaxGas: bool,
                        }> ,
                    },
                }>,
                fifo: before__std_queue_BoundedQueue,
                txLifetimeSeconds: uint,
            },
            numContracts: uint,
            codeRefTable: map<bytes32,struct {
                refCount: uint,
                code: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                evmJumpTable: map<uint,view write func()>,
                startCodePoint: view write func(),
            }>,
            escrowStore: struct {
                nextKey: uint,
                escrowedValues: struct {
                    tree: [8]any,
                    size: uint,
                },
            },
        },
        runningAsAccount: struct {
            addr: address,
            blsKey: option<struct {
                ax: uint,
                ay: uint,
                bx: uint,
                by: uint,
            }> ,
            nextSeqNum: uint,
            ethBalance: uint,
            contractInfo: option<struct {
                code: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                evmJumpTable: map<uint,view write func()>,
                startCodePoint: view write func(),
                storage: struct {
                    tree: [8]any,
                    size: uint,
                },
            }> ,
            aggregatorInfo: option<struct {
                decompressionState: option<struct {
                    functionTable: []struct {
                        callDataPrefix: any,
                        maxGas: uint,
                        payable: bool,
                    },
                }> ,
                feeCollector: address,
                baseTxFeeL1Gas: uint,
            }> ,
            aggregatorToPay: option<address> ,
        },
        caller: address,
        static: bool,
        calldata: struct {
            size: uint,
            sliceOffset: uint,
            contents: buffer,
        },
        callvalue: uint,
        returnInfo: option<struct {
            data: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            status: bool,
        }> ,
        memory: struct {
            size: uint,
            sliceOffset: uint,
            contents: buffer,
        },
        storageDelta: int,
        revertOnStorageWrite: bool,
        evmLogs: struct {
            last: any,
            rest: any,
        },
        selfDestructQueue: before__std_queue_BoundedQueue,
        resumeInfo: option<struct {
            codePoint: func(),
            stackContents: option<struct {
                top: [8]any,
                num: uint,
                rest: option<before__std_stack_StackCell> ,
            }> ,
            auxStackContents: option<option<struct {
                top: [8]any,
                num: uint,
                rest: option<before__std_stack_StackCell> ,
            }> > ,
            returnDataOffset: uint,
            returnDataNbytes: uint,
            callType: uint,
            savedGas: uint,
            givenGas: uint,
        }> ,
        sendQueue: before__std_queue_BoundedQueue,
        sendOnFailure: option<struct {
            size: uint,
            sliceOffset: uint,
            contents: buffer,
        }> ,
        parent: option<before__evmCallStack_EvmCallFrame> ,
    }> ,
    globalCurrentTxRequest: struct {
        maxGas: uint,
        gasPrice: uint,
        seqNum: option<uint> ,
        caller: address,
        calleeAddr: address,
        gasPayer: address,
        value: uint,
        calldata: struct {
            size: uint,
            sliceOffset: uint,
            contents: buffer,
        },
        nonMutating: bool,
        isConstructor: bool,
        incomingRequest: struct {
            kind: uint,
            arbBlockNumber: uint,
            ethBlockNumber: uint,
            timestamp: uint,
            sender: address,
            requestId: uint,
            msgData: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            provenance: struct {
                l1SeqNum: uint,
                parentRequestId: uint,
                indexInParent: uint,
            },
            aggregator: option<struct {
                aggregator: option<address> ,
                calldataUnits: uint,
            }> ,
            adminMode: bool,
            gasEstimationParams: option<struct {
                computeGasLimit: uint,
                ignoreGasPrice: bool,
                ignoreMaxGas: bool,
            }> ,
        },
        feeStats: struct {
            price: struct {
                tx: uint,
                calldataUnit: uint,
                storage: uint,
                compute: uint,
            },
            units: struct {
                tx: uint,
                calldataUnit: uint,
                storage: uint,
                compute: uint,
            },
            weiPaid: struct {
                tx: uint,
                calldataUnit: uint,
                storage: uint,
                compute: uint,
            },
            paidAggregator: address,
            noFeeGasEstimationMode: bool,
        },
        fromRetryable: option<struct {
            txId: uint,
            sender: address,
            destination: address,
            callvalue: uint,
            callvalueEscrowKey: uint,
            beneficiary: address,
            calldata: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            expiryTime: uint,
            l1Message: struct {
                kind: uint,
                arbBlockNumber: uint,
                ethBlockNumber: uint,
                timestamp: uint,
                sender: address,
                requestId: uint,
                msgData: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                provenance: struct {
                    l1SeqNum: uint,
                    parentRequestId: uint,
                    indexInParent: uint,
                },
                aggregator: option<struct {
                    aggregator: option<address> ,
                    calldataUnits: uint,
                }> ,
                adminMode: bool,
                gasEstimationParams: option<struct {
                    computeGasLimit: uint,
                    ignoreGasPrice: bool,
                    ignoreMaxGas: bool,
                }> ,
            },
        }> ,
    },
    globalCurrentRetryableRequest: option<struct {
        req: struct {
            kind: uint,
            arbBlockNumber: uint,
            ethBlockNumber: uint,
            timestamp: uint,
            sender: address,
            requestId: uint,
            msgData: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            provenance: struct {
                l1SeqNum: uint,
                parentRequestId: uint,
                indexInParent: uint,
            },
            aggregator: option<struct {
                aggregator: option<address> ,
                calldataUnits: uint,
            }> ,
            adminMode: bool,
            gasEstimationParams: option<struct {
                computeGasLimit: uint,
                ignoreGasPrice: bool,
                ignoreMaxGas: bool,
            }> ,
        },
        evmLogs: struct {
            last: any,
            rest: any,
        },
    }> ,
    inErrorHandler: bool,
    globalIndexedAddressTable: struct {
        byIndex: struct {
            size: uint,
            chunk: uint,
            contents: [8]any,
        },
        byAddress: map<address,uint>,
        size: uint,
    },
    codeSegGlobals: struct {
        unreachableMask: uint,
        dummyAcceptContractCode: view write func(),
    },
    globalChainParameters: map<uint,uint>,
    blockhashes: struct {
        latestBlockNum: uint,
        oldHashes: [256]bytes32,
    },
    arbStats: struct {
        storage: uint,
        arbGasUsed: uint,
        numTxReceipts: uint,
    },
    upgradeInProgress: option<struct {
        requireSafe: bool,
        code: view write func(),
        size: uint,
        codeMap: map<uint,view write func()>,
    }> ,
    previousArbosUpgradeHash: bytes32,
    globalAccountStore: struct {
        accounts: map<address,struct {
            addr: address,
            blsKey: option<struct {
                ax: uint,
                ay: uint,
                bx: uint,
                by: uint,
            }> ,
            nextSeqNum: uint,
            ethBalance: uint,
            contractInfo: option<struct {
                code: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                evmJumpTable: map<uint,view write func()>,
                startCodePoint: view write func(),
                storage: struct {
                    tree: [8]any,
                    size: uint,
                },
            }> ,
            aggregatorInfo: option<struct {
                decompressionState: option<struct {
                    functionTable: []struct {
                        callDataPrefix: any,
                        maxGas: uint,
                        payable: bool,
                    },
                }> ,
                feeCollector: address,
                baseTxFeeL1Gas: uint,
            }> ,
            aggregatorToPay: option<address> ,
        }>,
        retryBuffer: struct {
            byTxId: map<uint,struct {
                txId: uint,
                sender: address,
                destination: address,
                callvalue: uint,
                callvalueEscrowKey: uint,
                beneficiary: address,
                calldata: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                expiryTime: uint,
                l1Message: struct {
                    kind: uint,
                    arbBlockNumber: uint,
                    ethBlockNumber: uint,
                    timestamp: uint,
                    sender: address,
                    requestId: uint,
                    msgData: struct {
                        size: uint,
                        sliceOffset: uint,
                        contents: buffer,
                    },
                    provenance: struct {
                        l1SeqNum: uint,
                        parentRequestId: uint,
                        indexInParent: uint,
                    },
                    aggregator: option<struct {
                        aggregator: option<address> ,
                        calldataUnits: uint,
                    }> ,
                    adminMode: bool,
                    gasEstimationParams: option<struct {
                        computeGasLimit: uint,
                        ignoreGasPrice: bool,
                        ignoreMaxGas: bool,
                    }> ,
                },
            }>,
            fifo: before__std_queue_BoundedQueue,
            txLifetimeSeconds: uint,
        },
        numContracts: uint,
        codeRefTable: map<bytes32,struct {
            refCount: uint,
            code: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            evmJumpTable: map<uint,view write func()>,
            startCodePoint: view write func(),
        }>,
        escrowStore: struct {
            nextKey: uint,
            escrowedValues: struct {
                tree: [8]any,
                size: uint,
            },
        },
    },
    _jump_table: any,
};

type GlobalsAfterUpgrade = struct {
    __fixedLocationGlobal: view write func(uint, ),
    globalBlockReceiptData: struct {
        data: struct {
            totalGasUsed: uint,
            numTx: uint,
            numEvmLogs: uint,
        },
        statsThisBlock: struct {
            totalGasUsed: uint,
            numTx: uint,
            numEvmLogs: uint,
            numLogs: uint,
            numSends: uint,
        },
        statsAllTime: struct {
            totalGasUsed: uint,
            numTx: uint,
            numEvmLogs: uint,
            numLogs: uint,
            numSends: uint,
        },
        lastArbBlockNum: uint,
        nextSendTimestamp: uint,
    },
    logsQueuedForEndOfBlock: after__std_queue_BoundedQueue,
    globalOutbox: struct {
        batch: struct {
            contents: after__std_queue_BoundedQueue,
        },
        batchNumber: uint,
        numInBatch: uint,
        evmTracer: struct {
            recordStack: option<struct {
                top: [8]any,
                num: uint,
                rest: option<after__std_stack_StackCell> ,
            }> ,
        },
    },
    globalInbox: struct {
        queue: struct {
            q: after__std_queue_BoundedQueue,
        },
        arbBlockNum: uint,
        ethBlockNum: uint,
        timestamp: uint,
        atStartOfBlock: bool,
        inboxHashAccumulator: bytes32,
        pendingMessage: option<struct {
            kind: uint,
            arbBlockNumber: uint,
            ethBlockNumber: uint,
            timestamp: uint,
            sender: address,
            requestId: uint,
            msgData: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            provenance: struct {
                l1SeqNum: uint,
                parentRequestId: uint,
                indexInParent: uint,
            },
            aggregator: option<struct {
                aggregator: option<address> ,
                calldataUnits: uint,
            }> ,
            adminMode: bool,
            gasEstimationParams: option<struct {
                computeGasLimit: uint,
                ignoreGasPrice: bool,
                ignoreMaxGas: bool,
            }> ,
        }> ,
    },
    globalInputQueue: struct {
        txQ: struct {
            q: after__std_queue_BoundedQueue,
        },
        batchQ: struct {
            qs: option<struct {
                head: after__std_queue_BoundedQueue,
                rest: option<after__std_queue_QueueStackCell> ,
            }> ,
        },
    },
    addressRemapExceptions: struct {
        contents: map<(uint, uint, ),bool>,
    },
    gasAccountingInfo: struct {
        txState: option<struct {
            gasInReserve: uint,
            gasReservedForStorage: uint,
            originalMax: uint,
            price: uint,
            weiHeldForGas: uint,
            refundTo: address,
        }> ,
        feeConfig: struct {
            baseFeeMultiplier: struct {
                val: uint,
                shiftFactor: uint,
            },
            shareForNetFee: struct {
                val: uint,
                shiftFactor: uint,
            },
        },
        currentPrices: struct {
            perL1CalldataUnit: uint,
            perStorageCell: uint,
            perArbGasBase: uint,
            perArbGasCongestion: uint,
            perArbGasTotal: uint,
        },
        gasRemainingThisBlock: uint,
        congestionState: struct {
            gasPool: int,
            lastArbBlockNumSeen: uint,
            lastTimestampSeen: uint,
            congestionPriceWei: uint,
        },
        speedLimitPerSecond: uint,
        pricingParams: struct {
            l1GasPerL1CalldataUnit: uint,
            l1GasPerStorage: uint,
            arbGasDivisor: uint,
        },
        gasAllocatedToThisBlock: uint,
        retryablePrices: struct {
            perTx: uint,
            perCalldataByte: uint,
            nextUpdateTimestamp: uint,
        },
        allowedSenders: struct {
            contents: struct {
                tree: [8]any,
                size: uint,
            },
            inverted: bool,
        },
    },
    globalL1GasPriceEstimator: struct {
        estimateWei: uint,
        fairGasPriceSenders: struct {
            contents: struct {
                tree: [8]any,
                size: uint,
            },
            inverted: bool,
        },
    },
    evmOpJumpTable: [48]view write func(),
    globalCallStack: option<struct {
        runningAs: address,
        runningCodeFrom: address,
        accountStore: struct {
            accounts: map<address,struct {
                addr: address,
                blsKey: option<struct {
                    ax: uint,
                    ay: uint,
                    bx: uint,
                    by: uint,
                }> ,
                nextSeqNum: uint,
                ethBalance: uint,
                contractInfo: option<struct {
                    code: struct {
                        size: uint,
                        sliceOffset: uint,
                        contents: buffer,
                    },
                    evmJumpTable: map<uint,view write func()>,
                    startCodePoint: view write func(),
                    storage: struct {
                        tree: [8]any,
                        size: uint,
                    },
                }> ,
                aggregatorInfo: option<struct {
                    decompressionState: option<struct {
                        functionTable: []struct {
                            callDataPrefix: any,
                            maxGas: uint,
                            payable: bool,
                        },
                    }> ,
                    feeCollector: address,
                    baseTxFeeL1Gas: uint,
                }> ,
                aggregatorToPay: option<address> ,
            }>,
            retryBuffer: struct {
                byTxId: map<uint,struct {
                    txId: uint,
                    sender: address,
                    destination: address,
                    callvalue: uint,
                    callvalueEscrowKey: uint,
                    beneficiary: address,
                    calldata: struct {
                        size: uint,
                        sliceOffset: uint,
                        contents: buffer,
                    },
                    expiryTime: uint,
                    l1Message: struct {
                        kind: uint,
                        arbBlockNumber: uint,
                        ethBlockNumber: uint,
                        timestamp: uint,
                        sender: address,
                        requestId: uint,
                        msgData: struct {
                            size: uint,
                            sliceOffset: uint,
                            contents: buffer,
                        },
                        provenance: struct {
                            l1SeqNum: uint,
                            parentRequestId: uint,
                            indexInParent: uint,
                        },
                        aggregator: option<struct {
                            aggregator: option<address> ,
                            calldataUnits: uint,
                        }> ,
                        adminMode: bool,
                        gasEstimationParams: option<struct {
                            computeGasLimit: uint,
                            ignoreGasPrice: bool,
                            ignoreMaxGas: bool,
                        }> ,
                    },
                    originalSender: address,
                }>,
                fifo: after__std_queue_BoundedQueue,
                txLifetimeSeconds: uint,
            },
            numContracts: uint,
            codeRefTable: map<bytes32,struct {
                refCount: uint,
                code: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                evmJumpTable: map<uint,view write func()>,
                startCodePoint: view write func(),
            }>,
            escrowStore: struct {
                nextKey: uint,
                escrowedValues: struct {
                    tree: [8]any,
                    size: uint,
                },
            },
        },
        runningAsAccount: struct {
            addr: address,
            blsKey: option<struct {
                ax: uint,
                ay: uint,
                bx: uint,
                by: uint,
            }> ,
            nextSeqNum: uint,
            ethBalance: uint,
            contractInfo: option<struct {
                code: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                evmJumpTable: map<uint,view write func()>,
                startCodePoint: view write func(),
                storage: struct {
                    tree: [8]any,
                    size: uint,
                },
            }> ,
            aggregatorInfo: option<struct {
                decompressionState: option<struct {
                    functionTable: []struct {
                        callDataPrefix: any,
                        maxGas: uint,
                        payable: bool,
                    },
                }> ,
                feeCollector: address,
                baseTxFeeL1Gas: uint,
            }> ,
            aggregatorToPay: option<address> ,
        },
        caller: address,
        isConstructor: bool,
        static: bool,
        calldata: struct {
            size: uint,
            sliceOffset: uint,
            contents: buffer,
        },
        callvalue: uint,
        returnInfo: option<struct {
            data: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            status: bool,
        }> ,
        memory: struct {
            size: uint,
            sliceOffset: uint,
            contents: buffer,
        },
        maxMemoryOffsetTouched: uint,
        storageDelta: int,
        revertOnStorageWrite: bool,
        evmLogs: struct {
            last: any,
            rest: struct {
                last: any,
                rest: after__evmlogs_EvmLogs,
            },
        },
        selfDestructQueue: after__std_queue_BoundedQueue,
        resumeInfo: option<struct {
            codePoint: func(),
            stackContents: option<struct {
                top: [8]any,
                num: uint,
                rest: option<after__std_stack_StackCell> ,
            }> ,
            auxStackContents: option<option<struct {
                top: [8]any,
                num: uint,
                rest: option<after__std_stack_StackCell> ,
            }> > ,
            returnDataOffset: uint,
            returnDataNbytes: uint,
            callType: uint,
            savedGas: uint,
            givenGas: uint,
        }> ,
        sendQueue: after__std_queue_BoundedQueue,
        sendOnFailure: option<struct {
            size: uint,
            sliceOffset: uint,
            contents: buffer,
        }> ,
        parent: option<after__evmCallStack_EvmCallFrame> ,
    }> ,
    globalCurrentTxRequest: struct {
        maxGas: uint,
        gasPrice: uint,
        seqNum: option<uint> ,
        caller: address,
        calleeAddr: address,
        gasPayer: address,
        value: uint,
        calldata: struct {
            size: uint,
            sliceOffset: uint,
            contents: buffer,
        },
        nonMutating: bool,
        isConstructor: bool,
        incomingRequest: struct {
            kind: uint,
            arbBlockNumber: uint,
            ethBlockNumber: uint,
            timestamp: uint,
            sender: address,
            requestId: uint,
            msgData: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            provenance: struct {
                l1SeqNum: uint,
                parentRequestId: uint,
                indexInParent: uint,
            },
            aggregator: option<struct {
                aggregator: option<address> ,
                calldataUnits: uint,
            }> ,
            adminMode: bool,
            gasEstimationParams: option<struct {
                computeGasLimit: uint,
                ignoreGasPrice: bool,
                ignoreMaxGas: bool,
            }> ,
        },
        feeStats: struct {
            price: struct {
                tx: uint,
                calldataUnit: uint,
                storage: uint,
                compute: uint,
            },
            units: struct {
                tx: uint,
                calldataUnit: uint,
                storage: uint,
                compute: uint,
            },
            weiPaid: struct {
                tx: uint,
                calldataUnit: uint,
                storage: uint,
                compute: uint,
            },
            paidAggregator: address,
            noFeeGasEstimationMode: bool,
        },
        fromRetryable: option<struct {
            txId: uint,
            sender: address,
            destination: address,
            callvalue: uint,
            callvalueEscrowKey: uint,
            beneficiary: address,
            calldata: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            expiryTime: uint,
            l1Message: struct {
                kind: uint,
                arbBlockNumber: uint,
                ethBlockNumber: uint,
                timestamp: uint,
                sender: address,
                requestId: uint,
                msgData: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                provenance: struct {
                    l1SeqNum: uint,
                    parentRequestId: uint,
                    indexInParent: uint,
                },
                aggregator: option<struct {
                    aggregator: option<address> ,
                    calldataUnits: uint,
                }> ,
                adminMode: bool,
                gasEstimationParams: option<struct {
                    computeGasLimit: uint,
                    ignoreGasPrice: bool,
                    ignoreMaxGas: bool,
                }> ,
            },
            originalSender: address,
        }> ,
        originalCaller: address,
    },
    globalCurrentRetryableRequest: option<struct {
        req: struct {
            kind: uint,
            arbBlockNumber: uint,
            ethBlockNumber: uint,
            timestamp: uint,
            sender: address,
            requestId: uint,
            msgData: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            provenance: struct {
                l1SeqNum: uint,
                parentRequestId: uint,
                indexInParent: uint,
            },
            aggregator: option<struct {
                aggregator: option<address> ,
                calldataUnits: uint,
            }> ,
            adminMode: bool,
            gasEstimationParams: option<struct {
                computeGasLimit: uint,
                ignoreGasPrice: bool,
                ignoreMaxGas: bool,
            }> ,
        },
        evmLogs: struct {
            last: any,
            rest: struct {
                last: any,
                rest: after__evmlogs_EvmLogs,
            },
        },
        originalSender: address,
    }> ,
    inErrorHandler: bool,
    globalIndexedAddressTable: struct {
        byIndex: struct {
            size: uint,
            chunk: uint,
            contents: [8]any,
        },
        byAddress: map<address,uint>,
        size: uint,
    },
    globalChainParameters: map<uint,uint>,
    chainOwners: struct {
        contents: struct {
            tree: [8]any,
            size: uint,
        },
        inverted: bool,
    },
    blockhashes: struct {
        latestBlockNum: uint,
        oldHashes: [256]bytes32,
    },
    arbStats: struct {
        storage: uint,
        arbGasUsed: uint,
        numTxReceipts: uint,
    },
    upgradeInProgress: option<struct {
        requireSafe: bool,
        code: view write func(),
        size: uint,
        codeMap: map<uint,view write func()>,
    }> ,
    previousArbosUpgradeHash: bytes32,
    globalAccountStore: struct {
        accounts: map<address,struct {
            addr: address,
            blsKey: option<struct {
                ax: uint,
                ay: uint,
                bx: uint,
                by: uint,
            }> ,
            nextSeqNum: uint,
            ethBalance: uint,
            contractInfo: option<struct {
                code: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                evmJumpTable: map<uint,view write func()>,
                startCodePoint: view write func(),
                storage: struct {
                    tree: [8]any,
                    size: uint,
                },
            }> ,
            aggregatorInfo: option<struct {
                decompressionState: option<struct {
                    functionTable: []struct {
                        callDataPrefix: any,
                        maxGas: uint,
                        payable: bool,
                    },
                }> ,
                feeCollector: address,
                baseTxFeeL1Gas: uint,
            }> ,
            aggregatorToPay: option<address> ,
        }>,
        retryBuffer: struct {
            byTxId: map<uint,struct {
                txId: uint,
                sender: address,
                destination: address,
                callvalue: uint,
                callvalueEscrowKey: uint,
                beneficiary: address,
                calldata: struct {
                    size: uint,
                    sliceOffset: uint,
                    contents: buffer,
                },
                expiryTime: uint,
                l1Message: struct {
                    kind: uint,
                    arbBlockNumber: uint,
                    ethBlockNumber: uint,
                    timestamp: uint,
                    sender: address,
                    requestId: uint,
                    msgData: struct {
                        size: uint,
                        sliceOffset: uint,
                        contents: buffer,
                    },
                    provenance: struct {
                        l1SeqNum: uint,
                        parentRequestId: uint,
                        indexInParent: uint,
                    },
                    aggregator: option<struct {
                        aggregator: option<address> ,
                        calldataUnits: uint,
                    }> ,
                    adminMode: bool,
                    gasEstimationParams: option<struct {
                        computeGasLimit: uint,
                        ignoreGasPrice: bool,
                        ignoreMaxGas: bool,
                    }> ,
                },
                originalSender: address,
            }>,
            fifo: after__std_queue_BoundedQueue,
            txLifetimeSeconds: uint,
        },
        numContracts: uint,
        codeRefTable: map<bytes32,struct {
            refCount: uint,
            code: struct {
                size: uint,
                sliceOffset: uint,
                contents: buffer,
            },
            evmJumpTable: map<uint,view write func()>,
            startCodePoint: view write func(),
        }>,
        escrowStore: struct {
            nextKey: uint,
            escrowedValues: struct {
                tree: [8]any,
                size: uint,
            },
        },
    },
    codeSegGlobals: struct {
        unreachableMask: uint,
        dummyAcceptContractCode: view write func(),
    },
    _jump_table: any,
};

public view func remapGlobalsForUpgrade(input_globals: GlobalsBeforeUpgrade) -> (GlobalsAfterUpgrade, uint) {
    let __fixedLocationGlobal = input_globals.__fixedLocationGlobal;
    let arbStats = input_globals.arbStats;
    let blockhashes = input_globals.blockhashes;
    let codeSegGlobals = input_globals.codeSegGlobals;
    let evmOpJumpTable = input_globals.evmOpJumpTable;
    let gasAccountingInfo = input_globals.gasAccountingInfo;
    let globalChainParameters = set_globalChainParameters_onUpgrade(input_globals);
    let globalInbox = input_globals.globalInbox;
    let globalIndexedAddressTable = input_globals.globalIndexedAddressTable;
    let globalL1GasPriceEstimator = input_globals.globalL1GasPriceEstimator;
    let globalOutbox = input_globals.globalOutbox;
    let inErrorHandler = input_globals.inErrorHandler;
    let logsQueuedForEndOfBlock = input_globals.logsQueuedForEndOfBlock;
    let previousArbosUpgradeHash = input_globals.previousArbosUpgradeHash;
    let upgradeInProgress = input_globals.upgradeInProgress;
    let addressRemapExceptions = set_addressRemapExceptions_onUpgrade(input_globals);
    let chainOwners = set_chainOwners_onUpgrade(input_globals);
    let globalAccountStore = set_globalAccountStore_onUpgrade(input_globals);
    let globalBlockReceiptData = set_globalBlockReceiptData_onUpgrade(input_globals);
    let globalCallStack = set_globalCallStack_onUpgrade(input_globals);
    let globalCurrentRetryableRequest = set_globalCurrentRetryableRequest_onUpgrade(input_globals);
    let globalCurrentTxRequest = set_globalCurrentTxRequest_onUpgrade(input_globals);
    let globalInputQueue = set_globalInputQueue_onUpgrade(input_globals);
    let _jump_table = (asm() GlobalsAfterUpgrade { rget })._jump_table;
    return (struct {
        __fixedLocationGlobal: __fixedLocationGlobal,
        globalBlockReceiptData: globalBlockReceiptData,
        logsQueuedForEndOfBlock: logsQueuedForEndOfBlock,
        globalOutbox: globalOutbox,
        globalInbox: globalInbox,
        globalInputQueue: globalInputQueue,
        addressRemapExceptions: addressRemapExceptions,
        gasAccountingInfo: gasAccountingInfo,
        globalL1GasPriceEstimator: globalL1GasPriceEstimator,
        evmOpJumpTable: evmOpJumpTable,
        globalCallStack: globalCallStack,
        globalCurrentTxRequest: globalCurrentTxRequest,
        globalCurrentRetryableRequest: globalCurrentRetryableRequest,
        inErrorHandler: inErrorHandler,
        globalIndexedAddressTable: globalIndexedAddressTable,
        globalChainParameters: globalChainParameters,
        chainOwners: chainOwners,
        blockhashes: blockhashes,
        arbStats: arbStats,
        upgradeInProgress: upgradeInProgress,
        previousArbosUpgradeHash: previousArbosUpgradeHash,
        globalAccountStore: globalAccountStore,
        codeSegGlobals: codeSegGlobals,
        _jump_table: _jump_table,
    }, 35);
}


func __dummy__() { return; }


