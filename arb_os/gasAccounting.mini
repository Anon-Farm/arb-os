//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use accounts::AccountStore;
use accounts::Account;
use std::bytearray::ByteArray;
use std::bytearray::MarshalledBytes;
use messageBatch::MessageBatch;
use std::queue::Queue;

use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::account_getBalance;
use accounts::account_addToEthBalance;
use accounts::account_deductFromEthBalance;
use accounts::account_getAggregatorState;

use evmCallStack::evmCallStack_isEmpty;

use std::bytearray::bytearray_new;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_get256;

use std::queue::queue_new;
use std::queue::queue_isEmpty;
use std::queue::queue_put;
use std::queue::queue_get;

use chainParameters::chainParams_millisecondsPerBlock;
use chainParameters::chainParams_speedLimitPerSecond;

use inbox::IncomingRequest;
use inbox::inbox_getNextUnpackedRequest;


var gasAccountingInfo: struct {
    gasPool: int,                 // amount of gas available for use (note: signed value; if negative, we have overused gas)
    weiPool: uint,                // pool of funds collected recently
    weiOwedToValidators: uint,    // wei owed for work done but not yet collected
    weiAvailable: uint,           // wei immediately available to pay validators
    totalPaidToValidators: uint,  // total number of wei paid to validators over all time
    lastBlockNumSeen: uint,       // last L1 block number seen by this module
    txState: option<TxGasState>,  // status of currently active tx (if there is one)
    payFeesTo: option<address>,   // where to pay validator fees; if None, funds should be burned
};

var gasAccountingConstants: struct {
    SpeedLimitPerBlock: uint,
    GasPoolMax: int,
    BaseGasPrice: uint,
    TxGasLimit: uint,
    StorageCharge: uint,   // cost of adding one unit of storage, in wei
};

type TxGasState = struct {
    gasInReserve: uint,  // how much gas is being held in reserve
    originalMax: uint,   // the tx's original maxGas value
    price: uint,         // price of gas for this tx, in wei per unit of gas
    weiHeldForGas: uint, // amount of currency we're holding to cover the current tx's gas use
    refundTo: address,   // who gets a refund for unused gas at the end, if there is any
}

type GasUsage = struct {
    gasUsed: uint,
    gasPriceWei: uint,
}

public impure func gasAccounting_init() {
    let millisecondsPerBlock = 13500;     // default, until chain gets its initialization message
    let speedLimitPerSecond = 100000000;  // default, until chain gets its initialization message
    let maxBacklogSeconds = 60;
    if (maxBacklogSeconds < 4 * millisecondsPerBlock / 1000) {
        maxBacklogSeconds = 4 * millisecondsPerBlock / 1000;
    }
    gasAccountingConstants = struct {
        SpeedLimitPerBlock: speedLimitPerSecond * millisecondsPerBlock / 1000,
        GasPoolMax: int(speedLimitPerSecond * maxBacklogSeconds),
        BaseGasPrice: 0,
        TxGasLimit: speedLimitPerSecond * maxBacklogSeconds / 2,
        StorageCharge: 0,
    };
    gasAccountingInfo = struct {
        gasPool: gasAccountingConstants.GasPoolMax,
        weiPool: 0,
        weiOwedToValidators: 0,
        weiAvailable: 0,
        totalPaidToValidators: 0,
        lastBlockNumSeen: 0,
        txState: None<TxGasState>,
        payFeesTo: None<address>,
    };
}

public impure func gasAccounting_setFeeParams(baseGasPrice: uint, storageCharge: uint, feeRecipient: address) {
    gasAccountingConstants = gasAccountingConstants with {
        BaseGasPrice: baseGasPrice
    } with {
        StorageCharge: storageCharge
    };
    if (feeRecipient == address(0)) {
        gasAccountingInfo = gasAccountingInfo with {
            payFeesTo: None<address>
        };
    } else {
        gasAccountingInfo = gasAccountingInfo with {
            payFeesTo: Some(feeRecipient)
        };
    }
}

public impure func gasAccounting_postInitMessage() {
    let millisecondsPerBlock = chainParams_millisecondsPerBlock();
    let speedLimitPerSecond = chainParams_speedLimitPerSecond();
    let maxBacklogSeconds = 60;
    if (maxBacklogSeconds < 4 * millisecondsPerBlock / 1000) {
        maxBacklogSeconds = 4 * millisecondsPerBlock / 1000;
    }
    gasAccountingConstants = struct {
        SpeedLimitPerBlock: millisecondsPerBlock * speedLimitPerSecond / 1000,
        GasPoolMax: int(speedLimitPerSecond * maxBacklogSeconds),
        BaseGasPrice: 0,
        TxGasLimit: speedLimitPerSecond * maxBacklogSeconds / 2,
        StorageCharge: 0,
    };
    gasAccountingInfo = gasAccountingInfo with { gasPool: gasAccountingConstants.GasPoolMax };
}

public impure func gasAccounting_summaryToPublish() -> any {
    let payoutAddress = address(0);
    if let Some(paddr) = gasAccountingInfo.payFeesTo {
        payoutAddress = paddr;
    }

    let minGasPrice = gasAccountingConstants.BaseGasPrice;
    let shortfall = int(gasAccountingInfo.weiOwedToValidators) - int(gasAccountingInfo.weiAvailable);
    if (shortfall > int(0)) {
        minGasPrice = minGasPrice + uint(shortfall) / uint(gasAccountingConstants.GasPoolMax);
    }
    let gasPriceEstimate = gasAccountingInfo.weiPool;
    if (gasAccountingInfo.gasPool + int(gasAccountingConstants.SpeedLimitPerBlock) > int(0)) {
        gasPriceEstimate = gasAccountingInfo.weiPool / uint(gasAccountingInfo.gasPool + int(gasAccountingConstants.SpeedLimitPerBlock));
    }
    if (gasPriceEstimate < minGasPrice) {
        gasPriceEstimate = minGasPrice;
    }
    return (
        gasPriceEstimate,
        gasAccountingInfo.gasPool,
        gasAccountingInfo.weiPool,
        shortfall,
        gasAccountingInfo.totalPaidToValidators,
        payoutAddress,
    );
}

public impure func gasAccounting_specialCharge(payer: address, amount: uint) -> option<()> {
    if ( ! evmCallStack_isEmpty() ) {
        // This must be called outside of a tx.
        return None;
    }

    let globalAcctStore = getGlobalAccountStore();
    let payerAcct = accountStore_get(globalAcctStore, payer);
    setGlobalAccountStore(
        accountStore_set(
            globalAcctStore,
            payer,
            account_deductFromEthBalance(payerAcct, amount)?,
        )
    );
    payOutFundsToValidators(amount);
    return Some(());
}

public impure func recycleBurnedFunds(amount: uint) {
    gasAccountingInfo = gasAccountingInfo with {
        weiAvailable: gasAccountingInfo.weiAvailable + amount
    };
}

// The currently-running Tx has some amount of gas remaining. That gas can be in two places:
// *  in the ArbGasRemaining register, if that register is < 2**255
// *  in reserve
//
// The state of the ArbGasRemaining register tells us whether we're currently charging gas to the tx or to the OS.
// *  If the register is < 2**255, we're charging to the tx
// *  If the register is >= 2**255, we're charging to the OS
// Note that if execution in the tx (or a subcall it makes) runs out of gas, this will generate an Error and
//    set ArbGasRemaining to 2**256 - 1, which correctly puts us into the mode of charging the OS.
// If there is an Error, the Error handler will call us, to inform us that there might have been an out-of-gas situation.
//    (It's up to us to figure out whether there actually was an out-of-gas situation, vs some unrelated error.)
//
// When a new tx starts, we take enough Eth from it to cover its maxGas.
// When that tx is done, we give it a refund for any unused gas.

public impure func gasAccounting_startTxCharges(
    maxGas: uint,
    gasPrice: uint,
    payer: address,
    originalSender: address,  //TODO: use this
    calldataBytes: uint,
) -> option<()> {
    // Start charging a new Tx for ArbGas usage
    // The caller should already have verified that the payer has enough funds, but we'll return None if not.

    let _ = switchToChargingOS();   // call this in case we're somehow still charging a tx; ignore return value

    if (maxGas > gasAccountingConstants.TxGasLimit) {
        maxGas = gasAccountingConstants.TxGasLimit;
    }

    // take funds from the payer, enough to pay for maxGas at gasPrice
    let weiToHold = maxGas * gasPrice;
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            payer,
            account_deductFromEthBalance(
                accountStore_get(globalAS, payer),
                weiToHold
            )?   // note: returns None if insufficient balance
        )
    );

    let gasUsedByOS = (~0) - asm() uint { getgas };
    gasAccountingInfo = gasAccountingInfo with {
        gasPool: gasAccountingInfo.gasPool - int(gasUsedByOS)
    } with {
        weiOwedToValidators: gasAccountingInfo.weiOwedToValidators + gasUsedByOS * gasAccountingConstants.BaseGasPrice
    } with {
        txState: Some(struct {
            gasInReserve: 0,
            originalMax: maxGas,
            price: gasPrice,
            weiHeldForGas: weiToHold,
            refundTo: payer,
        })
    };

    // Now charge some ArbGas to pay the aggregator, if needed.
    // This ArbGas is added back to the global pool, because it doesn't represent validator computation.
    // The funds are paid out to the aggregator, and deducted from the client's ArbGas deposit.
    if ((gasPrice > 0) && (originalSender != address(0)) && (calldataBytes > 0)) {
        let globalAS = getGlobalAccountStore();
        if let Some(aggInfo) = account_getAggregatorState(accountStore_get(globalAS, originalSender)) {
            if (aggInfo.feePerByte > 0) {
                if let Some(clntMaxFee) = aggInfo.clientMaxFees[payer] {
                    if (clntMaxFee < aggInfo.feePerByte) {
                        return None;   // revert transaction; client does not accept the aggregator's calldata fee
                    }
                    let gasToTake = aggInfo.feePerByte * calldataBytes / gasPrice;
                    if (gasToTake >= maxGas) {
                        return None;  // transaction doesn't have enough gas to pay aggregator fee
                    }
                    maxGas = maxGas - gasToTake;
                    let weiToTake = gasToTake * gasPrice;
                    if let Some(txState) = gasAccountingInfo.txState {
                        gasAccountingInfo = gasAccountingInfo with {
                            txState: Some(txState with { weiHeldForGas: txState.weiHeldForGas - weiToTake })
                        } with {
                            gasPool: gasAccountingInfo.gasPool + int(gasToTake)
                        };
                        setGlobalAccountStore(
                            accountStore_set(
                                globalAS,
                                payer,
                                account_addToEthBalance(accountStore_get(globalAS, payer), weiToTake),
                            )
                        );
                    } else {
                        return None;  // should never happen
                    }
                } else {
                    return None;   // revert transaction; client is not registered with the aggregator
                }
            }
        }
    }

    asm(maxGas,) { setgas };

    return Some(());
}

public impure func gasAccounting_endTxCharges(storageDelta: int) -> option<GasUsage> {
    // stop charging the current tx for gas
    // refund any unused gas
    // return the total amount it used, or None if there isn't a tx active

    // charge the tx for storage it allocated (minus storage freed); for now, no refund if tx reduced total storage
    if (storageDelta > int(0)) {
        gasAccounting_chargeForStorage(uint(storageDelta));
    }

    // switch over to charging the OS for gas
    let txState = gasAccountingInfo.txState?;
    let gasToRefund = txState.gasInReserve + switchToChargingOS();

    // refund the unused gas
    let refund = gasToRefund * txState.price;
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            txState.refundTo,
            account_addToEthBalance(
                accountStore_get(globalAS, txState.refundTo),
                refund
            )
        )
    );
    gasAccountingInfo = gasAccountingInfo with {
        gasPool: gasAccountingInfo.gasPool - int(txState.originalMax - gasToRefund)
    } with {
        weiPool: gasAccountingInfo.weiPool + (txState.weiHeldForGas - refund)
    } with {
        weiOwedToValidators: gasAccountingInfo.weiOwedToValidators
                             + gasAccountingConstants.BaseGasPrice * (txState.originalMax - gasToRefund)
    } with {
        txState: None<TxGasState>
    };

    return Some(
        struct {
            gasUsed: txState.originalMax-gasToRefund,
            gasPriceWei: txState.price
        }
    );
}

public impure func gasAccounting_extraGasCharge(numArbGas: uint, isValidatorComputation: bool) {
    // Assess an extra gas charge on the current tx, paid to the validators.
    // This lets us charge for things that use up system resources
    // Callers should assess the charge for a thing before they do the thing, because we can
    //      only take the gas that the user has remaining
    // It's okay to assess the charge after doing the thing, if the cost of the thing will be eliminated on revert

    let gasLeft = asm() uint { getgas };
    if (gasLeft >= asm (1, 255) uint { shl }) {
        return;   // we're not currently charging a tx, so don't assess a charge
    }

    if (numArbGas >= gasLeft) {
        // user can't cover the charge, so we'll take all but 1 of their gas,
        //      ensuring that they'll get an out-of-gas error
        numArbGas = gasLeft-1;
    }

    if (!isValidatorComputation) {
        // add the gas back into the gas pool, because it doesn't represent validator computation
        gasAccountingInfo = gasAccountingInfo with { gasPool: gasAccountingInfo.gasPool + int(numArbGas) };
    }

    asm(gasLeft-numArbGas,) { setgas };
}

public impure func gasAccounting_chargeForStorage(numStorageUnits: uint) {
    if let Some(txState) = gasAccountingInfo.txState {
        if (txState.price > 0) {
            gasAccounting_extraGasCharge(numStorageUnits * gasAccountingConstants.StorageCharge / txState.price, false);
        }
    }
}

public impure func gasAccounting_pauseTxCharges() -> uint {
    // pause charging the currently running tx
    // return how many units of the tx's initial maxGas are still unused

    if let Some(txState) = gasAccountingInfo.txState {
        let gasRemaining = txState.gasInReserve + switchToChargingOS();
        gasAccountingInfo = gasAccountingInfo with {
            txState: Some(
                txState with {
                    gasInReserve: gasRemaining
                }
            )
        };
        return gasRemaining;
    } else {
        // oops, someone tried to pause tx charges when there's no active tx
        // to be safe, report that the tx is completely out of gas
        return 0;
    }
}

public impure func gasAccounting_resumeTxCharges(allocationRequested: uint) -> uint {
    // resume the charging of the tx for gas
    // allocationRequested is how much of its gas the tx wants to allocate
    // return how much gas we actually allocated = min(requested, available)

    if let Some(txState) = gasAccountingInfo.txState {
        let gasRegister = asm() uint { getgas };
        if (gasRegister >= asm(1, 255) uint { shl }) {
            let gasUsedByOS = (~0) - gasRegister;
            gasAccountingInfo = gasAccountingInfo with {
                gasPool: gasAccountingInfo.gasPool - int(gasUsedByOS)
            } with {
                weiOwedToValidators: gasAccountingInfo.weiOwedToValidators
                                     + gasUsedByOS * gasAccountingConstants.BaseGasPrice
            };
        }

        if (allocationRequested > txState.gasInReserve) {
            allocationRequested = txState.gasInReserve;  // can't request more gas than you have
        }

        gasAccountingInfo = gasAccountingInfo with {
            txState: Some(
                txState with {
                    gasInReserve: txState.gasInReserve - allocationRequested
                }
            )
        };

        asm(allocationRequested,) { setgas };  // start charging the application
        return allocationRequested;
    } else {
        // something went wrong: tried to resume tx charges when there isn't an active tx
        // to be safe, report that tx is completely out of gas
        return 0;
    }
}

impure func switchToChargingOS() -> uint {
    // switch to charging the OS for gas, if we aren't already
    // return amount of the tx's gas that was left over in ArbGasRemaining
    let gasRemaining = asm() uint { getgas };
    if (gasRemaining >= asm(255, 1) uint { shl }) {
        // we were already charging the OS, tx has nothing remaining
        return 0;
    } else {
        // we were charging the tx; switch to charging the OS and return tx's unused amount from ArbGasRemaining
        asm(~0,) { setgas };
        return gasRemaining;
    }
}

impure func payOutFundsToValidators(amount: uint) {  // this should only be called when not in a tx
    if let Some(validatorsAddr) = gasAccountingInfo.payFeesTo {
        let globalAcctStore = getGlobalAccountStore();
        setGlobalAccountStore(
            accountStore_set(
                globalAcctStore,
                validatorsAddr,
                account_addToEthBalance(
                    accountStore_get(globalAcctStore, validatorsAddr),
                    amount,
                ),
            )
        );
        gasAccountingInfo = gasAccountingInfo with {
            totalPaidToValidators: gasAccountingInfo.totalPaidToValidators + amount
        };
    }
}

// TxRequestData is declared identically in message.mini and elsewhere.
type TxRequestData = struct {
    maxGas: uint,
    gasPrice: uint,
    seqNum: option<uint>,
    caller: address,
    calleeAddr: address,
    value: uint,
    calldata: ByteArray,
    nonMutating: bool,
    incomingRequest: IncomingRequest,
    calldataBytes: uint,
}


// The next section of code implements the congestion auction. For each request, the auction
//     determines (a) whether to approve the request for execution, and (b) what gas price the request will pay.
// This uses a "pull" interface: the main run loop calls this to get the next request.
//     This code will in turn call back to the inbox to pull in incoming requests from the L1.
// Eventually this component will pull in a group of requests from the inbox, run the congestion
//     auction over them, then enqueue them to be eventually fetched by the main run loop.
// For now, this approves every request, and charges zero gas price.
public impure func getNextRequestFromCongestionAuction() -> (
    bool,                     // was it approved for execution
    option<IncomingRequest>,  // if it was an L1 message
    option<TxRequestData>,    // if it was an L2 tx message
) {
    let (maybeRequest, maybeTx) = inbox_getNextUnpackedRequest();
    let (isChargeable, blockNum, payer, maxGas, gasBid) = getRequestGasInfo(maybeRequest, maybeTx);

    if (blockNum > gasAccountingInfo.lastBlockNumSeen) {
        let blocksElapsed = blockNum - gasAccountingInfo.lastBlockNumSeen;
        let updatedGas = gasAccountingInfo.gasPool + int(blocksElapsed*gasAccountingConstants.SpeedLimitPerBlock);
        if (updatedGas > gasAccountingConstants.GasPoolMax) {
            updatedGas = gasAccountingConstants.GasPoolMax;
        }
        let updatedWei = gasAccountingInfo.weiPool;
        while (blocksElapsed > 0) {
            let updatedWei = (4 * updatedWei) / 5;
            blocksElapsed = blocksElapsed-1;
        }
        let weiAvailable = gasAccountingInfo.weiAvailable + (gasAccountingInfo.weiPool - updatedWei);
        let weiToPay = weiAvailable;
        if (weiToPay > gasAccountingInfo.weiOwedToValidators) {
            weiToPay = gasAccountingInfo.weiOwedToValidators;
        }

        payOutFundsToValidators(weiToPay);

        gasAccountingInfo = gasAccountingInfo with {
            lastBlockNumSeen: blockNum
        } with {
            gasPool: updatedGas
        } with {
            weiPool: updatedWei
        } with {
            weiAvailable: gasAccountingInfo.weiAvailable - weiToPay
        } with {
            weiOwedToValidators: gasAccountingInfo.weiOwedToValidators - weiToPay
        };
    }

    if (isChargeable) {
        let minGasPrice = gasAccountingConstants.BaseGasPrice;
        let shortfall = int(gasAccountingInfo.weiOwedToValidators) - int(gasAccountingInfo.weiAvailable);
        if (shortfall > int(0)) {
            minGasPrice = minGasPrice + uint(shortfall) / uint(gasAccountingConstants.GasPoolMax);
        }

        if (maxGas > gasAccountingConstants.TxGasLimit) {
            maxGas = gasAccountingConstants.TxGasLimit;
        }

        if ( (minGasPrice > 0) && (int(maxGas) >= gasAccountingInfo.gasPool) ) {
            return (false, maybeRequest, maybeTx);
        }

        if (gasAccountingInfo.gasPool <= int(maxGas)) {
            return (false, maybeRequest, maybeTx);
        }

        let gasPrice = gasAccountingInfo.weiPool / (uint(gasAccountingInfo.gasPool)-maxGas);
        if (gasPrice < minGasPrice) {
            gasPrice = minGasPrice;
        }

        if (gasBid == 0) {
            gasBid = minGasPrice;  // treat a zero bid as equivalent to bidding the min gas price
        }

        let availableFunds = account_getBalance(accountStore_get(getGlobalAccountStore(), payer));
        if (availableFunds < gasPrice*maxGas) {
            return (false, maybeRequest, maybeTx);
        }
        if let Some(tx) = maybeTx {
            return (
                true,
                maybeRequest,
                Some(tx with { gasPrice: gasPrice }),
            );
        } else {
            return (true, maybeRequest, maybeTx);  // shouldn't happen
        }
    } else {
        return (true, maybeRequest, maybeTx);
    }
}

public impure func getGasLimitConstant() -> uint {
    return gasAccountingConstants.TxGasLimit;
}

impure func getRequestGasInfo(maybeRequest: option<IncomingRequest>, maybeTx: option<TxRequestData>) -> (bool, uint, address, uint, uint) {
    if let Some(req) = maybeRequest {
        return (false, req.blockNumber, req.sender, 0, 0);
    }
    if let Some(tx) = maybeTx {
        return (true, tx.incomingRequest.blockNumber, tx.incomingRequest.sender, tx.maxGas, tx.gasPrice);
    }
    return (true, gasAccountingInfo.lastBlockNumSeen, address(~0), 0, 0);  // shouldn't happen
}
