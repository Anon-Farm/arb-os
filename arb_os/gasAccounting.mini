//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use accounts::AccountStore;
use accounts::Account;
use std::bytearray::ByteArray;
use std::bytearray::MarshalledBytes;
use messageBatch::MessageBatch;
use std::queue::Queue;

use core::kvs::Kvs;
use core::kvs::builtin_kvsForall;

use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::account_getBalance;
use accounts::account_addToEthBalance;
use accounts::account_deductFromEthBalance;
use accounts::accountStore_transferEthBalance;

use evmCallStack::evmCallStack_isEmpty;
use evmCallStack::evmCallStack_getAccountInCurrentContext;
use evmCallStack::evmCallStack_setAccountInCurrentContext;

use messages::TxRequestData;

use std::bytearray::bytearray_new;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_get256;

use std::fixedpoint::FixedPoint;
use std::fixedpoint::fixedPoint_new;
use std::fixedpoint::fixedPoint_getNum;
use std::fixedpoint::fixedPoint_getDenom;
use std::fixedpoint::fixedPoint_zero;
use std::fixedpoint::fixedPoint_compare;
use std::fixedpoint::fixedPoint_mulByUint;
use std::fixedpoint::fixedPoint_integerPart;

use std::queue::queue_new;
use std::queue::queue_isEmpty;
use std::queue::queue_put;
use std::queue::queue_get;
use std::queue::queue_getOrDie;

use chainParameters::chainParams_speedLimitPerBlock;

use inbox::IncomingRequest;
use inbox::inbox_getNextUnpackedRequest;


var gasAccountingInfo: struct {
    txState: option<TxGasState>,       // status of currently active tx (if there is one)
    feesEnabled: bool,                 // true iff fees are enabled; otherwise all prices will be zero
    currentPrices: GasPrices,          // current prices for resources
    gasRemainingThisBlock: uint,       // amount of gas remaining for this block
    congestionState: CongestionState,  // state of congestion pricing algorithm
    speedLimitPerBlock: uint,          // nominal ArbGas available for computation per L1 block
    recipients: FeeRecipients,         // who receives fees
    pricingParams: PricingParameters,  // parameters that affect pricing
};

type GasPrices = struct {    // all prices in this struct are denominated in wei
    perL2Tx: uint,
    perL1CalldataByte: uint,
    perStorageCell: uint,
    perArbGasBase: uint,
    perArbGasCongestion: uint,
    perArbGasTotal: uint,
}

type CongestionState = struct {
    gasPool: int,         // amount of gas available for use (note: signed value; if negative, we have overused gas)
    lastBlockNumSeen: uint,
    congestionPriceWei: uint,
}

type PricingParameters = struct {
    l1GasPerL2Tx: uint,
    l1GasPerL1Calldata: uint,
    l1GasPerStorage: uint,
    arbGasDivisor: uint,
}

type FeeRecipients = struct {
    forNetwork: address,
    forCongestion: address,
}

var gasAccountingParams: struct {
    SpeedLimitPerBlock: uint,
    GasPoolMax: int,
    TxGasLimit: uint,
};

type TxGasState = struct {
    gasInReserve: uint,  // how much gas is being held in reserve
    originalMax: uint,   // the tx's original maxGas value
    price: uint,         // price of gas for this tx, in wei per unit of gas
    weiHeldForGas: uint, // amount of currency we're holding to cover the current tx's gas use
    refundTo: address,   // who gets a refund for unused gas at the end, if there is any
}

type GasUsage = struct {
    gasUsed: uint,
    gasPriceWei: uint,
}

public impure func gasAccounting_init() {
    initGasPriceEstimator();
    gasAccountingParams = struct {
        SpeedLimitPerBlock: const::DefaultSpeedLimitPerBlock,
        GasPoolMax: int(const::DefaultSpeedLimitPerBlock * 5),
        TxGasLimit: const::DefaultSpeedLimitPerBlock * 5 / 2,
    };

    let pricingParams = struct {
        l1GasPerL2Tx: const::Charging_DefaultL1GasPerL2Tx,
        l1GasPerL1Calldata: const::Charging_DefaultL1GasPerCalldataByte,
        l1GasPerStorage: const::Charging_DefaultL1GasPerStorage,
        arbGasDivisor: const::Charging_DefaultArbGasDivisor,
    };

    let congestionState = struct {
        gasPool: int(gasAccountingParams.GasPoolMax),
        lastBlockNumSeen: 0,
        congestionPricePerArbGas: 0,
    };
    gasAccountingInfo = struct {
        txState: None<TxGasState>,
        feesEnabled: false,
        currentPrices: setPrices(false, pricingParams, congestionState),
        gasRemainingThisBlock: 0,
        congestionState: congestionState,
        speedLimitPerBlock: const::DefaultSpeedLimitPerBlock,
        recipients: struct {
            forNetwork: address(const::Charging_DefaultNetworkFeeRecipient),
            forCongestion: address(const::Charging_DefaultCongestionFeeRecipient),
        },
        pricingParams: pricingParams,
    };
}

impure func setPrices(feesEnabled: bool, params: PricingParameters, congestionState: CongestionState) -> GasPrices {
    return xif (feesEnabled) {
        let l1GasPrice = getL1GasPriceEstimate();
        let perArbGasBase = l1GasPrice / params.arbGasDivisor;
        let perArbGasCongestion = congestionState.congestionPriceWei;
        struct {
            perL2Tx: params.l1GasPerL2Tx * l1GasPrice,
            perL1CalldataByte: params.l1GasPerL2Tx * l1GasPrice,
            perStorageCell: params.l1GasPerStorage * l1GasPrice,
            perArbGasBase: perArbGasBase,
            perArbGasCongestion: perArbGasCongestion,
            perArbGasTotal: perArbGasBase + perArbGasCongestion,
        }
    } else {
        struct {
            perL2Tx: 0,
            perL1CalldataByte: 0,
            perStorageCell: 0,
            perArbGasBase: 0,
            perArbGasCongestion: 0,
            perArbGasTotal: 0,
        }
    };
}

public impure func gasAccounting_setFeesEnabled(enabled: bool) {
    gasAccountingInfo = gasAccountingInfo with { feesEnabled: enabled };
    if (! enabled) {
        gasAccountingInfo = gasAccountingInfo with {
            currentPrices: setPrices(false, gasAccountingInfo.pricingParams, gasAccountingInfo.congestionState)
        };
    }
}

public impure func gasAccounting_setChargingParams(
    l1GasPerL2Tx: uint,
    l1GasPerL2Calldata: uint,
    l1GasPerStorage: uint,
    arbGasDivisor: uint,
    netFeeRecipient: address,
    congestionFeeRecipient: address,
) {
    gasAccountingInfo = gasAccountingInfo with {
        pricingParams: struct {
            l1GasPerL2Tx: l1GasPerL2Tx,
            l1GasPerL2CalldataByte: l1GasPerL2Calldata,
            l1GasPerStorageCell: l1GasPerStorage,
            arbGasDivisor: arbGasDivisor,
        }
    } with {
        recipients: struct {
            forNetwork: netFeeRecipient,
            forCongestion: congestionFeeRecipient,
        }
    };
    gasAccounting_postInitMessage();
}

public impure func gasAccounting_postInitMessage() {
    let speedLimitPerBlock = chainParams_speedLimitPerBlock();
    gasAccountingParams = struct {
        SpeedLimitPerBlock: speedLimitPerBlock,
        GasPoolMax: int(5 * speedLimitPerBlock),
        TxGasLimit: 2 * speedLimitPerBlock,
    };
    gasAccountingInfo = gasAccountingInfo with {
        congestionState: gasAccountingInfo.congestionState with {
            gasPool: gasAccountingParams.GasPoolMax
        }
    };
}

public impure func gasAccounting_getFeeRecipients() -> (address, address) {
    return (
        gasAccountingInfo.recipients.forNetwork,
        gasAccountingInfo.recipients.forCongestion,
    );
}

public impure func gasAccounting_setFeeRecipients(forNetwork: address, forCongestion: address) {
    gasAccountingInfo = gasAccountingInfo with {
        recipients: struct {
            forNetwork: forNetwork,
            forCongestion: forCongestion,
        }
    };
}

public impure func gasAccounting_addToReserveInCurrentContext(wei: uint) {
    let reserveAddr = gasAccountingInfo.recipients.forCongestion;
    evmCallStack_setAccountInCurrentContext(
        reserveAddr,
        account_addToEthBalance(
            evmCallStack_getAccountInCurrentContext(reserveAddr),
            wei,
        ),
    );
}

public func gasAccounting_getFeeRates() -> option<(uint, uint, uint, uint)> {
    return Some((0, 0, 0, 0));   //TODO
}

public func gasAccounting_getFeeMaxes() -> option<(uint, uint, uint, uint)> {
    return Some((0, 0, 0, 0));   //TODO
}

public func gasAccounting_setFeeRates(r1: uint, r2: uint, r3: uint, r4: uint) -> option<()> {
    return Some(());  //TODO
}

public func gasAccounting_setFeeMaxes(r1: uint, r2: uint, r3: uint, r4: uint) -> option<()> {
    return Some(());  //TODO
}

public impure func gasAccounting_summaryToPublish() -> any {
    let prices = gasAccountingInfo.currentPrices;
    return (
        prices.perL2Tx,
        prices.perL1CalldataByte,
        prices.perStorageCell,
        prices.perArbGasBase,
        prices.perArbGasCongestion,
        prices.perArbGasTotal,
        gasAccountingInfo.congestionState.gasPool,
    );
}


// The next section of code supports tracking gas use of the currently running transactions.
// The currently-running Tx has some amount of gas remaining. That gas can be in two places:
// *  in the ArbGasRemaining register, if that register is < 2**255
// *  in reserve
//
// The state of the ArbGasRemaining register tells us whether we're currently charging gas to the tx or to ArbOS.
// *  If the register is < 2**255, we're charging to the tx
// *  If the register is >= 2**255, we're charging to ArbOS
// Note that if execution in the tx (or a subcall it makes) runs out of gas, this will generate an Error and
//    set ArbGasRemaining to 2**256 - 1, which correctly puts us into the mode of charging the OS.
// If there is an Error, the Error handler will call us, to inform us that there might have been an out-of-gas situation.
//    (It's up to us to figure out whether there actually was an out-of-gas situation, vs some unrelated error.)
//
// When a new tx starts, we take enough wei from it to cover its maxGas.
// When that tx is done, we give it a refund for any unused gas.

public impure func gasAccounting_startTxCharges(
    maxGas: uint,
    gasPrice: uint,
    payer: address
) -> option<()> {
    // Start charging a new Tx for ArbGas usage
    // The caller should already have verified that the payer has enough funds, but we'll return None if not.

    let _ = switchToChargingOS();   // call this in case we're somehow still charging a tx; ignore return value

    if (maxGas > gasAccountingParams.TxGasLimit) {
        return None<()>;   // tx wanted more gas than the gas limit
    }

    // take funds from the payer, enough to pay for maxGas at gasPrice
    let weiToHold = maxGas * gasPrice;
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            payer,
            account_deductFromEthBalance(
                accountStore_get(globalAS, payer),
                weiToHold
            )?   // note: returns None if insufficient balance
        )
    );

    let gasUsedByOS = (~0) - asm() uint { getgas };

    gasAccountingInfo = gasAccountingInfo with {
        txState: Some(struct {
            gasInReserve: 0,
            originalMax: maxGas,
            price: gasPrice,
            weiHeldForGas: weiToHold,
            refundTo: payer,
        })
    };

    asm(maxGas,) { setgas };
    return Some(());
}

public impure func gasAccounting_endTxCharges(storageDelta: int) -> option<GasUsage> {
    // stop charging the current tx for gas
    // refund any unused gas
    // return the total amount it used, or None if there isn't a tx active

    // charge the tx for storage it allocated (minus storage freed); for now, no refund if tx reduced total storage
    if (storageDelta > int(0)) {
        gasAccounting_chargeForStorage(uint(storageDelta));
    }

    // switch over to charging the OS for gas
    let txState = gasAccountingInfo.txState?;
    let gasToRefund = txState.gasInReserve + switchToChargingOS();
    let gasUsed = txState.originalMax - gasToRefund;    // won't underflow because gasToRefund <= originalMax

    // refund the unused gas, and pay fees
    let refund = gasToRefund * txState.price;
    let globalAS = getGlobalAccountStore();
    globalAS = accountStore_set(
       globalAS,
       txState.refundTo,
       account_addToEthBalance(
           accountStore_get(globalAS, txState.refundTo),
           refund
       )
    );
    globalAS = accountStore_set(
        globalAS,
        gasAccountingInfo.recipients.forNetwork,
        account_addToEthBalance(
            accountStore_get(globalAS, gasAccountingInfo.recipients.forNetwork),
            gasUsed * gasAccountingInfo.currentPrices.perArbGasBase,
        ),
    );
    globalAS = accountStore_set(
        globalAS,
        gasAccountingInfo.recipients.forCongestion,
        account_addToEthBalance(
            accountStore_get(globalAS, gasAccountingInfo.recipients.forCongestion),
            gasUsed * gasAccountingInfo.currentPrices.perArbGasCongestion,
        ),
    );

    setGlobalAccountStore(globalAS);

    gasAccountingInfo = gasAccountingInfo with {
        congestionState: gasAccountingInfo.congestionState with {
            gasPool: gasAccountingInfo.congestionState.gasPool - int(gasUsed)
        }
    } with {
        gasRemainingThisBlock: xif (gasAccountingInfo.gasRemainingThisBlock >= gasUsed) {
            gasAccountingInfo.gasRemainingThisBlock - gasUsed
        } else {
            0
        }
    } with {
        txState: None<TxGasState>
    };

    return Some(
        struct {
            gasUsed: gasUsed,
            gasPriceWei: txState.price,
        }
    );
}

public impure func gasAccounting_extraGasCharge(numArbGas: uint) {
    // assess an extra gas charge on the current tx, but don't count it against the speed limit
    // this lets us charge for things that use up system resources
    // callers should assess the charge for a thing before they do the thing, because we can
    //      only take the gas that the user has remaining
    // it's okay to assess the charge after doing the thing, if the cost of the thing will be eliminated on revert

    let gasLeft = asm() uint { getgas };
    if (gasLeft >= asm (1, 255) uint { shl }) {
        return;   // we're not currently charging a tx, so don't assess a charge
    }

    if (numArbGas >= gasLeft) {
        // user can't cover the charge, so we'll take all but 1 of their gas,
        //      ensuring that they'll get an out-of-gas error
        numArbGas = gasLeft-1;
    }

    // we're not counting this gas against the chain's speed limit,
    //       so add it back to the places it's going to be subtracted from
    gasAccountingInfo = gasAccountingInfo with {
        gasRemainingThisBlock: gasAccountingInfo.gasRemainingThisBlock + numArbGas
    } with {
        congestionState: gasAccountingInfo.congestionState with {
            gasPool: gasAccountingInfo.congestionState.gasPool + int(numArbGas)
        }
    };


    asm(gasLeft-numArbGas,) { setgas };
}

public impure func gasAccounting_chargeForStorage(numStorageUnits: uint) {
    if let Some(txState) = gasAccountingInfo.txState {
        gasAccounting_extraGasCharge(numStorageUnits * gasAccountingInfo.currentPrices.perStorageCell);
    }
}

public impure func gasAccounting_getGasChargeAmount(numStorageUnits: uint) -> uint {
    return numStorageUnits * gasAccountingInfo.currentPrices.perStorageCell;
}

public impure func gasAccounting_pauseTxCharges() -> uint {
    // pause charging the currently running tx
    // return how many units of the tx's initial maxGas are still unused

    return xif let Some(txState) = gasAccountingInfo.txState {
        let gasRemaining = txState.gasInReserve + switchToChargingOS();
        gasAccountingInfo = gasAccountingInfo with {
            txState: Some(
                txState with {
                    gasInReserve: gasRemaining
                }
            )
        };
        gasRemaining
    } else {
        // oops, someone tried to pause tx charges when there's no active tx
        // to be safe, report that the tx is completely out of gas
        0
    };
}

public impure func gasAccounting_resumeTxCharges(allocationRequested: uint) -> uint {
    // resume the charging of the tx for gas
    // allocationRequested is how much of its gas the tx wants to allocate for whatever is going to execute
    // return how much gas we actually allocated = min(requested, available)

    return xif let Some(txState) = gasAccountingInfo.txState {
        // stop charging the OS, and record the OS gas usage as overhead
        let gasRegister = asm() uint { getgas };

        if (allocationRequested > txState.gasInReserve) {
            allocationRequested = txState.gasInReserve;  // can't request more gas than you have
        }

        gasAccountingInfo = gasAccountingInfo with {
            txState: Some(
                txState with {
                    gasInReserve: txState.gasInReserve - allocationRequested
                }
            )
        };

        asm(allocationRequested,) { setgas };  // start charging the application
        allocationRequested
    } else {
        // something went wrong: tried to resume tx charges when there isn't an active tx
        // to be safe, report that tx is completely out of gas
        0
    };
}

impure func switchToChargingOS() -> uint {
    // switch to charging the OS for gas, if we aren't already
    // return amount of the tx's gas that is still unused
    let gasRemaining = asm() uint { getgas };
    return xif (gasRemaining >= asm(255, 1) uint { shl }) {
        // we were already charging the OS, tx has nothing remaining
        0
    } else {
        // we were charging the tx; switch to charging the OS and return tx's unused amount from ArbGasRemaining
        asm(~0,) { setgas };
        gasRemaining
    };
}

// getNextRequestFromCongestionAuction implements the congestion auction. For each request, the auction
//     determines (a) whether to approve the request for execution, and (b) what gas price the request will pay.
// This uses a "pull" interface: the main run loop calls this to get the next request.
//     This code will in turn call back to the inbox to pull in incoming requests from the L1.
public impure func getNextRequestFromCongestionAuction() -> (
    uint,                     // error code, or const::TxResultCode_success if no error
    option<IncomingRequest>,  // if it was an L1 message
    option<TxRequestData>,    // if it was an L2 tx message
) {
    let (maybeRequest, maybeTx) = inbox_getNextUnpackedRequest();
    let (isChargeable, blockNum, payer, maxGas, gasBid) = getRequestGasInfo(maybeRequest, maybeTx);

    if (blockNum > gasAccountingInfo.congestionState.lastBlockNumSeen) {
        // it's the first tx of a new block, so do beginning-of-block work
        let updatedCongestionState = updateCongestionState(gasAccountingInfo.congestionState, blockNum);

        gasAccountingInfo = gasAccountingInfo with {
            congestionState: updatedCongestionState
        } with {
            currentPrices: setPrices(gasAccountingInfo.feesEnabled, gasAccountingInfo.pricingParams, updatedCongestionState)
        } with {
            gasRemainingThisBlock: xif(gasAccountingInfo.congestionState.gasPool > int(0)) {
                    uint(gasAccountingInfo.congestionState.gasPool) * 3 / 4
                } else {
                    0
                }
        };
    }

    return xif (isChargeable && gasAccountingInfo.feesEnabled) {
        xif let Some(tx) = maybeTx {
            let prices = gasAccountingInfo.currentPrices;
            if let Some(aggInfo) = tx.incomingRequest.aggregator {
                let feeForTxAndCalldata = prices.perL2Tx + prices.perL1CalldataByte * aggInfo.calldataBytes;

                // reimburse aggregator for tx and calldata
                if let Some(globalAS) = accountStore_transferEthBalance(
                    getGlobalAccountStore(),
                    tx.caller,
                    aggInfo.aggregator,
                    feeForTxAndCalldata,
                ) {
                    setGlobalAccountStore(globalAS);
                } else {
                    return (const::TxResultCode_noGasFunds, maybeRequest, maybeTx);
                }

                // compute the number of ArbGas units corresponding to the aggregator fee, and deduct them from the tx
                // round up to the nearest integer number of units -- this will burn the wei that would pay
                //       for a fractional gas ArbGas unit (rounding down would credit the user with fractional
                //       ETH that don't we don't have)
                let roundedUpGasDelta = (feeForTxAndCalldata + prices.perArbGasTotal - 1) / prices.perArbGasTotal;
                if (tx.maxGas > roundedUpGasDelta) {
                    tx = tx with { maxGas: tx.maxGas - roundedUpGasDelta };
                } else {
                     return (const::TxResultCode_noGasFunds, maybeRequest, maybeTx);
                }
            }
            if (tx.maxGas > gasAccountingInfo.gasRemainingThisBlock) {
                return (const::TxResultCode_congestion, maybeRequest, maybeTx);
            }

            (
                const::TxResultCode_success,
                maybeRequest,
                Some(tx with {
                        gasPrice: gasAccountingInfo.currentPrices.perArbGasTotal
                    }
                )
            )
        } else {
            (const::TxResultCode_success, maybeRequest, maybeTx)  // shouldn't happen
        }
    } else {
        (const::TxResultCode_success, maybeRequest, maybeTx)
    };
}

impure func updateCongestionState(state: CongestionState, blockNum: uint) -> CongestionState {
    // determine gas pool and congestion price for next block
    let blocksToAdvance = blockNum - state.lastBlockNumSeen;
    let congestionPrice = state.congestionPriceWei;
    let gasPool = state.gasPool;
    let speedLimit = gasAccountingParams.SpeedLimitPerBlock;
    while((blocksToAdvance > 0) && ( (state.gasPool < gasAccountingParams.GasPoolMax) || (congestionPrice > 0) )) {
        blocksToAdvance = blocksToAdvance-1;
        gasPool = gasPool + int(speedLimit);
        if (gasPool > gasAccountingParams.GasPoolMax) {
            gasPool = gasAccountingParams.GasPoolMax;
        }

        let maxtc = gasPool;
        if (maxtc < int(speedLimit)) {
            maxtc = int(speedLimit);
        }
        congestionPrice = xif(19 * speedLimit > uint(maxtc)) {
            congestionPrice * (19 * speedLimit - uint(maxtc)) / (16 * speedLimit)
        } else {
            0
        };
    }
    return struct {
        gasPool: gasPool,
        lastBlockNumSeen: blockNum,
        congestionPriceWei: congestionPrice,
    };
}

public impure func getGasLimitPerTx() -> uint {
    return gasAccountingParams.TxGasLimit;
}

impure func getRequestGasInfo(maybeRequest: option<IncomingRequest>, maybeTx: option<TxRequestData>) -> (bool, uint, address, uint, uint) {
    if let Some(req) = maybeRequest {
        return (false, req.blockNumber, req.sender, 0, 0);
    }
    if let Some(tx) = maybeTx {
        return (true, tx.incomingRequest.blockNumber, tx.incomingRequest.sender, tx.maxGas, tx.gasPrice);
    }
    return (true, gasAccountingInfo.congestionState.lastBlockNumSeen, address(~0), 0, 0);  // shouldn't happen
}

var globalL1GasPriceEstimateWei: uint;

impure func initGasPriceEstimator() {
    globalL1GasPriceEstimateWei = 150*(1000*1000*1000);  // 150 gwei
}

impure func getL1GasPriceEstimate() -> uint {
    return globalL1GasPriceEstimateWei;
}

public impure func updateL1GasPriceEstimate(recentPrice: uint) {
    globalL1GasPriceEstimateWei = (recentPrice + 99 * globalL1GasPriceEstimateWei) / 100;
}