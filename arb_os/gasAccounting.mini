//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

import type AccountStore;
import type Account;
import type ByteArray;
import type MarshalledBytes;
import type MessageBatch;
import type Queue;
import type PriorityQ;

import func getGlobalAccountStore() -> AccountStore;
import func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func accountStore_set(acctStore: AccountStore, addr: address, acct: Account) -> AccountStore;
import func account_addToEthBalance(acct: Account, amount: uint) -> Account;
import func account_deductFromEthBalance(acct: Account, amount: uint) -> option<Account>;

import func bytearray_new(capacityHint: uint) -> ByteArray;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;

import func queue_new() -> Queue;
import func queue_isEmpty(q: Queue) -> bool;
import func queue_put(q: Queue, item: any) -> Queue;
import func queue_get(q: Queue) -> option<(Queue, any)>;

import func priorityq_new() -> PriorityQ;
import func priorityq_isEmpty(pq: PriorityQ) -> bool;
import func priorityq_get(pq: PriorityQ) -> option<(any, PriorityQ)>;
import func priorityq_insert(pq: PriorityQ, item: any, priority: uint) -> PriorityQ;

import impure func inbox_getNextUnpackedRequest() -> (option<IncomingRequest>, option<TxRequestData>);
import impure func inbox_currentTimestamp() -> uint;

import impure func chainParams_speedLimitPerSecond() -> uint;

import impure func outputStats_endOfBlock(blockNum: uint, timestamp: uint);


type ReimbursementRates = struct {
    weiPerSecond: uint,
    weiPerArbGas: uint,
}

var gasAccountingInfo: struct {
    weiOwedForOverhead: int,      // amount of currency that needs to be collected to cover overhead
    weiCollectedFromTxs: uint,    // amount of currency collected from txs but not yet paid out to validators
    txState: option<TxGasState>,  // status of currently active tx (if there is one)
    reimbursementRates: ReimbursementRates,
    lastTimestamp: option<uint>,  // last timestamp seen in a block
    baseGasPrice: uint,           // current base gas price, in wei
    gasTank: uint,                // amount of gas available for txs
    congestionQueue: Queue,       // queue of messages selected for execution by the congestion auction
};

type TxGasState = struct {
    gasInReserve: uint,  // how much gas is being held in reserve
    originalMax: uint,   // the tx's original maxGas value
    price: uint,         // price of gas, in wei per unit of gas
    weiHeldForGas: uint, // amount of currency we're holding to cover the current tx's gas use
    refundTo: address,   // who gets a refund for unused gas at the end, if there is any
}

type GasUsage = struct {
    gasUsed: uint,
    gasPriceWei: uint,
}

public impure func gasAccounting_init() {
    gasAccountingInfo = struct {
        weiOwedForOverhead: int(0),
        weiCollectedFromTxs: 0,
        txState: None<TxGasState>,
        reimbursementRates: struct {
            weiPerSecond: 0,
            weiPerArbGas: 0,
        },
        lastTimestamp: None<uint>,
        baseGasPrice: 0,
        gasTank: gasTankLimit(),
        congestionQueue: queue_new(),
    };
}

// The currently-running Tx has some amount of gas remaining. That gas can be in two places:
// *  in the ArbGasRemaining register, if that register is < 2**255
// *  in reserve
//
// The state of the ArbGasRemaining register tells us whether we're currently charging gas to the tx or to the OS.
// *  If the register is < 2**255, we're charging to the tx
// *  If the register is >= 2**255, we're charging to the OS
// Note that if execution in the tx (or a subcall it makes) runs out of gas, this will generate an Error and
//    set ArbGasRemaining to 2**256 - 1, which correctly puts us into the mode of charging the OS.
// If there is an Error, the Error handler will call us, to inform us that there might have been an out-of-gas situation.
//    (It's up to us to figure out whether there actually was an out-of-gas situation, vs some unrelated error.)
//
// When a new tx starts, we take enough Eth from it to cover its maxGas.
// When that tx is done, we give it a refund for any unused gas.

public impure func gasAccounting_startTxCharges(
    maxGas: uint,
    gasPriceBid: uint,
    payer: address
) -> option<()> {
    // Start charging a new Tx for ArbGas usage
    // The caller should already have verified that the payer has enough funds, but we'll return None if not.

    let _ = switchToChargingOS();   // ignore return value; purpose is to avoid error if already charging a tx

    if (maxGas >= asm(255, 1) uint { shl }) {  // make sure we're not setting tx gas remaining to invalid value
        maxGas = asm(255, 1) uint { shl } - 1;
    }

    // set gas price based on bid and base price
    let gasPrice = gasAccountingInfo.baseGasPrice;
    if (gasPriceBid != 0) {
        if (gasPriceBid < gasPrice) {
            // caller submitted a gas price bid, and it was too low, so return insufficient funds
            return None;
        }
    }

    // take funds from the payer, enough to pay for maxGas at gasPrice
    let weiToHold = maxGas * gasPrice;
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            payer,
            account_deductFromEthBalance(
                accountStore_get(globalAS, payer),
                weiToHold
            )?   // note: returns None if insufficient balance
        )
    );

    let gasUsed = (~0) - asm() uint { getgas };
    let usedFromTank = gasUsed;
    if (usedFromTank > gasAccountingInfo.gasTank) {
        usedFromTank = gasAccountingInfo.gasTank;
    }
    gasAccountingInfo = gasAccountingInfo with {
        weiOwedForOverhead: gasAccountingInfo.weiOwedForOverhead + int(gasUsed * gasAccountingInfo.reimbursementRates.weiPerArbGas)
    } with {
        gasTank: gasAccountingInfo.gasTank - usedFromTank
    } with {
        txState: Some(struct {
            gasInReserve: 0,
            originalMax: maxGas,
            price: gasPrice,
            weiHeldForGas: weiToHold,
            refundTo: payer,
        })
    };

    asm(maxGas,) { setgas };
    return Some(());
}

public impure func gasAccounting_endTxCharges() -> option<GasUsage> {
    // stop charging the current tx for gas
    // refund any unused gas
    // return the total amount it used, or None if there isn't a tx active

    // switch over to charging the OS for gas
    let txState = gasAccountingInfo.txState?;
    let gasToRefund = txState.gasInReserve + switchToChargingOS();

    // refund the unused gas
    let refund = gasToRefund * txState.price;
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            txState.refundTo,
            account_addToEthBalance(
                accountStore_get(globalAS, txState.refundTo),
                refund
            )
        )
    );

    // figure out how much overhead was paid by the tx (this could be negative, if tx was subsidized)
    let overheadPaid = int(txState.originalMax - gasToRefund) *
                       (int(gasAccountingInfo.baseGasPrice) - int(gasAccountingInfo.reimbursementRates.weiPerArbGas));

    gasAccountingInfo = gasAccountingInfo with {
        weiCollectedFromTxs: gasAccountingInfo.weiCollectedFromTxs
                                + (txState.weiHeldForGas - refund)
    } with {
        weiOwedForOverhead: gasAccountingInfo.weiOwedForOverhead - overheadPaid
    } with {
        txState: None<TxGasState>
    } with {
        gasTank: gasAccountingInfo.gasTank + gasToRefund  // won't overflow because we're returning gas we took out before
    };

    return Some(
        struct {
            gasUsed: txState.originalMax-gasToRefund,
            gasPriceWei: txState.price
        }
    );
}

public impure func gasAccounting_pauseTxCharges() -> uint {
    // pause charging the currently running tx
    // return how many units of the tx's initial maxGas are still unused

    if let Some(txState) = gasAccountingInfo.txState {
        let gasRemaining = txState.gasInReserve + switchToChargingOS();
        gasAccountingInfo = gasAccountingInfo with {
            txState: Some(
                txState with {
                    gasInReserve: gasRemaining
                }
            )
        };
        return gasRemaining;
    } else {
        // oops, someone tried to pause tx charges when there's no active tx
        // to be safe, report that the tx is completely out of gas
        return 0;
    }
}

public impure func gasAccounting_resumeTxCharges(allocationRequested: uint) -> uint {
    // resume the charging of the tx for gas
    // allocationRequested is how much of its gas the tx wants to allocate
    // return how much gas we actually allocated = min(requested, available)

    let _ = switchToChargingOS();   // ignore return value; purpose is to avoid error if already charging a tx

    if let Some(txState) = gasAccountingInfo.txState {
        let gasUsed = (~0) - asm() uint { getgas };
        let usedFromTank = gasUsed;
        if (usedFromTank > gasAccountingInfo.gasTank) {
            usedFromTank = gasAccountingInfo.gasTank;
        }

        if (allocationRequested > txState.gasInReserve) {
            allocationRequested = txState.gasInReserve;  // can't request more gas than you have
        }
        gasAccountingInfo = gasAccountingInfo with {
            weiOwedForOverhead: gasAccountingInfo.weiOwedForOverhead + int(gasUsed * gasAccountingInfo.reimbursementRates.weiPerArbGas)
        } with {
            gasTank: gasAccountingInfo.gasTank - usedFromTank
        } with {
            txState: Some(
                txState with {
                    gasInReserve: txState.gasInReserve - allocationRequested
                }
            )
        };

        asm(allocationRequested,) { setgas };  // start charging the application
        return allocationRequested;
    } else {
        // something went wrong: tried to resume tx charges when there isn't an active tx
        // to be safe, report that tx is completely out of gas
        return 0;
    }
}

impure func switchToChargingOS() -> uint {
    // switch to charging the OS for gas, if we aren't already
    // return amount of the tx's gas that was left over in ArbGasRemaining
    let gasRemaining = asm() uint { getgas };
    if (gasRemaining >= asm(255, 1) uint { shl }) {
        // we were already charging the OS, tx has nothing remaining
        return 0;
    } else {
        // we were charging the tx; switch to charging the OS and return tx's unused amount from ArbGasRemaining
        asm(~0,) { setgas };
        return gasRemaining;
    }
}

// This structure describes an incoming request.
// It is declared identically in inbox.mini and elsewhere
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: MarshalledBytes  // kind-specific data, as a marshalled bytearray
}

// TxRequestData is declared identically in message.mini and elsewhere.
type TxRequestData = struct {
    maxGas: uint,
    gasPrice: uint,
    seqNum: option<uint>,
    caller: address,
    calleeAddr: address,
    value: uint,
    calldata: ByteArray,
    incomingRequest: IncomingRequest,
}

// The next section of code implements the congestion auction. For each request, the auction
//     determines (a) whether to approve the request for execution, and (b) what gas price the request will pay.
// This uses a "pull" interface: the main run loop calls this to get the next request.
//     This code will in turn call back to the inbox to pull in incoming requests from the L1.
// Eventually this component will pull in a group of requests from the inbox, run the congestion
//     auction over them, then enqueue them to be eventually fetched by the main run loop.
// For now, this approves every request, and charges zero gas price.
public impure func getNextRequestFromCongestionAuction() -> (
    bool,           // was it approved for execution
    option<IncomingRequest>,  // if it was an L1 message
    option<TxRequestData>,    // if it was an L2 tx message
) {
    loop {
        if (queue_isEmpty(gasAccountingInfo.congestionQueue)) {
            // if needed, advance timestamp and update base gas price
            if let Some(timestamp) = gasAccountingInfo.lastTimestamp {
                let current = inbox_currentTimestamp();
                if (timestamp < current) {
                    let delta = current - timestamp;

                    let updatedTank = gasAccountingInfo.gasTank + delta * chainParams_speedLimitPerSecond();
                    if (updatedTank > gasTankLimit()) {
                        updatedTank = gasTankLimit();
                    }

                    let overhead = gasAccountingInfo.weiOwedForOverhead + int(delta * gasAccountingInfo.reimbursementRates.weiPerSecond);
                    let speedLimit = chainParams_speedLimitPerSecond();
                    let ibase = int(0);
                    if (delta > 30) {
                        ibase = int(3 * gasAccountingInfo.baseGasPrice / 4) + overhead / int(4 * 120 * speedLimit);
                    } else {
                        ibase = int((120-delta) * gasAccountingInfo.baseGasPrice / 120) + int(delta) * overhead / int(120 * 120 * speedLimit);
                    }
                    let base = gasAccountingInfo.reimbursementRates.weiPerArbGas / 2;
                    if (ibase > int(base)) {
                        base = uint(ibase);
                    }

                    gasAccountingInfo = gasAccountingInfo with {
                        lastTimestamp: Some(current)
                    } with {
                        weiOwedForOverhead: overhead
                    } with {
                        baseGasPrice: base
                    } with {
                        gasTank: updatedTank
                    };
                }
            } else {
                gasAccountingInfo = gasAccountingInfo with { lastTimestamp: Some(inbox_currentTimestamp()) };
            }

            // read in an L1 block of requests and queue them
            let q = gasAccountingInfo.congestionQueue;
            let moreToRead = true;
            while (moreToRead) {
                let (maybeRequest, maybeTx) = inbox_getNextUnpackedRequest();
                if let Some(request) = maybeRequest {
                    if (request.kind == 6) {
                        // got to the end of an L1 block, stop queueing after this message
                        moreToRead = false;
                    } else {
                        if (request.kind == 5) { // other kinds that can exist here all charge 0 gas
                            let maxGas = bytearray_get256(bytearray_unmarshalBytes(request.msgData), 0);
                            if (maxGas > gasAccountingInfo.gasTank) {
                                gasAccountingInfo = gasAccountingInfo with { gasTank: 0 };
                            } else {
                                gasAccountingInfo = gasAccountingInfo with { gasTank: gasAccountingInfo.gasTank - maxGas };
                            }
                        }
                        q = queue_put(q, (maybeRequest, maybeTx));
                    }
                } else {
                    if let Some(tx) = maybeTx {
                        if (tx.maxGas > gasAccountingInfo.gasTank) {
                            gasAccountingInfo = gasAccountingInfo with { gasTank: 0 };
                        } else {
                            gasAccountingInfo = gasAccountingInfo with { gasTank: gasAccountingInfo.gasTank - tx.maxGas };
                        }
                        q = queue_put(q, (maybeRequest, maybeTx));
                    } else {
                        // this should never happen; if it does, we don't have a request so loop back and try again
                    }
                }
            }
            gasAccountingInfo = gasAccountingInfo with { congestionQueue: q };
        } else {
            if let Some(res) = queue_get(gasAccountingInfo.congestionQueue) {
                let (uq, item) = res;
                gasAccountingInfo = gasAccountingInfo with { congestionQueue: uq };
                let (maybeReq, maybeTx) = unsafecast<(option<IncomingRequest>, option<TxRequestData>)>(item);
                if let Some(request) = maybeReq {
                    if (request.kind == 6) {
                        // it's an end-of-block message; send the end-of-block log, then discard the message
                        outputStats_endOfBlock(request.blockNumber, request.timestamp);
                    } else {
                        return (true, maybeReq, maybeTx);
                    }
                } else {
                    return (true, maybeReq, maybeTx);
                }
            }
            gasAccountingInfo = gasAccountingInfo with { congestionQueue: queue_new() };
        }
    }
}

// The "gas tank" holds gas that is available to be allocated to incoming requests.
// Gas is subtracted from the tank when a request is going to use that gas.
// Gas is added to the tank when time passes, or when a request returns some unused gas.
// The gas tank has a maximum capacity, which is returned by the following function.
impure func gasTankLimit() -> uint {
    return 120 * chainParams_speedLimitPerSecond();
}

// congestionAuction takes a queue of (maybeReq, maybeTx, maxGas, gasBid) tuples, and returns
//    a triple (outQ, totalGas, gasPrice) where outQ is a queue of (isApproved, maybeReq, maybeTx) triples
func congestionAuction(inQ: Queue, gasAvailable: uint) -> (Queue, uint, uint) {
    let gasAvailableIn = gasAvailable;
    let pq = priorityq_new();
    let maxGasBid = (asm(256-48, 1) uint { shl }) - 1;
    let numBidders = 0;
    let gasPrice = 0;
    while ( !queue_isEmpty(inQ) ){
        if let Some(res) = queue_get(inQ) {
            let (uq, item) = res;
            inQ = uq;
            let (maybeReq, maybeTx, maxGas, gasBid) = unsafecast<(option<IncomingRequest>, option<TxRequestData>, uint, uint)>(item);
            if (gasBid > maxGasBid) {
                gasBid = maxGasBid;
            }
            pq = priorityq_insert(pq, (maybeReq, maybeTx, maxGas, gasBid, numBidders), gasBid);
        }
        numBidders = numBidders + 1;
    }

    let pq2 = priorityq_new();   // use this to put items back into original order
    while ( !priorityq_isEmpty(pq) ) {
        if let Some(res) = priorityq_get(pq) {
            let (rawItem, upq) = res;
            pq = upq;
            let (maybeReq, maybeTx, maxGas, gasBid, index) = unsafecast<(option<IncomingRequest>, option<TxRequestData>, uint, uint, uint)>(rawItem);
            if ( (gasAvailable > 0) && (maxGas <= gasAvailable) ) {
                // auction winner
                gasAvailable = gasAvailable - maxGas;
                pq2 = priorityq_insert(pq2, (true, maybeReq, maybeTx), (~0)-index);
            } else {
                // auction loser
                if (gasPrice == 0) {
                    gasPrice = gasBid;
                }
                gasAvailable = 0;
                pq2 = priorityq_insert(pq2, (false, maybeReq, maybeTx), (~0)-index);
            }
        }
    }

    let retq = queue_new();
    loop {
        if let Some(res) = priorityq_get(pq2) {
            let (rawItem, upq) = res;
            pq2 = upq;
            let (item, _) = unsafecast<(any, any)>(rawItem);
            retq = queue_put(retq, item);
        } else {
            return (retq, gasAvailableIn-gasAvailable, gasPrice);
        }
    }
}