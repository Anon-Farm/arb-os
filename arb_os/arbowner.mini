//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use chainParameters::chainParams_getOwner;
use chainParameters::chainParams_setOwner;

use evmCallStack::EvmCallFrame;
use evmCallStack::evmCallStack_topFrame;
use evmCallStack::evmCallStack_callHitError;
use evmCallStack::evmCallFrame_getCalldata;
use evmCallStack::evmCallFrame_getCaller;

use evmOps::evmOp_return;
use evmOps::evmOp_revert_knownCodePc;

use std::bytearray::ByteArray;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_get256;


public impure func arbowner_txcall() {
    asm(107,) { debugprint };
    if let Some(topFrame) = evmCallStack_topFrame() {
        let calldata = evmCallFrame_getCalldata(topFrame);
        if (bytearray_size(calldata) < 4) {
            evmOp_revert_knownCodePc(address(107), 0, 0, 0);
        }
        let funcCode = asm(224, bytearray_get256(calldata, 0)) uint { shr };
        if (funcCode == 0x803e3ce8) {
            arbowner_giveOwnership(topFrame, calldata);
        } else {
            // unrecognized function code
            evmOp_revert_knownCodePc(address(107), 1, 0, 0);
        }
    } else {
        // this shouldn't happen -- should always be called in an EVM tx
        evmCallStack_callHitError(22);
    }
}

impure func arbowner_giveOwnership(topFrame: EvmCallFrame, calldata: ByteArray) {  // (address)
    if (bytearray_size(calldata) != 36) {
        evmOp_revert_knownCodePc(address(107), 10, 0, 0);
    }
    if (Some(evmCallFrame_getCaller(topFrame)) != chainParams_getOwner()) {
        evmOp_revert_knownCodePc(address(107), 11, 0, 0);
    }
    chainParams_setOwner(address(bytearray_get256(calldata, 4)));
    evmOp_return(0, 0);
}


