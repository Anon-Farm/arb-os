//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::bytearray::ByteArray;
use std::bytestream::ByteStream;
use std::bytearray::MarshalledBytes;
use accounts::AccountStore;
use accounts::Account;
use evmlogs::EvmLogs;
use std::storageMap::StorageMap;

use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::accountStore_transferEthBalance;
use accounts::accountStore_createAccountFromEvmCode;
use accounts::account_checkAndIncrSeqNum;
use accounts::account_fetchAndIncrSeqNum;
use accounts::account_hasContract;

use accounts::account_incrSeqNum;
use accounts::account_getNextSeqNum;
use accounts::account_addToEthBalance;
use accounts::account_getStartCodePoint;

use evmCallStack::initEvmCallStack;
use evmCallStack::initEvmCallStackForConstructor;
use evmCallStack::evmCallStack_runningCodeFromAccount;
use output::emitTxReceipt;

use tokens::tokens_erc20deposit;
use tokens::tokens_erc721deposit;

use std::bytearray::bytearray_new;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_marshalFull;
use std::bytearray::bytearray_extract;

use std::bytestream::bytestream_new;
use std::bytestream::bytestream_getByte;
use std::bytestream::bytestream_get256;
use std::bytestream::bytestream_skipBytes;
use std::bytestream::bytestream_getRemainingBytes;

use std::rlp::keccakOfRlpEncodedUintPair;

use codeSegment::translateEvmCodeSegment;

use inbox::IncomingRequest;

use gasAccounting::GasUsage;


public impure func handleL1Request(
    msg: IncomingRequest
) -> option<()> {   // return None if error; otherwise return Some(()) or do a tx and never return from here
    // Parse an incoming message and do appropriate computations
    let inStream = bytestream_new(msg.msgData);

    if (msg.kind == const::L1MessageType_ethDeposit) {
        // ethdeposit message
        let (bs, destination) = bytestream_get256(inStream)?;
        inStream = bs;

        let (bs, amount) = bytestream_get256(inStream)?;
        inStream = bs;

        let globalAS = getGlobalAccountStore();
        let destAccount = accountStore_get(globalAS, address(destination));
        destAccount = account_addToEthBalance(destAccount, amount);
        setGlobalAccountStore(
            accountStore_set(
                globalAS,
                address(destination),
                destAccount
            )
        );
        return Some(());
    } elseif (msg.kind == const::L1MessageType_erc20Deposit) {
        // ERC20 deposit message
        let (bs, tokenAddress) = bytestream_get256(inStream)?;
        inStream = bs;

        let (bs, payeeAddress) = bytestream_get256(inStream)?;
        inStream = bs;

        let (bs, amount) = bytestream_get256(inStream)?;
        inStream = bs;

        tokens_erc20deposit(
            address(tokenAddress),
            address(payeeAddress),
            amount,
            msg
        )?;  // should never return

        return None;
    } elseif (msg.kind == const::L1MessageType_erc721Deposit) {
         // ERC721 deposit message
         let (bs, tokenAddress) = bytestream_get256(inStream)?;
         inStream = bs;

         let (bs, payeeAddress) = bytestream_get256(inStream)?;
         inStream = bs;

         let (bs, id) = bytestream_get256(inStream)?;
         inStream = bs;

         tokens_erc721deposit(
             address(tokenAddress),
             address(payeeAddress),
             id,
             msg
         )?;  // should never return

         return None;
    } else {
        // not a valid message type
        // (This should not have been called if msg.kind == const::L1MessageType_L2.)
        return None;
    }
}

impure func verifyAndIncrSequenceNum(addr: address, seqNum: uint) -> option<()> {
    // Verify the sequence number on a message.
    // If it matches, increment the next expected seq num, and return Some(()).
    // Else, change nothing and return None.
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            addr,
            account_checkAndIncrSeqNum(
                accountStore_get(globalAS, addr),
                seqNum
            )?
        )
    );
    return Some(());
}

impure func fetchAndIncrSequenceNum(addr: address) -> uint {
    // Fetch sequence number, and increment it
    let globalAS = getGlobalAccountStore();
    let (ret, updatedAcct) = account_fetchAndIncrSeqNum(
        accountStore_get(globalAS, addr)
    );
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            addr,
            updatedAcct
        )
    );
    return ret;
}

type TxRequestData = struct {
    maxGas: uint,
    gasPrice: uint,
    seqNum: option<uint>,
    caller: address,
    calleeAddr: address,
    value: uint,
    calldata: ByteArray,
    nonMutating: bool,
    isConstructor: bool,
    incomingRequest: IncomingRequest,
}

public impure func handleL2Request(
    inStream: ByteStream,
    request: TxRequestData
) -> option<()> {   // return None if message is malformatted; otherwise handle errors and return Some(()); if no error, never return
    if let Some(sequenceNum) = request.seqNum {
        if (account_getNextSeqNum(
                accountStore_get(getGlobalAccountStore(), request.caller)
            ) != sequenceNum) {
            // bad sequence number error
            emitTxReceipt(
                request.incomingRequest,
                const::TxResultCode_badSequenceNum,
                None<ByteArray>,
                None<EvmLogs>,
                None<GasUsage>
            );
            return Some(());
        }
    }

    if (request.calleeAddr == address(0)) {
        // this is a constructor call
        if (request.nonMutating) {
            // revert error (tried to call constructor in a non-mutating call)
            emitTxReceipt(
                request.incomingRequest,
                const::TxResultCode_revert,
                None<ByteArray>,
                None<EvmLogs>,
                None<GasUsage>
                );
            return Some(());
        }

        // increment the caller's sequence number, unconditionally
        let acctStore = getGlobalAccountStore();
        setGlobalAccountStore(
            accountStore_set(
                acctStore,
                request.caller,
                account_incrSeqNum(
                    accountStore_get(acctStore, request.caller)
                )
            )
        );

        let codeBytes = request.calldata;
        request = request with { calldata: bytearray_new(0) };
        let (codept, evmJumpTable, _) = translateEvmCodeSegment(bytestream_new(codeBytes), false)?;

        if (request.seqNum == None<uint>) {
            request = request with { seqNum: Some(fetchAndIncrSequenceNum(request.caller)) };
        }
        if (request.incomingRequest.kind == const::L1MessageType_buddyDeploy) {
            // it's a buddy contract deployment; hardwire the new contract address
            request = request with { calleeAddr: request.caller };
        } else {
            // ordinary contract deploy; use the standard formula to calculate new contract address
            request = request with {
                calleeAddr: address(keccakOfRlpEncodedUintPair(uint(request.caller), request.seqNum?))
            };
        }

        if (account_hasContract(accountStore_get(getGlobalAccountStore(), request.calleeAddr))) {
            // there's already an account at that address, revert the call
            emitTxReceipt(request.incomingRequest, 7, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
            return Some(());
        } else {
            initEvmCallStackForConstructor(
                codeBytes,
                evmJumpTable,
                codept,
                request
            );  // should never return
        }
    } else {
        // this is a non-constructor call
        let callKind = const::EVMCallType_call;
        if (request.nonMutating) {
            callKind = const::EVMCallType_staticcall;
        }

        initEvmCallStack(
            callKind,
            request
        );  // should never return
    }

    panic;   // this should never be reached
}
