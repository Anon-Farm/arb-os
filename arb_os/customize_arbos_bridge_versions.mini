//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

use bridge_arbos_versions::GlobalsBeforeUpgrade;

use bridge_arbos_versions::before__accounts_Account;
use bridge_arbos_versions::before__retrybuffer_RetryableTx;
use bridge_arbos_versions::before__messages_IncomingRequest;
use bridge_arbos_versions::before__messages_TxFeeStats;
use bridge_arbos_versions::before__inbox_ByteArray;

use accounts::Account;
use accounts::AccountStore;
use accounts::AggregatorInfo;

use evmCallStack::EvmCallFrame;
use evmCallStack::IncomingRequestAndLogs;

use inbox::TxRequestQueue;
use inbox::IncomingRequestQueueStack;
use inbox::mapL1SenderAddress;

use messages::TxRequestData;

use retrybuffer::RetryableTx;

use std::addressSet::SetOfAddresses;
use std::addressSet::AddressPairSet;
use std::addressSet::setOfAddresses_emptySet;
use std::addressSet::setOfAddresses_add;
use std::addressSet::addressPairSet_new;

use std::queue::queue_map;

use core::kvs::Kvs;
use core::kvs::builtin_kvsForall;

public func set_globalCallStack_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> option<EvmCallFrame> {
    return None<EvmCallFrame>;
}

public func set_globalCurrentTxRequest_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> TxRequestData {
    return unsafecast<TxRequestData>(());   // safe because globalCurrentTxRequest will be written before used
}

public func set_globalAccountStore_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> AccountStore {
    let oldGAS = oldGlobals.globalAccountStore;
    let acctsRemapResult = builtin_kvsForall(
        unsafecast<Kvs>(oldGAS.accounts),
        unsafecast<func(any, any, any) -> any>(acctRemapClosure),
        newmap<address, Account>,
    );
    return struct {
        accounts: unsafecast<map<address, Account>>(acctsRemapResult),
        retryBuffer: struct {
            byTxId: {
                let m = newmap<uint, RetryableTx>;
                unsafecast<map<uint, RetryableTx> >(
                    builtin_kvsForall(
                        unsafecast<Kvs>(oldGAS.retryBuffer.byTxId),
                        unsafecast<func(any, any, any) -> any>(urbClosure),
                        m
                    )
                )
            },
            fifo: oldGAS.retryBuffer.fifo,
            txLifetimeSeconds: oldGAS.retryBuffer.txLifetimeSeconds,
        },
        numContracts: oldGAS.numContracts,
        codeRefTable: oldGAS.codeRefTable,
        escrowStore: oldGAS.escrowStore,
    };
}

func urbClosure(
    key: uint,
    value: before__retrybuffer_RetryableTx,
    state: map<uint, RetryableTx>
) -> map<uint, RetryableTx> {
    return state with {
        [key] = struct {
            txId: value.txId,
            sender: value.sender,
            destination: value.destination,
            callvalue: value.callvalue,
            callvalueEscrowKey: value.callvalueEscrowKey,
            beneficiary: value.beneficiary,
            calldata: value.calldata,
            expiryTime: value.expiryTime,
            l1Message: value.l1Message,
            originalSender: value.sender,
        }
    };
}

func acctRemapClosure(_addr: address, oldAcct: before__accounts_Account, state: map<address, Account>) -> map<address, Account> {
    let acct = struct {
        addr: oldAcct.addr,
        blsKey: oldAcct.blsKey,
        nextSeqNum: oldAcct.nextSeqNum,
        ethBalance: oldAcct.ethBalance,
        contractInfo: oldAcct.contractInfo,
        aggregatorInfo: xif let Some(aggInfo) = oldAcct.aggregatorInfo {
            Some(
                struct {
                    decompressionState: aggInfo.decompressionState,
                    feeCollector: aggInfo.feeCollector,
                    baseTxFeeL1Gas: const::Default_Param_DefaultBaseTxFeeL1Gas,
                }
            )
        } else {
            None<AggregatorInfo>
        },
        aggregatorToPay: oldAcct.aggregatorToPay,
    };
    return state with {
        [acct.addr] = acct
    };
}

public func set_globalCurrentRetryableRequest_onUpgrade(
    _old: GlobalsBeforeUpgrade
) -> option<IncomingRequestAndLogs> {
    return None<IncomingRequestAndLogs>;
}

public func set_addressRemapExceptions_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> AddressPairSet {
    return addressPairSet_new();
}

public func set_globalInputQueue_onUpgrade(
    oldGlobals: GlobalsBeforeUpgrade
) -> struct {
    txQ: TxRequestQueue,
    batchQ: IncomingRequestQueueStack,
}{
    return struct {
        txQ: struct {
            q: queue_map(
                oldGlobals.globalInputQueue.txQ.q,
                unsafecast<func(any, any) -> any>(sgiqouClosure),
                (),
            ),
        },
        batchQ: oldGlobals.globalInputQueue.batchQ,
    };
}

func sgiqouClosure(
    item: struct {
        maxGas: uint,
        gasPrice: uint,
        seqNum: option<uint>,
        caller: address,
        calleeAddr: address,
        gasPayer: address,
        value: uint,
        calldata: before__inbox_ByteArray,
        nonMutating: bool,
        isConstructor: bool,
        incomingRequest: before__messages_IncomingRequest,
        feeStats: before__messages_TxFeeStats,
        fromRetryable: option<before__retrybuffer_RetryableTx>,
    },
    _unused: ()
) -> TxRequestData {
    return struct {
        maxGas: item.maxGas,
        gasPrice: item.gasPrice,
        seqNum: item.seqNum,
        caller: item.caller,
        calleeAddr: item.calleeAddr,
        gasPayer: item.gasPayer,
        value: item.value,
        calldata: item.calldata,
        nonMutating: item.nonMutating,
        isConstructor: item.isConstructor,
        incomingRequest: item.incomingRequest,
        feeStats: item.feeStats,
        fromRetryable: xif let Some(oldRetryable) = item.fromRetryable {
            Some(
                struct {
                    txId: oldRetryable.txId,
                    sender: oldRetryable.sender,
                    destination: oldRetryable.destination,
                    callvalue: oldRetryable.callvalue,
                    callvalueEscrowKey: oldRetryable.callvalueEscrowKey,
                    beneficiary: oldRetryable.beneficiary,
                    calldata: oldRetryable.calldata,
                    expiryTime: oldRetryable.expiryTime,
                    l1Message: oldRetryable.l1Message,
                    originalSender: oldRetryable.sender,
                }
            )
        } else {
            None<RetryableTx>
        },
        originalCaller: item.caller,
    };
}

public func set_chainOwners_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> SetOfAddresses {
    let empty = setOfAddresses_emptySet();
    let constKeyForChainOwner = 0x1567aa7175e04611d194275bb504cc64e920959dd01df9d86ab047367aa4c534;
    return xif let Some(oldOwner) = oldGlobals.globalChainParameters[constKeyForChainOwner] {
        setOfAddresses_add(
            setOfAddresses_add(
                empty,
                address(oldOwner),
            ),
            mapL1SenderAddress(address(oldOwner)),
        )
    } else {
        empty
    };
}
