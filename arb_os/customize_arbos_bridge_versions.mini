//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

use bridge_arbos_versions::GlobalsBeforeUpgrade;
use bridge_arbos_versions::before__accounts_Account;
use bridge_arbos_versions::before__accounts_CodeRef;

use accounts::AccountStore;
use accounts::Account;
use accounts::AccountContractInfo;
use accounts::CodeRef;

use evmCallStack::EvmCallFrame;
use evmCallStack::IncomingRequestAndLogs;

use output::PerBlockReceiptData;
use output::OutputStatistics;

use core::kvs::Kvs;
use core::kvs::builtin_kvsForall;


public func set_globalChainParameters_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> map<uint, uint> {
    return oldGlobals.globalChainParameters
        with { [const::Atom_Param_GasPriceOracle] = const::Default_Param_GasPriceOracle }
        with { [const::Atom_Param_AvmGasPerArbGas] = const::Default_Param_AvmGasPerArbGas }
    ;
}

public func set_globalCallStack_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> option<EvmCallFrame> {
    return None<EvmCallFrame>;
}

public func set_globalCurrentRetryableRequest_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> option<IncomingRequestAndLogs> {
    return None<IncomingRequestAndLogs>;
}

public func set_globalBlockReceiptData_onUpgrade(oldGlobals: GlobalsBeforeUpgrade
) -> struct {
    data: PerBlockReceiptData,
    statsThisBlock: OutputStatistics,
    statsAllTime: OutputStatistics,
    lastArbBlockNum: uint,
    nextSendTimestamp: uint,
} {
    let old = oldGlobals.globalBlockReceiptData;
    return struct {
        data: old.data,
        statsThisBlock: old.statsThisBlock,
        statsAllTime: old.statsAllTime,
        lastArbBlockNum: old.lastBlockNum,
        nextSendTimestamp: old.nextSendTime,
    };
}

public func set_globalAccountStore_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> AccountStore {
    let old = oldGlobals.globalAccountStore;
    return struct {
        accounts: unsafecast<map<address, Account> >(
            builtin_kvsForall(
                unsafecast<Kvs>(old.accounts),
                closure(_k: any, rawAcct: any, rawState: any) -> any {
                    let acct = unsafecast<before__accounts_Account>(rawAcct);
                    let state = unsafecast<map<address, Account> >(rawState);
                    set state[acct.addr] = struct {
                        addr: acct.addr,
                        blsKey: acct.blsKey,
                        nextSeqNum: acct.nextSeqNum,
                        ethBalance: acct.ethBalance,
                        contractInfo: xif let Some(ci) = acct.contractInfo {
                            Some(struct {
                                evmCodeFormatVersion: const::EvmCodeFormatVersion_legacy,
                                code: ci.code,
                                evmJumpTable: ci.evmJumpTable,
                                startCodePoint: ci.startCodePoint,
                                storage: ci.storage,
                            })
                        } else {
                            None<AccountContractInfo>
                        },
                        aggregatorInfo: acct.aggregatorInfo,
                        aggregatorToPay: acct.aggregatorToPay,
                    };
                    return state;
                },
                newmap<address, Account>,
            )
        ),
        retryBuffer: old.retryBuffer,
        numContracts: old.numContracts,
        codeRefTable: unsafecast<map<bytes32, CodeRef> >(
            builtin_kvsForall(
                unsafecast<Kvs>(old.codeRefTable),
                closure(rawIndex: any, rawCodeRef: any, rawState: any) -> any {
                    let index = unsafecast<bytes32>(rawIndex);
                    let oldCodeRef = unsafecast<before__accounts_CodeRef>(rawCodeRef);
                    let state = unsafecast<map<bytes32, CodeRef> >(rawState);
                    set state[index] = struct {
                        refCount: oldCodeRef.refCount,
                        evmCodeFormatVersion: const::EvmCodeFormatVersion_legacy,
                        code: oldCodeRef.code,
                        evmJumpTable: oldCodeRef.evmJumpTable,
                        startCodePoint: oldCodeRef.startCodePoint,
                    };
                    return state;
                },
                newmap<bytes32, CodeRef>
            )
        ),
        escrowStore: old.escrowStore,
    };
}
