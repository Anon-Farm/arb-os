//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

import type ByteStream;
import func bytestream_getByte(bs: ByteStream) -> option<(ByteStream, uint)>;
import func rlp_decodeUint(bs: ByteStream) -> option<(ByteStream, uint)>;

import type ExpandingIntArray;
import func expandingIntArray_new() -> ExpandingIntArray;
import func expandingIntArray_size(arr: ExpandingIntArray) -> uint;
import func expandingIntArray_get(arr: ExpandingIntArray, index: uint) -> uint;
import func expandingIntArray_set(arr: ExpandingIntArray, index: uint, val: uint) -> ExpandingIntArray;

import type IncomingRequest;
import type Queue;

import func queue_new() -> Queue;


type Decompressor = func(IncomingRequest, ByteStream) -> Queue

type IndexedAddressTable = struct {
    byIndex: ExpandingIntArray,
    byAddress: map<address, uint>,
    size: uint
}

public func addressTable_new() -> IndexedAddressTable {
    return struct {
        byIndex: expandingIntArray_new(),
        byAddress: newmap<address, uint>,
        size: 0
    };
}

public func addressTable_size(iat: IndexedAddressTable) -> uint {
    return iat.size;
}

public func addressTable_getByIndex(iat: IndexedAddressTable, index: uint) -> address {  // returns zero if not in table
    return address(expandingIntArray_get(iat.byIndex, index));
}

public func addressTable_getByAddress(iat: IndexedAddressTable, addr: address) -> option<uint> {
    return iat.byAddress[addr];
}

public func addressTable_getByAddressAlloc(iat: IndexedAddressTable, addr: address) -> (IndexedAddressTable, uint) {
    if let Some(val) = iat.byAddress[addr] {
        return (iat, val);
    } else {
        return (
            iat with {
                byIndex: expandingIntArray_set(iat.byIndex, iat.size, uint(addr))
            } with {
                byAddress: iat.byAddress with {
                    [addr] = iat.size
                }
            } with {
                size: 1+iat.size
            },
            iat.size
        );
    }
}

public func decompressAddress(
    bs: ByteStream,
    iat: IndexedAddressTable
) -> option<(ByteStream, address)> {
    let (ustr, index) = rlp_decodeUint(bs)?;
    return Some((ustr, addressTable_getByIndex(iat, index)));
}

public func decompressOffsetUint(bs: ByteStream) -> option<(ByteStream, uint)> {
    let (ustr, base) = rlp_decodeUint(bs)?;
    let (ustr, sh) = bytestream_getByte(ustr)?;
    return Some((ustr, asm(sh, base) uint { shl }));
}

// testDecompressor is designed for us in testing only
//      discards the input
public func testDecompressor(req: IncomingRequest, stream: ByteStream) -> Queue {
    return queue_new();
}
