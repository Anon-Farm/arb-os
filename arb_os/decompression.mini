//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

import type ExpandingIntArray;
import func expandingIntArray_new() -> ExpandingIntArray;
import func expandingIntArray_size(arr: ExpandingIntArray) -> uint;
import func expandingIntArray_get(arr: ExpandingIntArray, index: uint) -> uint;
import func expandingIntArray_set(arr: ExpandingIntArray, index: uint, val: uint) -> ExpandingIntArray;


type IndexedAddressTable = struct {
    byIndex: ExpandingIntArray,
    byAddress: map<address, uint>,
    size: uint
}

public func addressTable_new() -> IndexedAddressTable {
    return struct {
        byIndex: expandingIntArray_new(),
        byAddress: newmap<address, uint>,
        size: 0
    };
}

public func addressTable_size(iat: IndexedAddressTable) -> uint {
    return iat.size;
}

public func addressTable_getByIndex(iat: IndexedAddressTable, index: uint) -> address {  // returns zero if not in table
    return address(expandingIntArray_get(iat.byIndex, index));
}

public func addressTable_getByAddress(iat: IndexedAddressTable, addr: address) -> option<uint> {
    return iat.byAddress[addr];
}

public func addressTable_getByAddressAlloc(iat: IndexedAddressTable, addr: address) -> (IndexedAddressTable, uint) {
    if let Some(val) = iat.byAddress[addr] {
        return (iat, val);
    } else {
        return (
            iat with {
                byIndex: expandingIntArray_set(iat.byIndex, iat.size, uint(addr))
            } with {
                byAddress: iat.byAddress with {
                    [addr] = iat.size
                }
            } with {
                size: 1+iat.size
            },
            iat.size
        );
    }
}