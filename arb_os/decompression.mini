//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

import impure func chainParams_chainId() -> uint;

import type ByteArray;
import type MarshalledBytes;
import func bytearray_new(unused: uint) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import func bytearray_copy(from: ByteArray, fromOffset: uint, to: ByteArray, toOffset: uint, nbytes: uint) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func bytearray_copy(
    from: ByteArray,
    fromOffset: uint,
    to: ByteArray,
    toOffset: uint,
    nbytes: uint,
) -> ByteArray;

import type ByteStream;
import func bytestream_new(ba: ByteArray) -> ByteStream;
import func bytestream_getByte(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_get256(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_getN(bs: ByteStream, n: uint) -> option<(ByteStream, ByteArray)>;
import func bytestream_bytesReadSoFar(bs: ByteStream) -> uint;
import func bytestream_bytesRemaining(bs: ByteStream) -> uint;
import func bytestream_getRemainingBytes(bs: ByteStream) -> ByteArray;
import func rlp_decodeUint(bs: ByteStream) -> option<(ByteStream, uint)>;

import type ExpandingIntArray;
import func expandingIntArray_new() -> ExpandingIntArray;
import func expandingIntArray_size(arr: ExpandingIntArray) -> uint;
import func expandingIntArray_get(arr: ExpandingIntArray, index: uint) -> uint;
import func expandingIntArray_set(arr: ExpandingIntArray, index: uint, val: uint) -> ExpandingIntArray;

import func keccak256(ba: ByteArray, offset: uint, nbytes: uint) -> bytes32;

import type Queue;
import func queue_new() -> Queue;
import func queue_put(q: Queue, item: any) -> Queue;

import type Account;
import type AccountStore;
import impure func getGlobalAccountStore() -> AccountStore;
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func account_getNextSeqNum(account: Account) -> uint;

import func rlp_decodeAddress(bs: ByteStream) -> option<(ByteStream, address)>;
import func rlp_decodeUint(bs: ByteStream) -> option<(ByteStream, uint)>;
import func rlp_encodeMessageInfo(
    seqNum: uint,
    gasPrice: uint,
    gasLimit: uint,
    to: address,
    value: uint,
    data: ByteArray,
    v: uint,
    r: uint,
    s: uint
) -> ByteArray;

import impure func recoverSigner(tx: SignedTx) -> option<address>;

// This structure describes an incoming request.
// It is declared identically in inbox.mini and elsewhere
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: MarshalledBytes  // kind-specific data, as a marshalled bytearray
}

// A copy of this struct is defined in stdlib/rlp.mini.
// The declaration there must remain consistent with the one here.
type SignedTx = struct {
    seqNum: uint,
    gasPrice: uint,
    gasLimit: uint,
    to: address,
    value: uint,
    data: ByteArray,
    v: uint,
    r: uint,
    s: uint
}

type IndexedAddressTable = struct {
    byIndex: ExpandingIntArray,
    byAddress: map<address, uint>,
    size: uint
}

var globalIndexedAddressTable: IndexedAddressTable;

public impure func decompression_init() {
    globalIndexedAddressTable = addressTable_new();
}

public impure func getGlobalAddressTable() -> IndexedAddressTable {
    return globalIndexedAddressTable;
}

public impure func setGlobalAddressTable(gat: IndexedAddressTable) {
    globalIndexedAddressTable = gat;
}

public func addressTable_new() -> IndexedAddressTable {
    return struct {
        byIndex: expandingIntArray_new(),
        byAddress: newmap<address, uint> with { [address(0)] = 0 },
        size: 1
    };
}

public func addressTable_size(iat: IndexedAddressTable) -> uint {
    return iat.size;
}

public func addressTable_getByIndex(iat: IndexedAddressTable, index: uint) -> address {  // returns zero if not in table
    return address(expandingIntArray_get(iat.byIndex, index));
}

public func addressTable_getByAddress(iat: IndexedAddressTable, addr: address) -> option<uint> {
    return iat.byAddress[addr];
}

public func addressTable_getByAddressAlloc(iat: IndexedAddressTable, addr: address) -> (IndexedAddressTable, uint) {
    if let Some(val) = iat.byAddress[addr] {
        return (iat, val);
    } else {
        // allocate space in the table
        return (
            iat with {
                byIndex: expandingIntArray_set(iat.byIndex, iat.size, uint(addr))
            } with {
                byAddress: iat.byAddress with {
                    [addr] = iat.size
                }
            } with {
                size: 1+iat.size
            },
            iat.size
        );
    }
}

public impure func decompressAddress(
    stream: ByteStream,
) -> option<(ByteStream, address)> {
    // Returns None if insufficient data in stream
    // A compressed address is one of three things:
    //   * a single byte 0x80, which is interpreted as the null address
    //   * an RLP-encoding of a value 1-19 bytes in length, which is interpreted as an index into
    //           the IndexedAddressTable, or
    //   * an RLP-encoding of a 20-byte value which is interpreted as an address.
    // In the last case, the address is added to the globalIndexedAddressTable if it is not already there

    let (ustr, firstByte) = bytestream_getByte(stream)?;
    if (firstByte == 0x80) {
        return Some((ustr, address(0)));
    } elseif (firstByte < 0x80 + 20) {
        // don't update stream, because we want to re-start from the beginning
        let (ustr, decodedUint) = rlp_decodeUint(stream)?;
        return Some((ustr, addressTable_getByIndex(globalIndexedAddressTable, decodedUint)));
    } else {
        let (ustr, addr) = rlp_decodeAddress(stream)?;
        let (iat, _) = addressTable_getByAddressAlloc(globalIndexedAddressTable, addr);
        globalIndexedAddressTable = iat;
        return Some((ustr, addr));
    }
}

public func decompressTokenAmount(bs: ByteStream) -> option<(ByteStream, uint)> {
    let (ustr, base) = rlp_decodeUint(bs)?;
    if (base == 0) {
        return Some((ustr, 0));
    }
    let (ustr, sh) = bytestream_getByte(ustr)?;
    return Some((ustr, base * asm(10, sh) uint { exp }));
}

// TxRequestData is declared identically in message.mini and elsewhere.
type TxRequestData = struct {
    maxGas: uint,
    gasPrice: uint,
    seqNum: option<uint>,
    caller: address,
    calleeAddr: address,
    value: uint,
    calldata: ByteArray,
    nonMutating: bool,
    incomingRequest: IncomingRequest,
}

// This is a copy of a struct defined in ArbOS/signedTx.mini.
// The declaration here must remain consistent with the one there.
type SignedTx = struct {
    seqNum: uint,
    gasPrice: uint,
    gasLimit: uint,
    to: address,
    value: uint,
    data: ByteArray,
    v: uint,
    r: uint,
    s: uint
}

public impure func decompressAndVerifyEcdsaSignedTx(
    ba: ByteArray,
    originalRequest: IncomingRequest
) -> option<TxRequestData> {
    let sz = bytearray_size(ba);
    if (sz <= 66) {
        return None;
    }

    let r = bytearray_get256(ba, sz-65);
    let s = bytearray_get256(ba, sz-33);
    let v = bytearray_getByte(ba, sz-1);
    let body = bytearray_extract(ba, 1, sz-66);

    let (_, txRequest) = decompressTx(bytestream_new(body), None<address>, None<FunctionTable>)?;

    let seqNum = 0;
    if let Some(sn) = txRequest.seqNum {
        seqNum = sn;
    }

    if (v < 2) {
        v = 35 + 2 * chainParams_chainId() + (1 - (v % 2));
    }
    let tx = struct {
        seqNum: seqNum,
        gasPrice: txRequest.gasPrice,
        gasLimit: txRequest.maxGas,
        to: txRequest.calleeAddr,
        value: txRequest.value,
        data: txRequest.calldata,
        v: v,
        r: r,
        s: s
    };
    let signer = recoverSigner(tx)?;
    let encodedMessage = rlp_encodeMessageInfo(
        tx.seqNum,
        tx.gasPrice,
        tx.gasLimit,
        tx.to,
        tx.value,
        tx.data,
        tx.v,
        tx.r,
        tx.s,
    );

    return Some(
        txRequest with {
            caller: signer
        } with {
            incomingRequest: originalRequest with {
                requestId: uint(keccak256(encodedMessage, 0, bytearray_size(encodedMessage)))
            } with {
                sender: signer
            } with {
                msgData: bytearray_marshalFull(
                    bytearray_copy(
                        encodedMessage,
                        0,
                        bytearray_setByte(bytearray_new(0), 0, 4),
                        1,
                        bytearray_size(encodedMessage)
                    )
                )
            }
        }
    );
}

public impure func decompressAndVerifyBlsSignedTxBatch(
    ba: ByteArray,
    originalRequest: IncomingRequest,
    txQ: Queue,
) -> option<Queue> {  // returns option<Queue of TxRequestData>
    if (bytearray_size(ba) < 2) {
        return None;
    }
    let numTxs = bytearray_getByte(ba, 1);
    let stream = bytestream_new(bytearray_extract(ba, 2, bytearray_size(ba)-2));
    let i = 0;
    while (i < numTxs) {
        let (ustr, sender) = decompressAddress(stream)?;
        stream = ustr;
        let (ustr, tx) = decompressTx(ustr, Some(sender), None<FunctionTable>)?;

        let startPos = bytestream_bytesReadSoFar(stream) + 2;
        let nbytes = bytestream_bytesReadSoFar(ustr) + 2 - startPos;
        let txHash = keccak256(ba, startPos, nbytes);

        stream = ustr;

        originalRequest = originalRequest with {
            requestId: uint(txHash)
        };
        tx = tx with {
            caller: sender
        } with {
            incomingRequest: originalRequest with {
                requestId: uint(txHash)
            }
        };
        txQ = queue_put(txQ, tx);
        // TODO: remember necessary info about tx and sender, for later BLS verification step
        i = i+1;
    }

    // TODO: read and check check BLS signature

    return Some(txQ);
}

impure func decompressTx(
    stream: ByteStream,
    maybeSender: option<address>,
    maybeTable: option<FunctionTable>,
) -> option<(ByteStream, TxRequestData)> {
    // decompress a compressed transaction, reading it from ByteStream
    // return None if insufficient data in the ByteStream
    // the TxRequestData we return will have an invalid dummy value in the incomingRequest field,
    //         and we'll assume the caller will supply that later
    //
    // caller will tell us the tx sender if it knows the sender
    // (knowing the sender lets us compress the sequence number more efficiently)
    // if we aren't given the sender address, we'll return a dummy value in that slot of the TxRequestData,
    //         and assume the caller will supply it later

    let funcTableEntry = None<FunctionTableEntry>;
    let (ustr, firstByte) = bytestream_getByte(stream)?;  // peek at first byte of stream
    if (firstByte == 0xff) {
        stream = ustr;   // consume the first byte
    } else {
        if let Some(funcTable) = maybeTable {
            // read from beginning of stream (because we haven't set stream = ustr)
            let (ustr, index) = rlp_decodeUint(stream)?;
            stream = ustr;
            if (index < len(funcTable)) {
                funcTableEntry = Some(funcTable[index]);
            }
        } else {
            stream = ustr;
        }
    }

    let sender = address(0);
    let seqNum = 0;
    if let Some(senderAddr) = maybeSender {
        sender = senderAddr;
        let (ustr, seqNumByte) = bytestream_getByte(stream)?;
        stream = ustr;
        let dbSeqNum = account_getNextSeqNum(
            accountStore_get(
                getGlobalAccountStore(),
                address(sender)
            )
        );
        seqNum = (dbSeqNum & ~0xff) | seqNumByte;
        if (seqNum < dbSeqNum) {
            seqNum = seqNum + 256;
        }
    } else {
        let (ustr, rawSeqNum) = rlp_decodeUint(stream)?;
        stream = ustr;
        seqNum = rawSeqNum;
    }

    let (ustr, gasPrice) = rlp_decodeUint(stream)?;
    stream = ustr;

    let gasLimit = 0;
    if let Some(tableEntry) = funcTableEntry {
        gasLimit = tableEntry.maxGas;
    } else {
        let (ustr, maxGas) = rlp_decodeUint(stream)?;
        stream = ustr;
        gasLimit = maxGas;
    }

    let (ustr, toAddr) = decompressAddress(stream)?;
    stream = ustr;

    let value = 0;
    let calldata = bytearray_new(0);
    if let Some(tableEntry) = funcTableEntry {
        if (tableEntry.payable) {
            let (ustr, val) = decompressTokenAmount(stream)?;
            stream = ustr;
            value = val;
        }
        calldata = bytestream_getRemainingBytes(stream);
        calldata = bytearray_copy(
            calldata,
            0,
            unsafecast<ByteArray>(tableEntry.callDataPrefix),
            4,
            bytearray_size(calldata),
        );
    } else {
        let (ustr, val) = decompressTokenAmount(stream)?;
        stream = ustr;
        value = val;
        calldata = bytestream_getRemainingBytes(stream);
    }

    return Some((
        stream,
        struct {
            maxGas: gasLimit,
            gasPrice: gasPrice,
            seqNum: Some(seqNum),
            caller: sender,
            calleeAddr: toAddr,
            value: value,
            calldata: calldata,
            nonMutating: false,
            incomingRequest: unsafecast<IncomingRequest>(0),  // caller will fill this in
        }
    ));
}

type FunctionTableEntry = struct {
    callDataPrefix: any,    // really a ByteArray, but compiler doesn't allow array of imported type
    maxGas: uint,
    payable: bool,
}

type FunctionTable = []FunctionTableEntry

type AggregatorDecompressionState = struct {
    functionTable: FunctionTable,
}

public func parseAggregatorFunctionTable(
    maybeState: option<AggregatorDecompressionState>,
    contents: ByteArray
) -> option<AggregatorDecompressionState> {
    let stream = bytestream_new(contents);
    let (ustr, numEntries) = rlp_decodeUint(stream)?;
    stream = ustr;

    if (numEntries > 1024) {   // hard limit on table size is 1024 entries, currently
        return None;
    }
    let ret = newarray<FunctionTableEntry>(numEntries);
    let i = 0;
    while (i < numEntries) {
        let (ustr, funcCode) = bytestream_getN(stream, 4)?;
        stream = ustr;
        let (ustr, maxGas) = rlp_decodeUint(stream)?;
        stream = ustr;
        let (ustr, payableByte) = bytestream_getByte(stream)?;
        stream = ustr;
        ret = ret with {
            [i] = struct {
                callDataPrefix: funcCode,
                maxGas: maxGas,
                payable: (payableByte != 0)
            }
        };
        i = i+1;
    }

    return Some(struct { functionTable: ret });
}

