//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

import type EvmCallFrame;
import type AccountStore;
import type Account;
import type ByteArray;
import type ByteStream;
import type MarshalledBytes;
import type BLSKey;

import impure func evmCallStack_topFrame() -> option<EvmCallFrame>;
import impure func evmCallStack_setAccount(addr: address, acct: Account) -> bool;
import impure func evmCallStack_getTopFrameMemoryOrDie() -> ByteArray;
import impure func evmCallStack_setTopFrameMemory(mem: ByteArray) -> bool;
import impure func evmCallStack_cloneContract(addr: address) -> option<address>;
import func evmCallStack_callHitError(reason: uint);

import func evmCallFrame_getCalldata(frame: EvmCallFrame) -> ByteArray;
import func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint;
import func evmCallFrame_getAccount(frame: EvmCallFrame, addr: address) -> Account;
import func evmCallFrame_runningAsAddress(frame: EvmCallFrame) -> address;
import func evmCallFrame_runningAsAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_getParent(frame: EvmCallFrame) -> option<EvmCallFrame>;
import func evmCallFrame_getCaller(frame: EvmCallFrame) -> address;

import impure func evmOp_return(memOffset: uint, memNbytes: uint);
import impure func evmOp_revert(memOffset: uint, memNbytes: uint);

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func accountStore_set(acctStore: AccountStore, addr: address, acct: Account) -> AccountStore;
import func account_getAddress(acct: Account) -> address;
import func account_getNextSeqNum(account: Account) -> uint;
import func account_getStorageCell(account: Account, cell: uint) -> option<uint>;
import func account_deductFromEthBalance(acct: Account, amount: uint) -> option<Account>;
import func account_setBlsKey(account: Account, maybeKey: option<BLSKey>) -> Account;
import func account_getBlsKey(account: Account) -> option<BLSKey>;

import func bytearray_new(unused: uint) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> ByteArray;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;

import func bytestream_new(ba: ByteArray) -> ByteStream;

import impure func inbox_currentBlockNumber() -> uint;
import impure func inbox_currentTimestamp() -> uint;

import impure func queueMessageForSend(msgType: uint, sender: address, data: ByteArray);

import type IndexedAddressTable;
import impure func getGlobalAddressTable() -> IndexedAddressTable;
import impure func setGlobalAddressTable(gat: IndexedAddressTable);
import func addressTable_getByAddressAlloc(iat: IndexedAddressTable, addr: address) -> (IndexedAddressTable, uint);
import func addressTable_getByAddress(iat: IndexedAddressTable, addr: address) -> option<uint>;
import func addressTable_getByIndex(iat: IndexedAddressTable, index: uint) -> address;  // returns zero if not in table
import impure func decompressAddress(stream: ByteStream) -> option<(ByteStream, address)>;

import func rlp_encodeUint(val: uint, ba: ByteArray, offset: uint) -> (ByteArray, uint);
import func rlp_encodeAddress(addr: address, ba: ByteArray, offset: uint) -> (ByteArray, uint);

import func bls_makeKey(x0: uint, x1: uint, y0: uint, y1: uint) -> option<BLSKey>;
import func bls_marshalPublicKey(key: BLSKey, ba: ByteArray, offset: uint) -> ByteArray;


public impure func arbsys_txcall() {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let calldata = evmCallFrame_getCalldata(topFrame);
        if (bytearray_size(calldata) < 4) {
            evmOp_revert(0, 0);
        }
        let funcCode = getFuncCode(calldata);
        if (funcCode == 0xa1db9782) {
            arbsys_withdrawErc20(topFrame, calldata);
        } elseif(funcCode == 0xf3e414f8) {
            arbsys_withdrawErc721(topFrame, calldata);
        } elseif(funcCode == 0x25e16063) {
            arbsys_withdrawEth(topFrame, calldata);
        } elseif(funcCode == 0x23ca0cd2) {
            arbsys_getTransactionCount(topFrame, calldata);
        } elseif(funcCode == 0x474ed9c0) {
            arbsys_cloneContract(topFrame, calldata);
        } elseif(funcCode == 0xa169625f) {
            arbsys_getStorageAt(topFrame, calldata);
        } elseif(funcCode == 0x3b199c19) {
            arbsys_addressTable_lookupAddress(topFrame, calldata);
        } elseif(funcCode == 0x4c352200) {
            arbsys_addressTable_lookupIndex(topFrame, calldata);
        } elseif(funcCode == 0x9bebbd33) {
            arbsys_addressTable_decompress(topFrame, calldata);
        } elseif(funcCode == 0x2a890b98) {
            arbsys_addressTable_compress(topFrame, calldata);
        } elseif(funcCode == 0x1ff548ca) {
            arbsys_registerBlsKey(topFrame, calldata);
        } elseif(funcCode == 0x647e0e98) {
            arbsys_getBlsPublicKey(topFrame, calldata);
        } else {
            // unrecognized function code
            evmOp_revert(0, 0);
        }
    } else {
        // this shouldn't happen -- should always be called in an EVM tx
        evmCallStack_callHitError(14);
    }
}

func getFuncCode(ba: ByteArray) -> uint {
    return asm(224, bytearray_get256(ba, 0)) uint { shr };
}

impure func arbsys_withdrawErc20(topFrame: EvmCallFrame, calldata: ByteArray) {
    if (bytearray_size(calldata) != 68) {
        evmOp_revert(0, 0);
    }
    let senderAcct = evmCallFrame_runningAsAccount(topFrame);
    let senderAddr = account_getAddress(senderAcct);
    let destAddr = address(bytearray_get256(calldata, 4));
    let amount = bytearray_get256(calldata, 36);

    let messageData = bytearray_extract(calldata, 4, 64);
    queueMessageForSend(1, senderAddr, messageData);
    evmOp_return(0, 0);
}

impure func arbsys_withdrawErc721(topFrame: EvmCallFrame, calldata: ByteArray) {
    if (bytearray_size(calldata) != 68) {
        evmOp_revert(0, 0);
    }
    let senderAcct = evmCallFrame_runningAsAccount(topFrame);
    let senderAddr = account_getAddress(senderAcct);
    let destAddr = address(bytearray_get256(calldata, 4));
    let id = bytearray_get256(calldata, 36);

    let messageData = bytearray_extract(calldata, 4, 64);
    queueMessageForSend(2, senderAddr, messageData);
    evmOp_return(0, 0);
}

impure func arbsys_withdrawEth(topFrame: EvmCallFrame, calldata: ByteArray) {
    if (bytearray_size(calldata) != 36) {
        evmOp_revert(0, 0);
    }
    let senderAddr = evmCallFrame_getCaller(topFrame);
    let senderAcct = evmCallFrame_getAccount(topFrame, senderAddr);
    let destAddr = address(bytearray_get256(calldata, 4));
    let amount = evmCallFrame_getCallvalue(topFrame);

    let arbSysAddr = evmCallFrame_runningAsAddress(topFrame);
    let arbSysAccount = evmCallFrame_getAccount(topFrame, arbSysAddr);
    if let Some(updatedAcct) = account_deductFromEthBalance(arbSysAccount, amount) {
        if ( ! evmCallStack_setAccount(arbSysAddr, updatedAcct)) {
            evmOp_revert(0, 0);
        }
        let messageData = bytearray_extract(calldata, 4, 32);
        messageData = bytearray_set256(messageData, 32, amount);
        queueMessageForSend(0, senderAddr, messageData);
        evmOp_return(0, 0);
    }

    evmOp_revert(0, 0);
}

impure func arbsys_getTransactionCount(topFrame: EvmCallFrame, calldata: ByteArray) {
    if (bytearray_size(calldata) != 36) {
        evmOp_revert(0, 0);
    }
    let addr = address(bytearray_get256(calldata, 4));
    let seqNum = account_getNextSeqNum(evmCallFrame_getAccount(topFrame, addr));
    let updatedMem = bytearray_set256(
         evmCallStack_getTopFrameMemoryOrDie(),
         0,
         seqNum
     );
    let success = evmCallStack_setTopFrameMemory(updatedMem);
    if (success) {
        evmOp_return(0, 32);
    } else {
        evmOp_revert(0, 0);
    }
}

impure func arbsys_cloneContract(topFrame: EvmCallFrame, calldata: ByteArray) {
    if (bytearray_size(calldata) != 36) {
        evmOp_revert(0, 0);
    }
    let oldContractAddr = address(bytearray_get256(calldata, 4));
    if let Some(newAddr) = evmCallStack_cloneContract(oldContractAddr) {
        let updatedMem = bytearray_set256(
            evmCallStack_getTopFrameMemoryOrDie(),
            0,
            uint(newAddr)
        );
        let success = evmCallStack_setTopFrameMemory(updatedMem);
        if (success) {
            evmOp_return(0, 32);
        } else {
            evmOp_revert(0, 0);
        }
    } else {
        evmOp_revert(0, 0);
    }
}

impure func arbsys_getStorageAt(topFrame: EvmCallFrame, calldata: ByteArray) {
    let senderAddr = evmCallFrame_getCaller(topFrame);
    if (senderAddr != address(0)) {
        evmOp_revert(0, 0);
    }

    let addr = address(bytearray_get256(calldata, 4));
    let offset = bytearray_get256(calldata, 4+32);
    let acct = evmCallFrame_getAccount(topFrame, addr);

    let ret = 0;
    if let Some(val) = account_getStorageCell(acct, offset) {
        ret = val;
    }

    let updatedMem = bytearray_set256(evmCallStack_getTopFrameMemoryOrDie(), 0, ret);
    let success = evmCallStack_setTopFrameMemory(updatedMem);

    if (success) {
        evmOp_return(0, 32);
    } else {
        evmOp_revert(0, 0);
    }
}

impure func arbsys_addressTable_lookupAddress(topFrame: EvmCallFrame, calldata: ByteArray) {  //(address, bool) -> uint
// if bool is true, and address not already in table, this allocates space in the table
// if bool is false, and address not already in table, this just returns MAXUINT
    if (bytearray_size(calldata) != 68) {
        evmOp_revert(0, 0);
    }
    let addr = address(bytearray_get256(calldata, 4));
    let flag = (bytearray_get256(calldata, 4+32) != 0);
    let addrTable = getGlobalAddressTable();
    let index = 0;
    if (flag) {
        let (atab, idx) = addressTable_getByAddressAlloc(addrTable, addr);
        setGlobalAddressTable(atab);
        index = idx;
    } else {
        if let Some(idx) = addressTable_getByAddress(addrTable, addr) {
            index = idx;
        } else {
            index = ~0;
        }
    }

    let success = evmCallStack_setTopFrameMemory(bytearray_set256(evmCallStack_getTopFrameMemoryOrDie(), 0, index));
    if (success) {
        evmOp_return(0, 32);
    } else {
        evmOp_revert(0, 0);
    }
}

impure func arbsys_addressTable_lookupIndex(topFrame: EvmCallFrame, calldata: ByteArray) {  // (uint) -> address
    if (bytearray_size(calldata) != 36) {
        evmOp_revert(0, 0);
    }
    let index = bytearray_get256(calldata, 4);
    let addrTable = getGlobalAddressTable();
    let addr = addressTable_getByIndex(addrTable, index);

    let success = evmCallStack_setTopFrameMemory(bytearray_set256(evmCallStack_getTopFrameMemoryOrDie(), 0, uint(addr)));
    if (success) {
        evmOp_return(0, 32);
    } else {
        evmOp_revert(0, 0);
    }
}

impure func arbsys_addressTable_decompress(topFrame: EvmCallFrame, calldata: ByteArray) {  // (bytes) -> (address, bool)
    if (bytearray_size(calldata) < 68) {
        evmOp_revert(0, 0);
    }
    let bytesLen = bytearray_get256(calldata, 36);
    if let Some(res) = decompressAddress(bytestream_new(bytearray_extract(calldata, 68, bytesLen))) {
        let (_, addr) = res;
        let success = evmCallStack_setTopFrameMemory(bytearray_set256(evmCallStack_getTopFrameMemoryOrDie(), 0, uint(addr)));
        if (success) {
            evmOp_return(0, 32);
        } else {
            evmOp_revert(0, 0);
        }
    } else {
        // input was too short
        evmOp_revert(0, 0);
    }
}

impure func arbsys_addressTable_compress(topFrame: EvmCallFrame, calldata: ByteArray) { // (address) -> bytes
    if (bytearray_size(calldata) != 36) {
        evmOp_revert(0, 0);
    }
    let addr = address(bytearray_get256(calldata, 4));
    let compressedData = bytearray_new(0);
    let compressedDataLen = 0;
    if let Some(index) = addressTable_getByAddress(getGlobalAddressTable(), addr) {
        let (ba, sz) = rlp_encodeUint(index, compressedData, 0);
        compressedData = ba;
        compressedDataLen = sz;
    } else {
        let (ba, sz) = rlp_encodeAddress(addr, compressedData, 0);
        compressedData = ba;
        compressedDataLen = sz;
    }
    let mem = bytearray_set256(
        bytearray_set256(
            bytearray_set256(
                evmCallStack_getTopFrameMemoryOrDie(),
                0,
                64
            ),
            32,
            compressedDataLen
        ),
        64,
        bytearray_get256(compressedData, 0)
    );

    if (evmCallStack_setTopFrameMemory(mem)) {
        evmOp_return(0, 96);
    } else {
        evmOp_revert(0, 0);
    }
}

impure func arbsys_registerBlsKey(topFrame: EvmCallFrame, calldata: ByteArray) {
    if (bytearray_size(calldata) != 4+32*4) {
        evmOp_revert(0, 0);
    }

    let x0 = bytearray_get256(calldata, 4);
    let x1 = bytearray_get256(calldata, 4+32);
    let y0 = bytearray_get256(calldata, 4+32*2);
    let y1 = bytearray_get256(calldata, 4+32*3);
    let maybeBlsKey = bls_makeKey(x0, x1, y0, y1);

    let caller = evmCallFrame_getCaller(topFrame);
    let acct = evmCallFrame_getAccount(topFrame, caller);
    if (evmCallStack_setAccount(caller, account_setBlsKey(acct, maybeBlsKey))) {
        evmOp_return(0, 0);
    } else {
        evmOp_revert(0, 0);
    }
}

impure func arbsys_getBlsPublicKey(topFrame: EvmCallFrame, calldata: ByteArray) { // (address) -> (uint, uint, uint, uint)
    if (bytearray_size(calldata) != 36) {
        evmOp_revert(0, 0);
    }
    let addr = address(bytearray_get256(calldata, 4));
    let maybeBlsKey = account_getBlsKey(evmCallFrame_getAccount(topFrame, addr));

    let mem = evmCallStack_getTopFrameMemoryOrDie();
    if let Some(blsKey) = maybeBlsKey {
        mem = bls_marshalPublicKey(blsKey, mem, 0);
    } else {
        mem = bytearray_set256(
            bytearray_set256(
                bytearray_set256(
                    bytearray_set256(mem, 0, ~0),
                    32,
                    ~0
                ),
                2*32,
                ~0
            ),
            3*32,
            ~0
        );
    }

    if (evmCallStack_setTopFrameMemory(mem)) {
        evmOp_return(0, 4*32);
    } else {
        evmOp_revert(0, 0);
    }
}