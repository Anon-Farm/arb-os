//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//


use accounts::AccountStore;
use accounts::accountStore_init;
use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::accountStore_createAccountFromEvmCode;
use accounts::accountStore_upgradeContractFromEvmCode;
use accounts::account_checkAndIncrSeqNum;
use accounts::account_setStorageCell;

use arbstatistics::arbStatistics_init;

use arbsys::arbosVersion;
use arbsys::arbsys_txcall;

use blockhash::blockhash_init;

use chainParameters::chainParams_init;
use chainParameters::chainParams_haveDoneInit;

use codeSegment::codeSegment_init;
use codeSegment::translateEvmCodeSegment;

use contractTemplates::getArbInfoCode;
use contractTemplates::getArbInfoAddress;
use contractTemplates::getArbInfoStorage;

use decompression::decompression_init;

use errorHandler::errorHandler_init;

use evmCallStack::evmCallStack_init;
use evmCallStack::evmCallStack_makeEmpty;

use evmOps::evmOps_init;
use evmOps::evmOp_return;
use evmOps::dispatchForEvmOp;

use evmlogs::EvmLogs;

use tracing::evmTracer_clear;

use gasAccounting::GasUsage;
use gasAccounting::gasAccounting_init;
use gasAccounting::getNextRequestFromCongestionAuction;
use gasAccounting::txFeeStats_zero;

use inbox::IncomingRequest;
use inbox::inbox_init;
use inbox::inbox_get;
use inbox::emitGenesisBlockReceipt;

use messages::TxRequestData;
use messages::handleL2Request;

use output::output_init;
use output::txReceipts_init;
use output::emitTxReceipt;

use pluggables::pluggables_init;

use precompiles::precompiles_init;

use rollupTracker::rollupTracker_init;

use std::bytearray::MarshalledBytes;
use std::bytearray::ByteArray;
use std::bytearray::bytearray_new;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytestream::ByteStream;
use std::bytestream::bytestream_new;
use std::storageMap::StorageMap;

use bridge_arbos_versions::GlobalsBeforeUpgrade;
use bridge_arbos_versions::remapGlobalsForUpgrade;

// The compiler will always put __fixedLocationGlobal in slot 0 of the AVM Register,
//     so we can rely on it not moving across upgrades.
var __fixedLocationGlobal: impure func(uint);    // points to EVM op dispatch function

impure func main(oldGlobals: GlobalsBeforeUpgrade) {
    if (unsafecast<any>(oldGlobals) != ()) {
        // this is an upgrade; we're inheriting the state of a previous ArbOS instance

        let (newGlobals, _oldArbosVersion) = remapGlobalsForUpgrade(oldGlobals);

        asm(newGlobals,) { rset };

        // now re-do the initializations that set up pointers into the ArbOS code
        errorHandler_init();
        evmOps_init();
        __fixedLocationGlobal = dispatchForEvmOp;
        codeSegment_init();

        if (initializePreinstalls(true) == None<()>) {
            panic;   // don't try to run without preinstalls and precompiles
        }

        // special-case fix for the WETH9 TransparentUpgradableProxy contract
        if (arbosVersion() == 33) {
            let addr = address(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
            let location = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
            let value = 0xd570ace65c43af47101fc6250fd6fc63d1c22a86;
            let acctStore = getGlobalAccountStore();
            let acct = accountStore_get(acctStore, addr);
            if let Some(updatedAcct) = account_setStorageCell(acct, location, value) {
                setGlobalAccountStore(accountStore_set(acctStore, addr, updatedAcct));
            } else {
                asm(40000,) { debugprint };
            }
        }
    } else {
        // this is a clean start, not an upgrade
        errorHandler_init();
        arbStatistics_init();

        pluggables_init();
        codeSegment_init();
        chainParams_init();
        output_init();
        decompression_init();
        inbox_init();
        gasAccounting_init();
        evmCallStack_init();
        evmOps_init();
        __fixedLocationGlobal = dispatchForEvmOp;
        blockhash_init();
        inbox_init();
        accountStore_init();
        txReceipts_init();
        rollupTracker_init();
        if (initializePreinstalls(false) == None<()>) {
            panic;   // don't try to run without preinstalls and precompiles
        }

        // advance the Arbitrum block number, and emit a block receipt
        emitGenesisBlockReceipt();
    }

    // initialize any customizations here

    mainRunLoop();
}

public impure func mainRunLoop() {
    loop {
        let (resultCode, request) = getNextRequestFromCongestionAuction();
        if (resultCode == const::TxResultCode_success) {
            if (handleL2Request(request) == None<()>) {
                // reject for message format error
                emitTxReceipt(
                    request.incomingRequest,
                    const::TxResultCode_formatError,
                    None<ByteArray>,
                    None<EvmLogs>,
                    None<GasUsage>,
                    request.feeStats,
                    false,      // don't emit tracing info because the tx was bogus
                );
            }
        } else {
            // before emitting a failure receipt, try to increment caller's sequence number
            if ( (resultCode != const::TxResultCode_sequenceNumberTooLow) && (resultCode != const::TxResultCode_sequenceNumberTooHigh) ) {
                if let Some(seqNum) = request.seqNum {
                    let gAcctStore = getGlobalAccountStore();
                    if let Some(acct) = account_checkAndIncrSeqNum(accountStore_get(gAcctStore, request.caller), seqNum) {
                        setGlobalAccountStore(accountStore_set(gAcctStore, request.caller, acct));
                    }
                }
            }

            emitTxReceipt(
                request.incomingRequest,
                resultCode,
                None<ByteArray>,
                None<EvmLogs>,
                None<GasUsage>,
                request.feeStats,
                true,
            );
        }
    }
}

impure func initializePreinstalls(isUpgrade: bool) -> option<()> {
    let acctStore = getGlobalAccountStore();

    let code = bytearray_unmarshalBytes(getArbInfoCode())?;
    let (initCodePt, evmJumpTable, _) = translateEvmCodeSegment(
        bytestream_new(code),
        false
    );
    acctStore = xif (isUpgrade) {
        accountStore_upgradeContractFromEvmCode(
            acctStore,
            getArbInfoAddress(),
            code,
            evmJumpTable,
            initCodePt,
        )
    } else {
        accountStore_createAccountFromEvmCode(
            acctStore,
            getArbInfoAddress(),
            code,
            evmJumpTable,
            initCodePt,
            getArbInfoStorage()
        )?
    };

    // set up precompiled contracts
    acctStore = precompiles_init(acctStore, isUpgrade)?;

    setGlobalAccountStore(acctStore);

    return Some(());
}
