//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::stack::Stack;
use std::bytearray::ByteArray;
use std::bytestream::ByteStream;

use evmCallStack::evmCallStack_callHitError;

use std::bytestream::bytestream_new;
use std::bytestream::bytestream_atEof;
use std::bytestream::bytestream_bytesReadSoFar;
use std::bytestream::bytestream_bytesRemaining;
use std::bytestream::bytestream_truncate;
use std::bytestream::bytestream_getByte;
use std::bytestream::bytestream_get64;
use std::bytestream::bytestream_skipBytes;
use std::stack::stack_new;
use std::stack::stack_push;

use std::rlp::rlp_decodeUint;

use chainParameters::chainParams_chainId;

use evmOps::evmOps_indexForFunction;
use evmOps::evmOps_trampoline;

use evmOps::evmOp_address;
use evmOps::evmOp_balance;
use evmOps::evmOp_selfbalance;
use evmOps::evmOp_call;
use evmOps::evmOp_callcode;
use evmOps::evmOp_calldatacopy;
use evmOps::evmOp_calldataload;
use evmOps::evmOp_calldatasize;
use evmOps::evmOp_caller;
use evmOps::evmOp_callvalue;
use evmOps::evmOp_codecopy;
use evmOps::evmOp_codesize;
use evmOps::evmOp_delegatecall;
use evmOps::evmOp_extcodesize;
use evmOps::evmOp_extcodecopy;
use evmOps::evmOp_extcodehash;
use evmOps::evmOp_getjumpaddr;
use evmOps::evmOp_log0;
use evmOps::evmOp_log1;
use evmOps::evmOp_log2;
use evmOps::evmOp_log3;
use evmOps::evmOp_log4;
use evmOps::evmOp_msize;
use evmOps::evmOp_mload;
use evmOps::evmOp_mstore;
use evmOps::evmOp_mstore8;
use evmOps::evmOp_number;
use evmOps::evmOp_origin;
use evmOps::evmOp_return;
use evmOps::evmOp_returndatasize;
use evmOps::evmOp_returndatacopy;
use evmOps::evmOp_revert_knownPc;
use evmOps::evmOp_selfdestruct;
use evmOps::evmOp_sha3;
use evmOps::evmOp_sload;
use evmOps::evmOp_sstore;
use evmOps::evmOp_staticcall;
use evmOps::evmOp_stop;
use evmOps::evmOp_timestamp;
use evmOps::evmOp_create;
use evmOps::evmOp_create2;


// An AVM CodePoint, that is, a place that AVM code can jump to, is represented as a func()
type AvmCodePoint = impure func()

func opWrapperVoid(f: impure func()) -> func() {
    return unsafecast<func()>(f);
}

func opWrapperRetAddress(f: impure func() -> address) -> func() {
    return unsafecast<func()>(f);
}

func opWrapperRetUint(f: impure func() -> uint) -> func() {
    return unsafecast<func()>(f);
}

func opWrapperUint(f: impure func(uint)) -> func() {
    return unsafecast<func()>(f);
}

func opWrapperUintRetBytes(f: impure func(uint) -> bytes32) -> func() {
    return unsafecast<func()>(f);
}

func opWrapperUintRetFunc(f: impure func(uint) -> func()) -> func() {
    return unsafecast<func()>(f);
}

func opWrapperUintRetUint(f: impure func(uint) -> uint) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper2Uint(f: impure func(uint, uint)) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper2UintRetBytes(f: impure func(uint, uint) -> bytes32) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper3Uint(f: impure func(uint, uint, uint)) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper3UintRetAddress(f: impure func(uint, uint, uint) -> address) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper4Uint(f: impure func(uint, uint, uint, uint)) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper4UintRetAddress(f: impure func(uint, uint, uint, uint) -> address) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper5Uint(f: impure func(uint, uint, uint, uint, uint)) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper6Uint(f: impure func(uint, uint, uint, uint, uint, uint)) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper6UintRetBool(f: impure func(uint, uint, uint, uint, uint, uint) -> bool) -> func() {
    return unsafecast<func()>(f);
}

func opWrapper7UintRetBool(f: impure func(uint, uint, uint, uint, uint, uint, uint) -> bool) -> func() {
    return unsafecast<func()>(f);
}

impure func pushInstruction(opcode: uint, restOfCode: AvmCodePoint) -> AvmCodePoint {
    // Push an instruction onto the beginning of a code segment, and return the resulting CodePoint.
    return asm(opcode, restOfCode) AvmCodePoint { pushinsn };
}

impure func pushInstructionImm(opcode: uint, val: any, restOfCode: AvmCodePoint) -> AvmCodePoint {
    // Push an instruction (with immediate value) onto the beginning of a code segment, and return the resulting CodePoint.
    return asm(opcode, val, restOfCode) AvmCodePoint { pushinsnimm };
}

impure func pushValue(val: any, restOfCode: AvmCodePoint) -> AvmCodePoint {
    // Push a noop (with immediate value) onto the beginning of a code segment, and return the resulting CodePoint.
    return asm(0x3b, val, restOfCode) AvmCodePoint { pushinsnimm };
}

public impure func pcTableForCode(code: ByteArray) -> option<Stack> {
    let (code, _, pcTable) = translateEvmCodeSegment(bytestream_new(code), true)?;
    return Some(stack_push(pcTable, (0, code)));
}

public impure func translateEvmCodeSegment(
    bs: ByteStream,
    makePcTable: bool,
) -> option<(AvmCodePoint, map<uint, AvmCodePoint>, Stack)> {
    // Given the EVM bytecode for a contract, generate the equivalent AVM code.
    // If this succeeds, it will return a triple:
    //       * CodePoint to jump to, to start executing the contract
    //       * mapping from valid EVM jump destinations to corresponding AVM CodePoints
    //       * if makePcTable is true, a Stack of (EVM PC, hash(AVM codepoint)) pairs; otherwise an empty stack
    // This operates recursively, building the compiled code from the end back toward the beginning.

    if (bytestream_atEof(bs)) {
        // Base case of the recursion.
        // Return a minimal code segment that just contains a panic instruction.
        // The panic prevents execution from "falling off the end" of the resulting segment.
        return Some((
            asm() AvmCodePoint { errcodept }, 
            newmap<uint, AvmCodePoint>,
            stack_new(),
        ));
    }

    // Read in the first opcode in the code.
    let (ubs, opcode) = bytestream_getByte(bs)?;
    bs = ubs;

    if ((opcode >= 0x60) && (opcode <= 0x7f)) {
        // it's a pushN instruction; unmarshal the immediate value and push it
        let bytesRemaining = opcode - 0x5f;
        let imm = 0;
        while (bytesRemaining > 0) {
            if let Some(res) = bytestream_getByte(bs) {
                let (ubs, val) = res;
                bs = ubs;
                imm = 256*imm + val;
            }
            bytesRemaining = bytesRemaining-1;
        }
        let numBytesRead = bytestream_bytesReadSoFar(bs);

        // Recursively generate code for everything after this instruction.
        let (restOfCode, evmJumpTable, pcTable) = translateEvmCodeSegment(bs, makePcTable)?;
        if (makePcTable) {
            pcTable = stack_push(pcTable, (numBytesRead, hash(restOfCode)));
        }

            // for debugging, uncomment this to get a debugprint before each EVM instruction
            // restOfCode = pushInstructionImm(0x90, (42, numBytesRead, opcode), restOfCode);

        // Now prepend the current operation onto the front of the generated code.
        return Some((pushValue(imm, restOfCode), evmJumpTable, pcTable));
    } 

    // The rest of the instructions are all a single byte. So we'll generate code for the rest of
    // the program, then prepend whatever is needed to implement the current opcode.
    let (restOfCode, evmJumpTable, pcTable) = translateEvmCodeSegment(bs, makePcTable)?;

    let numBytesRead = bytestream_bytesReadSoFar(bs);

    if (makePcTable) {
        pcTable = stack_push(pcTable, (numBytesRead, hash(restOfCode)));
    }

        // for debugging, uncomment this to get a debugprint before each EVM instruction
        // restOfCode = pushInstructionImm(0x90, (42, numBytesRead, opcode), restOfCode);

    if (opcode < 0x80) {
        if (opcode < 0x40) {
            if (opcode < 0x20) {
                if (opcode < 0x10) {
                    if (opcode < 0x04) {
                        if (opcode == 0x00) { // STOP
                            return pushEvmInsnCall(opWrapperVoid(evmOp_stop), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x01) { // ADD
                            return Some((pushInstruction(0x01, restOfCode), evmJumpTable, pcTable));
                        } elseif (opcode == 0x02) { // MUL
                            return Some((pushInstruction(0x02, restOfCode), evmJumpTable, pcTable));
                        } elseif (opcode == 0x03) { // SUB
                            return Some((pushInstruction(0x03, restOfCode), evmJumpTable, pcTable));
                        }
                    } else {
                        if ( (opcode >= 0x04) && (opcode <= 0x07) ) { // DIV, MOD, SDIV, SMOD
                            return pushEvmInsnDenomCheck(opcode, 2, restOfCode, evmJumpTable, pcTable);
                        } elseif ( (opcode >= 0x08) && (opcode <= 0x09) ) { // ADDMOD, MULMOD
                            return pushEvmInsnDenomCheck(opcode, 3, restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x0a) { // EXP
                            return Some((pushInstruction(0x0a, restOfCode), evmJumpTable, pcTable));
                        } elseif (opcode == 0x0b) { // SIGNEXTEND
                            return Some((pushInstruction(0x0b, restOfCode), evmJumpTable, pcTable));
                        }
                    }
                } else {
                    if ( (opcode >= 0x10) && (opcode <= 0x1a) ) {
                        return Some((pushInstruction(opcode, restOfCode), evmJumpTable, pcTable));
                    } elseif (opcode == 0x1b) { // SHL
                        return Some((
                            pushInstructionImm(
                                0x0a, 2,   // [2] exp
                                pushInstruction(
                                    0x02, // mul
                                    restOfCode
                                )
                            ),
                            evmJumpTable,
                            pcTable,
                        ));
                    } elseif (opcode == 0x1c) { // SHR
                        return Some((
                            pushInstructionImm(
                                0x0a, 2,   // [2] exp
                                pushInstruction(
                                    0x43, // swap1
                                    pushInstruction(
                                        0x04, // div
                                        restOfCode
                                    )
                                )
                            ),
                            evmJumpTable,
                            pcTable,
                        ));
                    } elseif (opcode == 0x1d) { // SHA
                        return Some((
                            pushInstructionImm(
                                0x0a, 2,   // [2] exp
                                pushInstruction(
                                    0x43, // swap1
                                    pushInstruction(
                                        0x05, // sdiv
                                        restOfCode
                                    )
                                )
                            ),
                            evmJumpTable,
                            pcTable,
                        ));
                    }
                }
            } else {
                if (opcode < 0x37 ) {
                    if (opcode < 0x33) {
                        if (opcode == 0x20) { // SHA3
                            return pushEvmInsnCall(opWrapper2UintRetBytes(evmOp_sha3), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x30) { // ADDRESS
                            return pushEvmInsnCall(opWrapperRetAddress(evmOp_address), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x31) { // BALANCE
                            return pushEvmInsnCall(opWrapperUintRetUint(evmOp_balance), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x32) { // ORIGIN
                            return pushEvmInsnCall(opWrapperRetAddress(evmOp_origin), restOfCode, evmJumpTable, pcTable);
                        }
                    } else {
                        if (opcode == 0x33) { // CALLER
                            return pushEvmInsnCall(opWrapperRetAddress(evmOp_caller), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x34) { // CALLVALUE
                            return pushEvmInsnCall(opWrapperRetUint(evmOp_callvalue), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x35) { // CALLDATALOAD
                            return pushEvmInsnCall(opWrapperUintRetUint(evmOp_calldataload), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x36) { // CALLDATASIZE
                            return pushEvmInsnCall(opWrapperRetUint(evmOp_calldatasize), restOfCode, evmJumpTable, pcTable);
                        }
                    }
                } else {
                    if (opcode < 0x3b) {
                        if (opcode == 0x37) { // CALLDATACOPY
                            return pushEvmInsnCall(opWrapper3Uint(evmOp_calldatacopy), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x38) { // CODESIZE
                            return pushEvmInsnCall(opWrapperRetUint(evmOp_codesize), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x39) { // CODECOPY
                            return pushEvmInsnCall(opWrapper3Uint(evmOp_codecopy), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x3a) { // GASPRICE
                            return Some((pushValue(1, restOfCode), evmJumpTable, pcTable));
                        }
                    } else {
                        if (opcode == 0x3b) { // EXTCODESIZE
                            return pushEvmInsnCall(opWrapperUintRetUint(evmOp_extcodesize), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x3c) { // EXTCODECOPY
                            return pushEvmInsnCall(opWrapper4Uint(evmOp_extcodecopy), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x3d) { // RETURNDATASIZE
                            return pushEvmInsnCall(opWrapperRetUint(evmOp_returndatasize), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x3e) { // RETURNDATACOPY
                            return pushEvmInsnCall(opWrapper3Uint(evmOp_returndatacopy), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x3f) { // EXTCODEHASH
                            return pushEvmInsnCall(opWrapperUintRetBytes(evmOp_extcodehash), restOfCode, evmJumpTable, pcTable);
                        }
                    }
                }
            }
        } else {
            if (opcode < 0x53) {
                if (opcode < 0x45) {
                    if (opcode < 0x43) {
                        if (opcode == 0x40) { // BLOCKHASH
                            return Some((
                                pushInstruction(
                                    0x30,  // pop
                                    pushValue(0, restOfCode),
                                ),
                                evmJumpTable,
                                pcTable,
                            ));
                        } elseif (opcode == 0x41) { // COINBASE
                            return Some((pushValue(0, restOfCode), evmJumpTable, pcTable));
                        } elseif (opcode == 0x42) { // TIMESTAMP
                            return pushEvmInsnCall(opWrapperRetUint(evmOp_timestamp), restOfCode, evmJumpTable, pcTable);
                        }
                    } else {
                        if (opcode == 0x43) { // NUMBER
                            return pushEvmInsnCall(opWrapperRetUint(evmOp_number), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x44) { // DIFFICULTY
                             return Some((pushValue(2500000000000000, restOfCode), evmJumpTable, pcTable));
                        }
                    }
                } else {
                    if (opcode == 0x45) { // GASLIMIT
                        return Some((pushValue(10000000000, restOfCode), evmJumpTable, pcTable));
                    } elseif (opcode == 0x46) { // CHAINID
                        return pushEvmInsnCall(opWrapperRetUint(chainParams_chainId), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0x47) { // SELFBALANCE
                        return pushEvmInsnCall(opWrapperRetUint(evmOp_selfbalance), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0x50) { // POP
                        return Some((pushInstruction(0x30, restOfCode), evmJumpTable, pcTable)); // pop
                    } elseif (opcode == 0x51) { // MLOAD
                        return pushEvmInsnCall(opWrapperUintRetUint(evmOp_mload), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0x52) { // MSTORE
                        return pushEvmInsnCall(opWrapper2Uint(evmOp_mstore), restOfCode, evmJumpTable, pcTable);
                    }
                }
            } else {
                if (opcode < 0x58) {
                    if (opcode < 0x56) {
                        if (opcode == 0x53) { // MSTORE8
                            return pushEvmInsnCall(opWrapper2Uint(evmOp_mstore8), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x54) { // SLOAD
                            return pushEvmInsnCall(opWrapperUintRetUint(evmOp_sload), restOfCode, evmJumpTable, pcTable);
                        } elseif (opcode == 0x55) { // SSTORE
                            return pushEvmInsnCall(opWrapper2Uint(evmOp_sstore), restOfCode, evmJumpTable, pcTable);
                        }
                    } else {
                        if (opcode == 0x56) { // JUMP
                            return pushEvmInsnCall(
                                opWrapperUintRetFunc(evmOp_getjumpaddr),
                                pushInstruction(0x34, restOfCode), // jump
                                evmJumpTable,
                                pcTable
                            );
                        } elseif (opcode == 0x57) { // JUMPI
                            if let Some(res) = pushEvmInsnCall(
                                opWrapperUintRetFunc(evmOp_getjumpaddr),
                                pushInstruction(0x34, restOfCode), // jump
                                evmJumpTable,
                                pcTable,
                            ) {
                                let (doJump, jumpTable, pcTab) = res;
                                return Some((
                                    pushInstruction(
                                        0x43,  // swap1
                                        pushInstructionImm(
                                            0x35, // cjump
                                            doJump,
                                            pushInstruction(
                                                0x30, // pop
                                                pushInstructionImm(
                                                    0x34,  // jump
                                                    restOfCode,
                                                    doJump,
                                                )
                                            )
                                        )
                                    ),
                                    jumpTable,
                                    pcTab,
                                ));
                            } else {
                                // should never happen; pushEvmInsnCall always returns Some
                                evmCallStack_callHitError(16);
                                return None;
                            }
                        }
                    }
                } else {
                    if (opcode == 0x58) {  // GETPC
                        // we know the current PC, so we can push it directly as a constant
                        return Some((pushValue(bytestream_bytesReadSoFar(bs)-1, restOfCode), evmJumpTable, pcTable));
                    } elseif (opcode == 0x59) { // MSIZE
                        return pushEvmInsnCall(opWrapperRetUint(evmOp_msize), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0x5a) { // GAS
                        return Some((pushInstruction(0x76, restOfCode), evmJumpTable, pcTable));
                    } elseif (opcode == 0x5b) { // JUMPDEST
                        return Some((
                            restOfCode,
                            evmJumpTable with {
                                [numBytesRead-1] = restOfCode
                            },
                            pcTable
                        ));
                    }
                }
            }
        }
    } else {
        if (opcode < 0xe1) {
            if (opcode < 0xa0) {
                if (opcode < 0x90) {
                    if (opcode == 0x80) {  // DUP1 -- note that DUPn in EVM corresponds to DUP(n-1) in AvmCodePoint
                        return Some((pushInstruction(0x40, restOfCode), evmJumpTable, pcTable));  // dup0
                    } elseif (opcode == 0x81) {  // DUP2
                        return Some((pushInstruction(0x41, restOfCode), evmJumpTable, pcTable));  // dup1
                    } elseif (opcode == 0x82) {  // DUP3
                        return Some((pushInstruction(0x42, restOfCode), evmJumpTable, pcTable));  // DUP2
                    } elseif ( (opcode >= 0x83) && (opcode <= 0x8f) ) {
                        return Some((pushDupn(opcode-0x80, restOfCode), evmJumpTable, pcTable));
                    }
                } else {
                    if (opcode == 0x90) {  // SWAP1
                        return Some((pushInstruction(0x43, restOfCode), evmJumpTable, pcTable));  // swap1
                    } elseif (opcode == 0x91) {  // SWAP2
                        return Some((pushInstruction(0x44, restOfCode), evmJumpTable, pcTable));  // swap2
                    } elseif ( (opcode >= 0x92) && (opcode <= 0x9f) ) {
                        return Some((pushSwapn(opcode-0x8f, restOfCode), evmJumpTable, pcTable));
                    }
                }
            } else {
                if (opcode < 0xa3) {
                    if (opcode == 0xa0) { // LOG0
                        return pushEvmInsnCall(opWrapper2Uint(evmOp_log0), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0xa1) { // LOG1
                        return pushEvmInsnCall(opWrapper3Uint(evmOp_log1), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0xa2) { // LOG2
                        return pushEvmInsnCall(opWrapper4Uint(evmOp_log2), restOfCode, evmJumpTable, pcTable);
                    }
                } else {
                    if (opcode == 0xa3) { // LOG3
                        return pushEvmInsnCall(opWrapper5Uint(evmOp_log3), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0xa4) { // LOG0
                        return pushEvmInsnCall(opWrapper6Uint(evmOp_log4), restOfCode, evmJumpTable, pcTable);
                    }
                }
            }
        } else {
            if (opcode < 0xf4) {
                if (opcode == 0xf0) {  // CREATE
                    return pushEvmInsnCall(opWrapper3UintRetAddress(evmOp_create), restOfCode, evmJumpTable, pcTable);
                } elseif (opcode == 0xf1) { // CALL
                    return pushEvmInsnCall(opWrapper7UintRetBool(evmOp_call), restOfCode, evmJumpTable, pcTable);
                } elseif (opcode == 0xf2) { // CALLCODE
                    return pushEvmInsnCall(opWrapper7UintRetBool(evmOp_callcode), restOfCode, evmJumpTable, pcTable);
                } elseif (opcode == 0xf3) { // RETURN
                    return pushEvmInsnCall(opWrapper2Uint(evmOp_return), restOfCode, evmJumpTable, pcTable);
                }
            } else {
                if (opcode < 0xfc) {
                    if (opcode == 0xf4) { // DELEGATECALL
                        return pushEvmInsnCall(opWrapper6UintRetBool(evmOp_delegatecall), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0xf5) {  // CREATE2
                        return pushEvmInsnCall(opWrapper4UintRetAddress(evmOp_create2), restOfCode, evmJumpTable, pcTable);
                    } elseif (opcode == 0xfa) { // STATICCALL
                        return pushEvmInsnCall(opWrapper6UintRetBool(evmOp_staticcall), restOfCode, evmJumpTable, pcTable);
                    }
                } else {
                    if ( (opcode == 0xfd) || (opcode == 0xfe) ) { // REVERT or INVALID
                        let (doCall, jumpTable, uPcTable) = pushEvmInsnCall(
                            opWrapper3Uint(evmOp_revert_knownPc),
                            restOfCode,
                            evmJumpTable,
                            pcTable,
                        )?;
                        if (opcode == 0xfe) {  // INVALID
                            doCall = pushValue(0, pushValue(0, doCall));  // treat as equivalent to revert(0,0)
                        }
                        return Some((
                            pushValue(
                                numBytesRead-1,
                                doCall
                            ),
                            jumpTable,
                            uPcTable,
                        ));
                    } elseif (opcode == 0xff) { // SELFDESTRUCT
                        return pushEvmInsnCall(opWrapperUint(evmOp_selfdestruct), restOfCode, evmJumpTable, pcTable);
                    }
                }
            }
        }
    }

    // opcode was not found, generate AVM error instruction
    return Some((pushInstruction(0x73, restOfCode), evmJumpTable, pcTable));
}

impure func pushEvmInsnDenomCheck(
    opcode: uint,
    numStackOperands: uint,
    restOfCode: AvmCodePoint,
    evmJumpTable: map<uint, AvmCodePoint>,
    pcTable: Stack,
) -> option<(AvmCodePoint, map<uint, AvmCodePoint>, Stack)> {
    // Deal with the EVM instructions that can "divide by zero" or the equivalent.
    // EVM defines these to return zero if the denominator is zero.
    // So we need to generate a little conditional to handle the special case.
    let doTheOp = pushInstruction(opcode, restOfCode);
    return Some((
        pushDupn(
            numStackOperands-1,  // dup denominator/modulus to top of stack
            pushInstructionImm(
                0x35,  // cjump
                doTheOp,
                prependPops(
                    numStackOperands,
                    pushValue(
                        0,
                        pushInstructionImm(
                            0x34, // jump
                            restOfCode,
                            doTheOp
                        )
                    )
                )
            )
        ),
        evmJumpTable,
        pcTable,
    ));
}

impure func prependPops(numPops: uint, restOfCode: AvmCodePoint) -> AvmCodePoint {
    while (numPops > 0) {
        restOfCode = pushInstruction(0x30, restOfCode);   // pop instruction
        numPops = numPops-1;
    }
    return restOfCode;
}

impure func pushDupn(
    n: uint, 
    restOfCode: AvmCodePoint,
) -> AvmCodePoint {
    // Generate code for a dupN pseudo-operation.
    // AVM supports this only for N <= 2, whereas EVM can ask for larger ones.
    // Note that N here uses the AVM semantics, which is off-by-one from the EVM semantics.
    if (n <= 2) {
        return pushInstruction(0x40+n, restOfCode);  //dup_n
    } else {
        return pushInstruction(
            0x38,  // auxpush,
            pushDupn(
                n-1,
                pushInstruction(
                    0x39,  // auxpop
                    pushInstruction(
                        0x43,  // swap1
                        restOfCode
                    )
                )
            )
        );
    }
}

impure func pushSwapn(
    n: uint, 
    restOfCode: AvmCodePoint,
) -> AvmCodePoint {
    // Generate code for a swapN pseudo-operation.
    // AVM supports this only for N <= 2, whereas EVM can ask for larger ones.
    if (n == 2) {
        return pushInstruction(0x44, restOfCode);  // swap2
    } else {
        return pushInstruction(
            0x43, // swap1
            pushInstruction(
                0x38, // auxpush
                pushSwapn(
                    n-1,
                    pushInstruction(
                        0x39, // auxpop
                        pushInstruction(
                            0x43, // swap1
                            restOfCode
                        )
                    )
                )
            )
        );
    }
}

impure func pushEvmInsnCall(
    evmOp: func(), 
    restOfCode: AvmCodePoint,
    evmJumpTable: map<uint, AvmCodePoint>,
    pcTable: Stack,
) -> option<(AvmCodePoint, map<uint, AvmCodePoint>, Stack)> {
    // Some EVM instructions compile to a procedure call to some Mini code.
    // Generate the appropriate procedure call.
    // Note that the EVM code will already have put the args to the call on the stack,
    //     and the Mini code will leave return values on the stack.
    if let Some(funcIndex) = evmOps_indexForFunction(evmOp) {
        return Some((
            pushValue(
                funcIndex,
                pushValue(
                    restOfCode,   // return address
                    pushInstructionImm(
                        0x34, // jump
                        evmOps_trampoline,
                        restOfCode
                    )
                )
            ),
            evmJumpTable,
            pcTable,
        ));
    } else {
        panic;
    }
}

func isKnownOpcode(opcode: uint) -> bool {  // return true iff opcode is a known EVM opcode
    return ( (opcode >= 0x00) && (opcode <= 0x0b) )
        || ( (opcode >= 0x10) && (opcode <= 0x1d) )
        || (opcode == 0x20)
        || ( (opcode >= 0x30) && (opcode <= 0x45) )
        || ( (opcode >= 0x50) && (opcode <= 0x5b) )
        || ( (opcode >= 0x60) && (opcode <= 0xa4) )
        || ( (opcode >= 0xf0) && (opcode <= 0xf5) )
        || (opcode == 0xfa)
        || ( (opcode == 0xfd) && (opcode <= 0xff) );
}

type AvmCodeBuilder = struct {
    requireSafe: bool,
    code: AvmCodePoint,
    size: uint,
    codeMap: map<uint, AvmCodePoint>,
}

public impure func avmCodeBuilder_new(requireSafe: bool) -> AvmCodeBuilder {
    let code = asm() AvmCodePoint { errcodept };
    return struct {
        requireSafe: requireSafe,
        code: code,
        size: 1,
        codeMap: newmap<uint, AvmCodePoint> with { [0] = code },
    };
}

public impure func avmCodeBuilder_append(builder: AvmCodeBuilder, stream: ByteStream) -> option<AvmCodeBuilder> {
    let requireSafe = builder.requireSafe;
    let code = builder.code;
    let size = builder.size;
    let codeMap = builder.codeMap;

    while( ! bytestream_atEof(stream) ) {
        let (ustr, insn) = bytestream_getByte(stream)?;
        if ( requireSafe && !isSafeInstruction(insn) ) {
            return None;
        }
        stream = ustr;
        let (ustr, hasImm) = bytestream_getByte(stream)?;
        stream = ustr;
        if (hasImm == 0) {
            code = pushInstruction(insn, code);
        } else {
            let (ustr, val) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            code = pushInstructionImm(insn, val, code);
        }
        codeMap = codeMap with { [size] = code };
        size = size+1;
    }

    return Some(struct {
        requireSafe: requireSafe,
        code: code,
        size: size,
        codeMap: codeMap,
    });
}

public func avmCodeBuilder_finish(builder: AvmCodeBuilder) -> AvmCodePoint {
    return builder.code;
}

func isSafeInstruction(insn: uint) -> bool {
    return (insn != 0x34)                      // rset
        && (insn != 0x3d)                      // errset
        && ((insn < 0x60) || (insn > 0x7f));   // various unsafe instructions
}

func unmarshalValue(stream: ByteStream, codeMap: map<uint, AvmCodePoint>) -> option<(ByteStream, any)> {
    let (ustr, kind) = bytestream_getByte(stream)?;
    stream = ustr;
    if (kind == 0) {  // integer
        let (ustr, val) = rlp_decodeUint(stream)?;
        return Some((ustr, val));
    } elseif (kind == 1) { // codepoint
        let (ustr, idx) = rlp_decodeUint(stream)?;
        if let Some(codePt) = codeMap[idx] {
            return Some((ustr, codePt));
        } else {
            return None;
        }
    } elseif (kind == 10) {   // 0-tuple
        return Some((stream, ()));
    } elseif (kind == 11) {   // 1-tuple
        let (ustr, x) = unmarshalValue(stream, codeMap)?;
        return Some((ustr, (x,)));
    } elseif (kind == 12) {   // 2-tuple
        let val = unsafecast<[2]any>((0,0));
        let i = 0;
        while (i < 2) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        return Some((stream, val));
    } elseif (kind == 13) {   // 3-tuple
        let val = unsafecast<[3]any>((0,0,0));
        let i = 0;
        while (i < 3) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        return Some((stream, val));
    } elseif (kind == 14) {   // 4-tuple
        let val = unsafecast<[4]any>((0,0,0,0));
        let i = 0;
        while (i < 4) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        return Some((stream, val));
    } elseif (kind == 15) {   // 5-tuple
        let val = unsafecast<[5]any>((0,0,0,0,0));
        let i = 0;
        while (i < 5) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        return Some((stream, val));
    } elseif (kind == 16) {   // 6-tuple
        let val = unsafecast<[6]any>((0,0,0,0,0,0));
        let i = 0;
        while (i < 6) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        return Some((stream, val));
    } elseif (kind == 17) {   // 7-tuple
        let val = unsafecast<[7]any>((0,0,0,0,0,0,0));
        let i = 0;
        while (i < 7) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        return Some((stream, val));
    } elseif (kind == 18) {   // 8-tuple
        let val = unsafecast<[8]any>((0,0,0,0,0,0,0,0));
        let i = 0;
        while (i < 8) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        return Some((stream, val));
    } else {
        return None;
    }
}
