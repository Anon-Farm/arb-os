//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type ByteStream;
import type MarshalledBytes;

import func bytearray_new(capacityHint: uint) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_set256(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func marshalledBytes_hash(mb: MarshalledBytes) -> bytes32;
import func bytearray_copy(
    from: ByteArray,
    fromOffset: uint,
    to: ByteArray,
    toOffset: uint,
    nbytes: uint,
) -> ByteArray;

import func bytestream_new(ba: ByteArray) -> ByteStream;
import func bytestream_skipBytes(ba: ByteStream, nbytes: uint) -> option<ByteStream>;

import func rlp_encodeAndHashMessageInfo(tx: SignedTx) -> bytes32;
import func rlp_decodeMessageInfo(inStream: ByteStream) -> option<(ByteStream, SignedTx)>;

import impure func chainParams_chainId() -> uint;

import func keccak256(ba: ByteArray, offset: uint, nbytes: uint) -> bytes32;


type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    inboxSeqNum: uint,        // sequence number in L1 inbox, or tx id
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

type SignedTx = struct {
    seqNum: uint,
    gasPrice: uint,
    gasLimit: uint,
    to: address,
    value: uint,
    data: ByteArray,
    v: uint,
    r: uint,
    s: uint
}

public impure func translateSignedTx(req: IncomingRequest) -> option<IncomingRequest> {
    // Given an IncomingRequest that contains an L2 signed tx message, translate the
    //    L2 message from the RLP-encoded form it arrived in, into the old format which downstream code expects.
    // Also, check the signature on the tx, and set:
    //      - the sender field in the request equal to signer, and
    //      - the requestID field in the request equal to the Ethereum-compatible tx id,
    // Return the result, or None if message is malformed or the signature is invalid.

    let rlpData = bytearray_unmarshalBytes(req.msgData);
    rlpData = bytearray_extract(rlpData, 1, bytearray_size(rlpData)-1);
    let (_, signedTx) = rlp_decodeMessageInfo(bytestream_new(rlpData))?;

    let extractedL2data = signedTxToBytes(signedTx);
    let l2MsgSize = bytearray_size(extractedL2data);

    let preSigSize = l2MsgSize-65;
    let signer = recoverSigner(signedTx)?;

    // turn it into an unsigned message
    let newL2message = bytearray_setByte(
        bytearray_extract(extractedL2data, 0, preSigSize),
        0,
        0
    );

    let rlpHash = keccak256(rlpData, 0, bytearray_size(rlpData));

    return Some(
        req with {
            sender: signer
        } with {
            inboxSeqNum: uint(rlpHash)
        } with {
            msgData: bytearray_marshalFull(newL2message)
        }
    );
}

impure func recoverSigner(tx: SignedTx) -> option<address> {
    let rlpHashForSig = rlp_encodeAndHashMessageInfo(
        tx with {
            r: 0
        } with {
            s: 0
        } with {
            v: chainParams_chainId()
        }
    );

    let signer = asm(
        tx.r,
        tx.s,
        1 - (tx.v % 2),
        rlpHashForSig,
    ) address { ecrecover };

    if (signer == address(0)) {
        return None;
    } else {
        return Some(signer);
    }
}

func rlpAndHash(msgData: ByteArray, preSigSize: uint, v: uint, r: uint, s: uint) -> bytes32 {
    let maxGas = bytearray_get256(msgData, 1);
    let gasPriceBid = bytearray_get256(msgData, 32+1);
    let sequenceNum = bytearray_get256(msgData, 2*32+1);
    let destAddress = address(bytearray_get256(msgData, 3*32+1));
    let payment = bytearray_get256(msgData, 4*32+1);
    return rlp_encodeAndHashMessageInfo(
        struct {
            seqNum: sequenceNum,
            gasPrice: gasPriceBid,
            gasLimit: maxGas,
            to: destAddress,
            value: payment,
            data: bytearray_extract(msgData, 5*32+1, preSigSize-(5*32+1)),
            v: v,
            r: r,
            s: s
        }
    );
}

func signedTxToBytes(tx: SignedTx) -> ByteArray {
    let dataSize = bytearray_size(tx.data);
    let ret = bytearray_new(0);
    ret = bytearray_setByte(ret, 0, 4);  // L2 subtype for signed tx
    ret = bytearray_set256(ret, 1, tx.gasLimit);
    ret = bytearray_set256(ret, 1+32, tx.gasPrice);
    ret = bytearray_set256(ret, 1+2*32, tx.seqNum);
    ret = bytearray_set256(ret, 1+3*32, uint(tx.to));
    ret = bytearray_set256(ret, 1+4*32, tx.value);
    ret = bytearray_copy(tx.data, 0, ret, 1+5*32, dataSize);
    ret = bytearray_set256(ret, 1+5*32+dataSize, tx.r);
    ret = bytearray_set256(ret, 1+6*32+dataSize, tx.s);
    ret = bytearray_setByte(ret, 1+7*32+dataSize, 1-(tx.v % 2));
    return ret;
}

public func hashUnsignedL2messageInfo(l2msg: MarshalledBytes, chainId: uint, sender: address) -> bytes32 {
    return hash(
        bytes32(sender),
        hash(
            bytes32(chainId),
            marshalledBytes_hash(l2msg),
        )
    );
}
