//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::account_addToEthBalance;

use evmlogs::EvmLogs;

use gasAccounting::GasUsage;
use gasAccounting::txFeeStats_zero;
use gasAccounting::chargeForRetryableTx;
use gasAccounting::getRetryableTxPrice;

use inbox::IncomingRequest;
use inbox::inbox_currentTimestamp;

use messages::TxRequestData;

use output::emitTxReceipt;

use std::bytearray::ByteArray;
use std::bytearray::bytearray_new;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_get256;
use std::bytearray::bytearray_set256;
use std::bytearray::bytearray_extract;

use std::keccak::keccak256;

use std::queue::Queue;
use std::queue::queue_new;
use std::queue::queue_put;
use std::queue::queue_get;


type RetryableTx = struct {
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    calldata: ByteArray,
    retryCount: uint,
    expiryTime: uint,
}

type RetryQueueItem = struct {
    txId: uint,
    retryCount: uint,
    expiryTime: uint,
}

public func retryableTx_hash(rtx: RetryableTx) -> bytes32 {  // note: hash does not include retryCount field
    return hash(
        bytes32(rtx.txId),
        hash(
            bytes32(rtx.sender),
            hash(
                bytes32(rtx.destination),
                hash(
                    bytes32(rtx.callvalue),
                    keccak256(rtx.calldata, 0, bytearray_size(rtx.calldata)),
                )
            )
        )
    );
}

public func retryItem_rebuildVerifyHash(
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    calldata: ByteArray,
    claimedHash: bytes32,
) -> option<RetryableTx> {
    let claimedRtx = struct {
        txId: txId,
        sender: sender,
        destination: destination,
        callvalue: callvalue,
        calldata: calldata,
        retryCount: 0,     // OK to put any value here because it does not affect the hash.
        expiryTime: 0,     // OK to put any value here because it does not affect the hash.
    };
    return xif (claimedHash == retryableTx_hash(claimedRtx)) {
        Some(claimedRtx)
    } else {
        None<RetryableTx>
    };
}

var retryBuffer: struct {
    byTxId: map<uint, RetryableTx>,
    fifo: Queue,     // not in strict expirationTime order, but this doesn't affect correctness
    txLifetimeSeconds: uint
};

public impure func retryBuffer_init() {
    retryBuffer = struct {
        byTxId: newmap<uint, RetryableTx>,
        fifo: queue_new(),
        txLifetimeSeconds: const::RetryBuffer_DefaultLifetimeSeconds,
    };
}

public impure func retryBuffer_getLifetime() -> uint {
    return retryBuffer.txLifetimeSeconds;
}

public impure func retryBuffer_setLifetime(lifetimeSeconds: uint) {
    retryBuffer = retryBuffer with {
        txLifetimeSeconds: lifetimeSeconds
    };
    // no need to discard newly aged-out txs, they'll get cleaned up later
}

impure func retryBuffer_trimTwo(currentTimestamp: uint) {
    // remove up to 2 aged-out items from the retryBuffer
    if (retryBuffer_trimOne(currentTimestamp)) {
        let _ = retryBuffer_trimOne(currentTimestamp);
    }
}

impure func retryBuffer_trimOne(currentTimestamp: uint) -> bool {  // returns true iff a tx was trimmed
    return xif let Some(res) = queue_get(retryBuffer.fifo) {
        let (uq, rawQitem) = res;
        let qitem = unsafecast<RetryQueueItem>(rawQitem);
        xif let Some(rawItem) = retryBuffer.byTxId[qitem.txId] {
            xif (qitem.expiryTime <= currentTimestamp) {
                let item = unsafecast<RetryableTx>(rawItem);
                xif (qitem.retryCount >= item.retryCount) {
                    retryBuffer_delete(qitem.txId);
                    retryBuffer = retryBuffer with {
                       fifo: uq
                    };
                    true
                } else {
                    false
                }
            } else {
                false
            }
        } else {
            false
        }
    } else {
        false
    };
}

public impure func retryBuffer_insert(rtx: RetryableTx) {
    let now = inbox_currentTimestamp();
    retryBuffer_trimTwo(now);
    let txId = rtx.txId;
    retryBuffer = retryBuffer with {
        byTxId: retryBuffer.byTxId with {
            [txId] = rtx with {
                retryCount: rtx.retryCount + 1
            }
        }
    } with {
        fifo: queue_put(retryBuffer.fifo, struct { txId: txId, retryCount: rtx.retryCount, expiryTime: rtx.expiryTime })
    };
}

public impure func retryBuffer_insertNew(
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    calldata: ByteArray
) -> bytes32 {
    let newTx = struct {
        txId: txId,
        sender: sender,
        destination: destination,
        callvalue: callvalue,
        calldata: calldata,
        retryCount: 0,
        expiryTime: inbox_currentTimestamp() + retryBuffer.txLifetimeSeconds,
    };
    retryBuffer_insert(newTx);

    return retryableTx_hash(newTx);
}

public impure func retryBuffer_get(txId: uint, removeIfFound: bool) -> option<RetryableTx> {
    let ret = retryBuffer.byTxId[txId];
    if (removeIfFound) {
        if let Some(tx) = ret {
            retryBuffer_delete(txId);
        }
    }
    return ret;
}

public impure func retryBuffer_getTxTimeout(txId: uint) -> uint {
    return xif let Some(rtx) = retryBuffer_get(txId, false) {
        rtx.expiryTime
    } else {
        0
    };
}

public impure func retryBuffer_getLifetime() -> uint {
    return retryBuffer.txLifetimeSeconds;
}

public impure func retryBuffer_getTxKeepalivePrice(txId: uint) -> option<(uint, uint)>{
    let rtx = retryBuffer_get(txId, false)?;
    return Some(getRetryableTxPrice(bytearray_size(rtx.calldata)));
}

public impure func retryBuffer_keepalive(txId: uint) -> option<()> {
    let rtx = retryBuffer_get(txId, false)?;
    retryBuffer_insert(rtx with { expiryTime: rtx.expiryTime + retryBuffer.txLifetimeSeconds });
    return Some(());
}

public impure func retryBuffer_delete(txId: uint) {
    retryBuffer = retryBuffer with {
        byTxId: retryBuffer.byTxId with { [txId] = unsafecast<RetryableTx>(0) }    // deletes item from the map
    };
    // tx might still be in retryBuffer.fifo, but that isn't a problem because it's not gettable and re-deletion is safe
}

public impure func processRetryableTx(req: IncomingRequest) {
    let sender = req.sender;
    let destination = address(bytearray_get256(req.msgData, 0));
    let callvalue = bytearray_get256(req.msgData, 32);
    let deposit = bytearray_get256(req.msgData, 2*32);
    let calldataSize = bytearray_get256(req.msgData, 3*32);
    let calldata = bytearray_extract(req.msgData, 4*32, calldataSize);

    // deposited funds go into the caller's account
    if (deposit > 0) {
        let globalStore = getGlobalAccountStore();
        setGlobalAccountStore(
            accountStore_set(
                globalStore,
                sender,
                account_addToEthBalance(accountStore_get(globalStore, sender), deposit)
            )
        );
    }

    // charge for injecting this message
    let (paid, feeStats) = chargeForRetryableTx(sender, calldataSize, req.gasPriceL1);

    if (paid) {
        // remember the retryable tx
        let txHash = retryBuffer_insertNew(req.requestId, sender, destination, callvalue, calldata);

        emitTxReceipt(
            req,
            const::TxResultCode_success,
            Some(bytearray_set256(bytearray_set256(bytearray_new(0), 0, req.requestId), 32, uint(txHash))),
            None<EvmLogs>,
            None<GasUsage>,
            feeStats,
        );
    } else {
        emitTxReceipt(
            req,
            const::TxResultCode_noGasFunds,
            None<ByteArray>,
            None<EvmLogs>,
            None<GasUsage>,
            feeStats,
        );
    }
}

public impure func redeemRetryableTxInTx(txToRedeem: uint) {
    //TODO: implement this
    panic;
}

