//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::accountStore_getRetryBuffer;
use accounts::accountStore_setRetryBuffer;
use accounts::account_addToEthBalance;
use accounts::account_deductFromEthBalance;

use evmCallStack::evmCallStack_getAccountInCurrentContext;
use evmCallStack::evmCallStack_setAccountInCurrentContext;
use evmCallStack::getRetryBufferInCurrentContext;
use evmCallStack::setRetryBufferInCurrentContext;
use evmCallStack::evmCallStack_callRetryableTxAndReturn;

use evmlogs::EvmLogs;

use gasAccounting::GasUsage;
use gasAccounting::txFeeStats_zero;
use gasAccounting::getFeesForRetryableTx;
use gasAccounting::getRetryableTxPrice;
use gasAccounting::txFeeStats_zero;

use inbox::IncomingRequest;
use inbox::inbox_currentTimestamp;

use messages::TxRequestData;

use output::emitTxReceipt;

use std::bytearray::ByteArray;
use std::bytearray::bytearray_new;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_get256;
use std::bytearray::bytearray_set256;
use std::bytearray::bytearray_extract;

use std::keccak::keccak256;

use std::queue::Queue;
use std::queue::queue_new;
use std::queue::queue_put;
use std::queue::queue_get;

use core::kvs::Kvs;
use core::kvs::builtin_kvsDelete;


// Each RetryableTx is identified by a txId, which is a unique identifier for the transaction it will eventually
//     become.  This is not the same as the requestId of the L1 request that submitted this RetryableTx.  They're
//     different because ArbOS will need to emit a tx receipt for the L1 request and separately for the RetryableTx.
//     The txId used here is hash(submitterRequestId, 0), which is the same formula that would be used if the
//     submission was a batch of one item containing the RetryableTx.

type RetryableTx = struct {
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    beneficiary: address,
    calldata: ByteArray,
    l1Message: IncomingRequest,
}

type RetryQueueItem = struct {
    txId: uint,         // id of item to check
    checkTime: uint,    // when to check for expiration of the item
}

// RetryBuffer holds retryable transactions.
type RetryBuffer = struct {
    newMap: map<uint, RetryableTx>,
    oldMap: map<uint, RetryableTx>,
    nextTrimTime: uint,
    txLifetimeSeconds: uint,
}

public func retryBuffer_new() -> RetryBuffer {
    return struct {
        newMap: newmap<uint, RetryableTx>,
        oldMap: newmap<uint, RetryableTx>,
        nextTrimTime: 0,    // we'll trim the first time this is used, but that's harmless
        txLifetimeSeconds: const::RetryBuffer_DefaultLifetimeSeconds,
    };
}

public func retryBuffer_getLifetime(rbuf: RetryBuffer) -> uint {
    return rbuf.txLifetimeSeconds;
}

impure func retryBuffer_trimIfNeeded(rbuf: RetryBuffer) -> RetryBuffer {
    let currentTimestamp = inbox_currentTimestamp();
    return xif (currentTimestamp >= rbuf.nextTrimTime) {
        rbuf = rbuf with {
            newMap: newmap<uint, RetryableTx>
        } with {
            oldMap: rbuf.newMap
        } with {
            nextTrimTime: rbuf.nextTrimTime + rbuf.txLifetimeSeconds
        };
        xif (currentTimestamp >= rbuf.nextTrimTime) {
            rbuf with {
                oldMap: newmap<uint, RetryableTx>
            } with {
                nextTrimTime: currentTimestamp + rbuf.txLifetimeSeconds
            }
        } else {
            rbuf
        }
    } else {
        rbuf
    };
}

public impure func retryBuffer_insert(rbuf: RetryBuffer, rtx: RetryableTx) -> RetryBuffer {
    rbuf = retryBuffer_trimIfNeeded(rbuf);
    let txId = rtx.txId;
    return rbuf with {
        newMap: rbuf.newMap with { [txId] = rtx }
    };
}

impure func retryBuffer_insertNew(
    rbuf: RetryBuffer,
    txId: uint,
    sender: address,
    destination: address,
    callvalue: uint,
    beneficiary: address,
    calldata: ByteArray,
    l1Message: IncomingRequest,
) -> (RetryBuffer, uint) {
    let newTx = struct {
        txId: uint(hash(bytes32(txId), bytes32(0))),
        sender: sender,
        destination: destination,
        callvalue: callvalue,
        beneficiary: beneficiary,
        calldata: calldata,
        l1Message: l1Message with { requestId: uint(hash(bytes32(l1Message.requestId), bytes32(0))) },
    };

    return (retryBuffer_insert(rbuf, newTx), newTx.txId);
}

public func retryBuffer_get(rbuf: RetryBuffer, txId: uint) -> option<RetryableTx> {
    return xif let Some(rtx) = rbuf.newMap[txId] {
        Some(rtx)
    } else {
        rbuf.oldMap[txId]
    };
}

public func retryBuffer_getTxTimeout(rbuf: RetryBuffer, txId: uint) -> uint {
    return xif (rbuf.newMap[txId] != None<RetryableTx>) {
        rbuf.nextTrimTime + rbuf.txLifetimeSeconds
    } elseif (rbuf.oldMap[txId] != None<RetryableTx>) {
        rbuf.nextTrimTime
    } else {
        0
    };
}

public func retryBuffer_getBeneficiary(rbuf: RetryBuffer, txId: uint) -> option<address> {
    return Some( (retryBuffer_get(rbuf, txId)?).beneficiary );
}

public func retryBuffer_getLifetime(rbuf: RetryBuffer) -> uint {
    return rbuf.txLifetimeSeconds;
}

public impure func retryBuffer_getTxKeepalivePrice(rbuf: RetryBuffer, txId: uint) -> option<(uint, uint)>{
    let rtx = retryBuffer_get(rbuf, txId)?;
    return Some(getRetryableTxPrice(bytearray_size(rtx.calldata)));
}

public impure func retryBuffer_keepalive(rbuf: RetryBuffer, txId: uint) -> option<(RetryBuffer, uint)> {
    rbuf = retryBuffer_trimIfNeeded(rbuf);
    return xif let Some(_) = rbuf.newMap[txId] {
        None<(RetryBuffer, uint)>
    } else {
        let rtx = retryBuffer_get(rbuf, txId)?;
        rbuf = retryBuffer_insert(rbuf, rtx);
        Some((rbuf, retryBuffer_getTxTimeout(rbuf, txId)))
    };
}

public impure func retryBuffer_delete(rbuf: RetryBuffer, txId: uint, withRefund: bool) -> option<RetryBuffer> {
    // don't call retryBuffer_trimTwo here, because this is called by retryBuffer_trimOne, and we don't want to recurse

    return xif let Some(rtx) = retryBuffer_get(rbuf, txId) {
        // delete the tx
        rbuf = rbuf with {
            newMap: unsafecast<map<uint, RetryableTx>>(
                builtin_kvsDelete(unsafecast<Kvs>(rbuf.newMap), txId)
            )
        } with {
            oldMap: unsafecast<map<uint, RetryableTx>>(
                builtin_kvsDelete(unsafecast<Kvs>(rbuf.oldMap), txId)
            )
        };

        if (withRefund) {
            // credit the callvalue back to the beneficiary
            evmCallStack_setAccountInCurrentContext(
                rtx.beneficiary,
                account_addToEthBalance(
                    evmCallStack_getAccountInCurrentContext(rtx.beneficiary),
                    rtx.callvalue,
                )
            );
        }

        Some(rbuf)
    } else {
        None<RetryBuffer>
    };
}

public impure func processRetryableTx(req: IncomingRequest) {
    // This must be called outside of a transaction.

    let sender = req.sender;
    let destination = address(bytearray_get256(req.msgData, 0));
    let callvalue = bytearray_get256(req.msgData, 32);
    let deposit = bytearray_get256(req.msgData, 2*32);
    let maxSubmissionCost = bytearray_get256(req.msgData, 3*32);
    let creditBack = address(bytearray_get256(req.msgData, 4*32));
    let beneficiary = address(bytearray_get256(req.msgData, 5*32));
    let calldataSize = bytearray_get256(req.msgData, 6*32);
    let calldata = bytearray_extract(req.msgData, 7*32, calldataSize);

    if (creditBack == address(0)) { creditBack = sender; }

    let acctStore = getGlobalAccountStore();

    // deposited funds go into the sender's account
    if (deposit > 0) {
        acctStore = accountStore_set(
            acctStore,
            sender,
            account_addToEthBalance(accountStore_get(acctStore, sender), deposit)
        );
    }

    // charge for injecting this message
    let (submissionFee, subFeeRecipient, feeStats) = getFeesForRetryableTx(sender, calldataSize);

    if (submissionFee <= maxSubmissionCost) {
        let totalDue = callvalue + maxSubmissionCost;

        if let Some(senderAcct) = account_deductFromEthBalance(accountStore_get(acctStore, sender), totalDue) {
            // We took maxSubmissionCost + callvalue from the sender.
            // We will distribute those funds as follows:
            //       submissionFee to the subFeeRecipient
            //       maxSubmissionCost-submissionFee to the creditBack address
            //       callvalue to the retryableTx we will create

            acctStore = accountStore_set(acctStore, sender, senderAcct);
            if (submissionFee > 0) {
                acctStore = accountStore_set(
                    acctStore,
                    subFeeRecipient,
                    account_addToEthBalance(accountStore_get(acctStore, subFeeRecipient), submissionFee)
                );
            }

            if (submissionFee < maxSubmissionCost) {
                acctStore = accountStore_set(
                    acctStore,
                    creditBack,
                    account_addToEthBalance(
                        accountStore_get(acctStore, creditBack),
                        maxSubmissionCost - submissionFee
                    )
                );
            }

            // Create a new retryable tx, holding the callvalue
            let (rbuf, txId) = retryBuffer_insertNew(
                accountStore_getRetryBuffer(acctStore),
                req.requestId,
                sender,
                destination,
                callvalue,
                beneficiary,
                calldata,
                req
            );
            acctStore = accountStore_setRetryBuffer(acctStore, rbuf);

            emitTxReceipt(
                req,
                const::TxResultCode_success,
                Some(bytearray_set256(bytearray_new(0), 0, txId)),
                None<EvmLogs>,
                None<GasUsage>,
                feeStats,
            );
        } else {
            emitTxReceipt(
                req,
                const::TxResultCode_insufficientBalance,
                None<ByteArray>,
                None<EvmLogs>,
                None<GasUsage>,
                feeStats,
            );
        }
    } else {
        // submission cost was higher than the maximum allowed by the request
        emitTxReceipt(
            req,
            const::TxResultCode_noGasFunds,
            None<ByteArray>,
            None<EvmLogs>,
            None<GasUsage>,
            feeStats,
        );
    }
    setGlobalAccountStore(acctStore);
}

public impure func redeemRetryableTxInTx(txToRedeem: uint) -> bool {
    let rbuf = retryBuffer_trimIfNeeded(getRetryBufferInCurrentContext());
    return xif let Some(rtx) = retryBuffer_get(rbuf, txToRedeem) {
        xif let Some(rb) = retryBuffer_delete(rbuf, txToRedeem, false) {
            // we just deleted the tx, without a credit-back to the beneficiary
            // note that this delete will be discarded if the tx reverts
            setRetryBufferInCurrentContext(rb);
            evmCallStack_callRetryableTxAndReturn(rtx)
        } else {
            setRetryBufferInCurrentContext(rbuf);
            false
        }
    } else {
        setRetryBufferInCurrentContext(rbuf);
        false
    };
}
