//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

use evmCallStack::EvmCallFrame;
use evmCallStack::evmCallStack_topFrame;
use evmCallStack::evmCallStack_stackDepth;
use evmCallStack::evmCallStack_setTopFrameMemory;
use evmCallStack::evmCallStack_transferEthFromCurrent;
use evmCallStack::evmCallFrame_getCalldata;
use evmCallStack::evmCallFrame_getCaller;
use evmCallStack::evmCallFrame_getCallvalue;
use evmCallStack::evmCallFrame_getMemory;
use evmCallStack::evmCallStack_callHitError;
use evmCallStack::evmCallStack_getAccountInCurrentContext;
use evmCallStack::evmCallStack_setAccountInCurrentContext;
use evmCallStack::getRetryBufferInCurrentContext;
use evmCallStack::setRetryBufferInCurrentContext;

use evmOps::evmOp_log2;
use evmOps::evmOp_return;
use evmOps::evmOp_revert_knownPc;

use std::bytearray::ByteArray;
use std::bytearray::bytearray_new;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_get256;
use std::bytearray::bytearray_set256;

use gasAccounting::getRetryableTxPrice;

use retrybuffer::retryBuffer_getLifetime;
use retrybuffer::retryBuffer_getTxTimeout;
use retrybuffer::redeemRetryableTxInTx;
use retrybuffer::retryBuffer_getTxKeepalivePrice;
use retrybuffer::retryBuffer_keepalive;
use retrybuffer::retryBuffer_getBeneficiary;
use retrybuffer::retryBuffer_delete;


public impure func ArbRetryableTx_redeem(topFrame: EvmCallFrame, txId: uint) -> ByteArray {
    // This can only be called directly from L1. Revert if called from L2.
    if (evmCallStack_stackDepth() != 1) {
        evmOp_revert_knownPc(11, 0, 0);
    }

    let (success, returnData) = redeemRetryableTxInTx(txId);
    if (success) {
        arbRetryable_emitRedeemed(topFrame, txId);
        return returnData;
    } else {
        if (evmCallStack_setTopFrameMemory(returnData)) {
            evmOp_revert_knownPc(13, 0, bytearray_size(returnData));
        } else {
            evmOp_revert_knownPc(14, 0, 0);
        }
    }
}

public impure func ArbRetryableTx_getTimeout(_topFrame: EvmCallFrame, txId: uint) -> uint {
    return retryBuffer_getTxTimeout(
        getRetryBufferInCurrentContext(),
        txId
    );
}

public impure func ArbRetryableTx_getLifetime(_topFrame: EvmCallFrame, calldata: ByteArray) -> uint {
    return retryBuffer_getLifetime(getRetryBufferInCurrentContext());
}

public impure func ArbRetryableTx_getKeepalivePrice(_topFrame: EvmCallFrame, txId: uint) -> (uint, uint) {
    if let Some(res) = retryBuffer_getTxKeepalivePrice(getRetryBufferInCurrentContext(), txId) {
        return res;
    } else {
        evmOp_revert_knownPc(42, 0, 0);
    }
}

public impure func ArbRetryableTx_keepalive(topFrame: EvmCallFrame, txId: uint) -> uint {
    let caller = evmCallFrame_getCaller(topFrame);
    let callvalue = evmCallFrame_getCallvalue(topFrame);
    if (callvalue > 0) {
        if (evmCallStack_transferEthFromCurrent(caller, callvalue) == None<()>) {
            evmOp_revert_knownPc(51, 0, 0);
        }
    }

    if let Some(res) = retryBuffer_keepalive(getRetryBufferInCurrentContext(), txId) {
        let (rbuf, newTimeout) = res;
        setRetryBufferInCurrentContext(rbuf);
        if (arbRetryable_emitLifetimeExtended(topFrame, txId, newTimeout) == None<()>) {
            evmOp_revert_knownPc(52, 0, 0);
        }
        return newTimeout;
    } else {
        evmOp_revert_knownPc(54, 0, 0);
    }
}

public impure func ArbRetryableTx_getBeneficiary(_topFrame: EvmCallFrame, txId: uint) -> address {
    if let Some(bene) = retryBuffer_getBeneficiary(getRetryBufferInCurrentContext(), txId) {
        return bene;
    } else {
        evmOp_revert_knownPc(62, 0, 0);
    }
}

public impure func ArbRetryableTx_cancel(topFrame: EvmCallFrame, txId: uint) {
    let rbuf = getRetryBufferInCurrentContext();
    if let Some(bene) = retryBuffer_getBeneficiary(rbuf, txId) {
        let caller = evmCallFrame_getCaller(topFrame);
        if ((caller != bene) && (caller != address(0))) {
            evmOp_revert_knownPc(71, 0, 0);
        }

        if let Some(updatedRbuf) = retryBuffer_delete(rbuf, txId, true) {
            setRetryBufferInCurrentContext(updatedRbuf);
            ArbRetryableTx_emitCanceled(topFrame, txId);
        } else {
            evmOp_revert_knownPc(72, 0, 0);
        }
    } else {
        evmOp_revert_knownPc(73, 0, 0);
    }
}

public impure func ArbRetryableTx_getSubmissionPrice(_topFrame: EvmCallFrame, dataSize: uint) -> (uint, uint) {
    return getRetryableTxPrice(dataSize);
}

impure func ArbRetryableTx_emitTicketCreated(_topFrame: EvmCallFrame, txId: uint) {
    evmOp_log2(0, 0, const::eventTopic_ArbRetryableTx_TicketCreated, txId);
}

impure func ArbRetryableTx_emitLifetimeExtended(topFrame: EvmCallFrame, txId: uint, newTimeout: uint) -> option<()> {
    let savedMem = evmCallFrame_getMemory(topFrame);
    let mem = bytearray_set256(bytearray_new(0), 0, newTimeout);
    if ( ! evmCallStack_setTopFrameMemory(mem)) {
       return None<()>;
    }
    evmOp_log2(0, 32, const::eventTopic_ArbRetryableTx_LifetimeExtended, txId);
    return xif(evmCallStack_setTopFrameMemory(savedMem)) {
        Some(())
    } else {
        None<()>
    };
}

impure func ArbRetryableTx_emitRedeemed(_topFrame: EvmCallFrame, txId: uint) {
    evmOp_log2(0, 0, const::eventTopic_ArbRetryableTx_Redeemed, txId);
}

impure func ArbRetryableTx_emitCanceled(_topFrame: EvmCallFrame, txId: uint) {
    evmOp_log2(0, 0, const::eventTopic_ArbRetryableTx_Canceled, txId);
}