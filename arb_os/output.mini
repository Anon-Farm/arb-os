//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::bytearray::ByteArray;
use std::bytearray::MarshalledBytes;
use std::queue::Queue;
use evmlogs::EvmLogs;

use std::bytearray::bytearray_new;
use std::bytearray::bytearray_marshalFull;

use std::merkletree::MerkleTreeBuilder;
use std::merkletree::merkleTreeBuilder_new;
use std::merkletree::merkleTreeBuilder_add;
use std::merkletree::merkleTreeBuilder_rootHash;

use std::outputstream::OutputStream;
use std::outputstream::outputStream_new;
use std::outputstream::outputStream_push256;
use std::outputstream::outputStream_push256;
use std::outputstream::outputStream_pushByteArray;
use std::outputstream::outputStream_pushBuffer;
use std::outputstream::outputStream_size;
use std::outputstream::outputStream_contents;
use std::outputstream::outputStream_writeAsLog;

use std::queue::queue_get;

use evmlogs::evmlogs_empty;
use evmlogs::evmlogs_numLogs;
use evmlogs::pushEvmLogsToOutputStream;

use evmCallStack::evmCallStack_queueMessage;

use chainParameters::chainParams_speedLimitPerBlock;

use inbox::IncomingRequest;
use inbox::inbox_currentBlockNumber;
use inbox::inbox_currentTimestamp;
use inbox::pushIncomingRequestToOutputStream;
use inbox::pushProvenanceToOutputStream;

use gasAccounting::GasUsage;
use gasAccounting::gasSummaryToOutputStream;


// PerBlockReceiptData is different from OutputStatistics for now; might want to unify
type PerBlockReceiptData = struct {
    totalGasUsed: uint,
    numTx: uint,
    numEvmLogs: uint,
}

type OutputStatistics = struct {
    totalGasUsed: uint,
    numTx: uint,
    numEvmLogs: uint,
    numLogs: uint,
    numSends: uint,
}

var merkleOfSends: MerkleTreeBuilder;

public impure func output_init() {
    merkleOfSends = merkleTreeBuilder_new();
}

func pushPerBlockReceiptDataToOutputStream(os: OutputStream, pbrd: PerBlockReceiptData) -> OutputStream {
    os = outputStream_push256(os, pbrd.totalGasUsed);
    os = outputStream_push256(os, pbrd.numTx);
    return outputStream_push256(os, pbrd.numEvmLogs);
}

func outputStats_new() -> OutputStatistics {
    return struct {
        totalGasUsed: 0,
        numTx: 0,
        numEvmLogs: 0,
        numLogs: 0,
        numSends: 0
    };
}

func outputStats_isAllZero(os: OutputStatistics) -> bool {
    return (os.totalGasUsed + os.numTx + os.numEvmLogs + os.numLogs + os.numSends) == 0;
}

func outputStats_add(os1: OutputStatistics, os2: OutputStatistics) -> OutputStatistics {
    return struct {
        totalGasUsed: os1.totalGasUsed + os2.totalGasUsed,
        numTx: os1.numTx + os2.numTx,
        numEvmLogs: os1.numEvmLogs + os2.numEvmLogs,
        numLogs: os1.numLogs + os2.numLogs,
        numSends: os1.numSends + os2.numSends,
    };
}

var globalBlockReceiptData: struct {
    data: PerBlockReceiptData,
    statsThisBlock: OutputStatistics,
    statsAllTime: OutputStatistics,
    lastBlockNum: uint,
};

public impure func outputStats_endOfBlock(blockNum: uint, timestamp: uint) {
    if ( ! outputStats_isAllZero(globalBlockReceiptData.statsThisBlock)) {
        // add current block (including soon-to-be-issued block summary log) into total stats
        let updatedStats = outputStats_add(
            globalBlockReceiptData.statsThisBlock,
            globalBlockReceiptData.statsAllTime
        );
        updatedStats = updatedStats with {
            numLogs: updatedStats.numLogs + 1  // +1 for soon-to-be-issued block summary log
        };

        globalBlockReceiptData = globalBlockReceiptData with {
            statsAllTime: updatedStats
        };
        emitBlockSummaryLog(blockNum, timestamp, globalBlockReceiptData.lastBlockNum);

        globalBlockReceiptData = globalBlockReceiptData with {
            lastBlockNum: blockNum
        };
    }

    // now clear current block stats, because we're advancing to a new current block
    globalBlockReceiptData = globalBlockReceiptData with {
        statsThisBlock: outputStats_new()
    } with {
        data: struct {
            totalGasUsed: 0,
            numTx: 0,
            numEvmLogs: 0
        }
    };
}

impure func outputStats_addTxLog(gasUsed: uint, numEvmLogs: uint) {
    globalBlockReceiptData = globalBlockReceiptData with {
        statsThisBlock: globalBlockReceiptData.statsThisBlock with {
            numTx: 1 + globalBlockReceiptData.statsThisBlock.numTx
        } with {
            numLogs: 1 + globalBlockReceiptData.statsThisBlock.numLogs
        } with {
            totalGasUsed: gasUsed + globalBlockReceiptData.statsThisBlock.totalGasUsed
        } with {
            numEvmLogs: numEvmLogs + globalBlockReceiptData.statsThisBlock.numEvmLogs
        }
    };
}

impure func outputStats_addSend() {
    globalBlockReceiptData = globalBlockReceiptData with {
        statsThisBlock: globalBlockReceiptData.statsThisBlock with {
            numSends: 1 + globalBlockReceiptData.statsThisBlock.numSends
        }
    };
}

public impure func txReceipts_init() {  // will be called at beginning of main()
    globalBlockReceiptData = struct {
        data: struct {
            totalGasUsed: 0,
            numTx: 0,
            numEvmLogs: 0
        },
        statsThisBlock: outputStats_new(),
        statsAllTime: outputStats_new(),
        lastBlockNum: ~0,
    };
}

impure func update_txReceiptsForBlock(
    blockNum: uint,
    gasUsed: uint,
    numEvmLogs: uint
) -> PerBlockReceiptData {
    // first add in the gas, because returned value is supposed to include it
    let ret = globalBlockReceiptData.data with {
        totalGasUsed: gasUsed + globalBlockReceiptData.data.totalGasUsed
    };

    // now update the accumulated data and write it back, but don't return the updated version
    globalBlockReceiptData = globalBlockReceiptData with {
        data: ret with {
            numTx: ret.numTx + 1
        } with {
            numEvmLogs: ret.numEvmLogs + numEvmLogs
        }
    };

    return ret;
}

public impure func emitTxReceipt(
    l1message: IncomingRequest,
    resultCode: uint,
    maybeReturnData: option<ByteArray>,
    maybeEvmLogs: option<EvmLogs>,
    gasUsage: option<GasUsage>,
) {
    let realGasUsage = struct {
        gasUsed: 0,
        gasPriceWei: 0,
    };
    if let Some(gu) = gasUsage {
        realGasUsage = gu;
    }

    let evmLogs = evmlogs_empty();
    let numEvmLogs = 0;
    if let Some(el) = maybeEvmLogs {
        evmLogs = el;
        numEvmLogs = evmlogs_numLogs(el);
    }

    outputStats_addTxLog(realGasUsage.gasUsed, numEvmLogs);

    let returnData = bytearray_new(0);
    if let Some(rd) = maybeReturnData {
        returnData = rd;
    }

    let txResultInfo = struct {
        returnCode: resultCode,
        returnData: bytearray_marshalFull(returnData),
        evmLogs: evmLogs,
    };

    let os = outputStream_new();
    os = outputStream_push256(os, const::LogType_txReceipt);

    os = pushIncomingRequestToOutputStream(os, l1message, false);

    os = outputStream_push256(os, resultCode);
    os = outputStream_pushByteArray(os, returnData, true);
    os = pushEvmLogsToOutputStream(os, evmLogs);

    os = outputStream_push256(os, realGasUsage.gasUsed);
    os = outputStream_push256(os, realGasUsage.gasPriceWei);

    os = pushProvenanceToOutputStream(os, l1message.provenance);

    os = pushPerBlockReceiptDataToOutputStream(
        os,
        update_txReceiptsForBlock(
            l1message.blockNumber,
            realGasUsage.gasUsed,
            numEvmLogs,
        )
    );

    outputStream_writeAsLog(os);
}

impure func emitBlockSummaryLog(blockNum: uint, timestamp: uint, prevBlockNum: uint) {
    let gasUsedThisBlock = globalBlockReceiptData.statsThisBlock.totalGasUsed;
    let gasLimit = chainParams_speedLimitPerBlock();
    if (gasLimit < gasUsedThisBlock) {
        gasLimit = gasUsedThisBlock;
    }

    let os = outputStream_new();
    os = outputStream_push256(os, const::LogType_blockSummary);
    os = outputStream_push256(os, blockNum);
    os = outputStream_push256(os, timestamp);
    os = outputStream_push256(os, gasLimit);
    os = pushStatsToOutputStream(os, globalBlockReceiptData.statsThisBlock);
    os = pushStatsToOutputStream(os, globalBlockReceiptData.statsAllTime);
    os = gasSummaryToOutputStream(os);
    os = outputStream_push256(os, prevBlockNum);
    outputStream_writeAsLog(os);

    asm(
        32,
        setbuffer256(newbuffer(), 0, uint(merkleTreeBuilder_rootHash(merkleOfSends))),
    ) { send };
    merkleOfSends = merkleTreeBuilder_new();
}

func pushStatsToOutputStream(os: OutputStream, stats: OutputStatistics) -> OutputStream {
    os = outputStream_push256(os, stats.totalGasUsed);
    os = outputStream_push256(os, stats.numTx);
    os = outputStream_push256(os, stats.numEvmLogs);
    os = outputStream_push256(os, stats.numLogs);
    return outputStream_push256(os, stats.numSends);
}

public impure func queueMessageForSend(msgType: uint, sender: address, data: ByteArray) {
    let os = outputStream_new();
    os = outputStream_push256(os, msgType);
    os = outputStream_push256(os, uint(sender));
    os = outputStream_pushByteArray(os, data, false);
    evmCallStack_queueMessage(os);
}

public impure func sendQueuedMessages(queue: Queue) {
    loop {
        if let Some(res) = queue_get(queue) {
            let (uq, rawOs) = res;
            queue = uq;
            let os = unsafecast<OutputStream>(rawOs);
            sendPackagedMessage(outputStream_size(os), outputStream_contents(os));
        } else {
            return;
        }
    }
}

public impure func sendMessage(msgType: uint, sender: address, data: ByteArray) {
    let os = outputStream_new();
    os = outputStream_push256(os, msgType);
    os = outputStream_push256(os, uint(sender));
    os = outputStream_pushByteArray(os, data, false);
    sendPackagedMessage(outputStream_size(os), outputStream_contents(os));
}

impure func sendPackagedMessage(size: uint, contents: buffer) {
    outputStats_addSend();
    merkleOfSends = merkleTreeBuilder_add(merkleOfSends, size, contents);
    let os = outputStream_new();
    os = outputStream_push256(os, const::LogType_send);
    os = outputStream_push256(os, size);
    os = outputStream_pushBuffer(os, size, contents);
    outputStream_writeAsLog(os);
}