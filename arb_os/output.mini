//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type MarshalledBytes;
import type EvmLogs;

import func bytearray_new(capacity: uint) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func evmlogs_empty() -> EvmLogs;
import func evmlogs_numLogs(logs: EvmLogs) -> uint;

import impure func inbox_currentBlockNumber() -> uint;


// This is declared identically in messages.mini
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,          // sequence number in L1 inbox
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

// This is declared identically in gasAccounting.mini
type GasUsage = struct {
    gasUsed: uint,
    gasPriceWei: uint,
}

// PerBlockReceiptData is different from OutputStatistics for now; might want to unify
type PerBlockReceiptData = struct {
    totalGasUsed: uint,
    numTx: uint,
    numEvmLogs: uint,
}

type OutputStatistics = struct {
    totalGasUsed: uint,
    numTx: uint,
    numEvmLogs: uint,
    numLogs: uint,
    numSends: uint,
}

func outputStats_new() -> OutputStatistics {
    return struct {
        totalGasUsed: 0,
        numTx: 0,
        numEvmLogs: 0,
        numLogs: 0,
        numSends: 0
    };
}

func outputStats_allZero(os: OutputStatistics) -> bool {
    return (os.totalGasUsed + os.numTx + os.numEvmLogs + os.numLogs + os.numSends) == 0;
}

func outputStats_add(os1: OutputStatistics, os2: OutputStatistics) -> OutputStatistics {
    return struct {
        totalGasUsed: os1.totalGasUsed + os2.totalGasUsed,
        numTx: os1.numTx + os2.numTx,
        numEvmLogs: os1.numEvmLogs + os2.numEvmLogs,
        numLogs: os1.numLogs + os2.numLogs,
        numSends: os1.numSends + os2.numSends,
    };
}

var globalBlockReceiptData: struct {
    blockNum: uint,
    data: PerBlockReceiptData,
    statsThisBlock: OutputStatistics,
    statsAllTime: OutputStatistics,
};

impure func outputStats_updateBlockIfNeeded() {
    let oldBlockNum = globalBlockReceiptData.blockNum;
    let newBlockNum = inbox_currentBlockNumber();
    if (newBlockNum > oldBlockNum) {
        if ( ! outputStats_allZero(globalBlockReceiptData.statsThisBlock)) {
            let updatedStats = outputStats_add(
                globalBlockReceiptData.statsThisBlock,
                globalBlockReceiptData.statsAllTime
            );
            updatedStats = updatedStats with {
                numLogs: updatedStats.numLogs + 1
            };
            globalBlockReceiptData = globalBlockReceiptData with {
                statsAllTime: updatedStats
            } with {
                statsThisBlock: outputStats_new()
            };
        }
        globalBlockReceiptData = globalBlockReceiptData with {
            blockNum: newBlockNum
        };
    }
}

impure func outputStats_addTxLog(gasUsed: uint, numEvmLogs: uint) {
    outputStats_updateBlockIfNeeded();
    globalBlockReceiptData = globalBlockReceiptData with {
        statsThisBlock: globalBlockReceiptData.statsThisBlock with {
            numTx: 1 + globalBlockReceiptData.statsThisBlock.numTx
        } with {
            numLogs: 1 + globalBlockReceiptData.statsThisBlock.numLogs
        } with {
            totalGasUsed: gasUsed + globalBlockReceiptData.statsThisBlock.totalGasUsed
        } with {
            numEvmLogs: numEvmLogs + globalBlockReceiptData.statsThisBlock.numEvmLogs
        }
    };
}

impure func outputStats_addSend() {
    outputStats_updateBlockIfNeeded();
    globalBlockReceiptData = globalBlockReceiptData with {
        statsThisBlock: globalBlockReceiptData.statsThisBlock with {
            numSends: 1 + globalBlockReceiptData.statsThisBlock.numSends
        }
    };
}

public impure func txReceipts_init() {  // will be called at beginning of main()
    init_txReceiptsForBlock(0);
}

impure func init_txReceiptsForBlock(blockNum: uint) {
    globalBlockReceiptData = struct {
        blockNum: blockNum,
        data: struct {
            totalGasUsed: 0,
            numTx: 0,
            numEvmLogs: 0
        },
        statsThisBlock: outputStats_new(),
        statsAllTime: outputStats_new(),
    };
}

impure func update_txReceiptsForBlock(
    blockNum: uint,
    gasUsed: uint,
    numEvmLogs: uint
) -> PerBlockReceiptData {
    // first add in the gas, because returned value is supposed to include it
    let ret = globalBlockReceiptData.data with {
        totalGasUsed: gasUsed + globalBlockReceiptData.data.totalGasUsed
    };

    // now update the accumulated data and write it back
    globalBlockReceiptData = globalBlockReceiptData with {
        data: ret with {
            numTx: ret.numTx + 1
        } with {
            numEvmLogs: ret.numEvmLogs + numEvmLogs
        }
    };

    return ret;
}

public impure func output_updateTime() {
    // this should be called if the block number might have advanced
    // it will push out a block summary log item if that's needed
    outputStats_updateBlockIfNeeded();
}

// result codes:
//    0    return (success)
//    1    tx reverted
//    2    rejected due to congestion
//    3    insufficient funds to pay for gas
//    4    insufficient funds for tx payment
//    5    bad sequence number
//    6    message format error
//    255  unknown error
public impure func emitLog(
    l1message: IncomingRequest,
    resultCode: uint,
    maybeReturnData: option<ByteArray>,
    maybeEvmLogs: option<EvmLogs>,
    gasUsage: option<GasUsage>,
) {
    let realGasUsage = struct {
        gasUsed: 0,
        gasPriceWei: 0,
    };
    if let Some(gu) = gasUsage {
        realGasUsage = gu;
    }
    let evmLogs = evmlogs_empty();
    let numEvmLogs = 0;
    if let Some(el) = maybeEvmLogs {
        evmLogs = el;
        numEvmLogs = evmlogs_numLogs(el);
    }
    outputStats_addTxLog(realGasUsage.gasUsed, numEvmLogs);

    let returnData = bytearray_new(0);
    if let Some(rd) = maybeReturnData {
        returnData = rd;
    }
    let evmLogs = evmlogs_empty();
    if let Some(el) = maybeEvmLogs {
        evmLogs = el;
    }

    let txResultInfo = struct {
        returnCode: resultCode,
        returnData: bytearray_marshalFull(returnData),
        evmLogs: evmLogs,
    };
    asm((
        0,
        l1message,
        txResultInfo,
        realGasUsage,
        update_txReceiptsForBlock(
            l1message.blockNumber,
            realGasUsage.gasUsed,
            numEvmLogs,
        )
    ),) { log };
}

impure func emitBlockSummaryLog() {
    asm((
        1,
        globalBlockReceiptData.blockNum,
        globalBlockReceiptData.statsThisBlock,
        globalBlockReceiptData.statsAllTime
    ),) { log };
}

public impure func sendMessage(msgType: uint, sender: address, data: ByteArray) {
    outputStats_addSend();
    asm(
        (
            msgType,
            uint(sender),
            bytearray_marshalFull(data),
        ),
    ) { send };
}