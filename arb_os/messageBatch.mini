//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::bytearray::MarshalledBytes;
use std::bytearray::ByteArray;
use std::bytestream::ByteStream;

use std::bytearray::bytearray_size;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_get256;
use std::bytearray::bytearray_setByte;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytearray::bytearray_marshalFull;
use std::bytearray::bytearray_extract;
use std::bytestream::bytestream_new;
use std::bytestream::bytestream_get64;
use std::bytestream::bytestream_getN;
use std::bytestream::bytestream_skipBytes;
use std::bytearray::marshalledBytes_firstByte;
use std::bytearray::marshalledBytes_hash;


// This structure defines an incoming request.
// It is declared identically in inbox.mini and elsewhere.
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: MarshalledBytes  // kind-specific data, as a marshalled bytearray
}

type MessageBatch = struct {
    template: IncomingRequest,
    stream: ByteStream,
    numSoFar: uint,
}

public func messageBatch_tryNew(msg: IncomingRequest) -> option<MessageBatch> {
    if ( (msg.kind == 3) && (marshalledBytes_firstByte(msg.msgData) == 3) ) {
        let stream = bytestream_new(bytearray_unmarshalBytes(msg.msgData));
        stream = bytestream_skipBytes(stream, 1)?;
        return Some(
            struct {
                template: msg,
                stream: stream,
                numSoFar: 0,
            }
        );
    } else {
        // it's not a batch
        return None;
    }
}

public func messageBatch_get(batch: MessageBatch) -> option<(IncomingRequest, MessageBatch)> {
    // returns next message in the batch (and updated batch), or None if no more messages in batch
    let (stream, l2MsgLength) = bytestream_get64(batch.stream)?;
    let (bs, extractedL2data) = bytestream_getN(stream, l2MsgLength)?;
    stream = bs;

    return Some((
        batch.template with {
            msgData: bytearray_marshalFull(extractedL2data)
        } with {
            requestId: uint(hash(bytes32(batch.template.requestId), bytes32(batch.numSoFar)))
        },
        batch with {
            stream: stream
        } with {
            numSoFar: batch.numSoFar + 1
        }
    ));
}
