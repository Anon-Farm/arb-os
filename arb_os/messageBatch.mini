//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type MarshalledBytes;
import type ByteArray;
import type ByteStream;

import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import func bytestream_new(ba: ByteArray) -> ByteStream;
import func bytestream_get64(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_getN(bs: ByteStream, nbytes: uint) -> option<(ByteStream, ByteArray)>;
import func bytestream_skipBytes(bs: ByteStream, nbytes: uint) -> option<ByteStream>;
import func marshalledBytes_firstByte(mb: MarshalledBytes) -> uint;
import func marshalledBytes_hash(mb: MarshalledBytes) -> bytes32;

import func rlp_encodeMessageInfo(
    seqNum: uint,
    gasPrice: uint,
    gasLimit: uint,
    to: address,
    value: uint,
    data: ByteArray,
    v: uint,
    r: uint,
    s: uint
) -> ByteArray;

import impure func chainParams_chainId() -> uint;

import impure func keccak256(ba: ByteArray, offset: uint, nbytes: uint) -> bytes32;



// This is the structure that the Arbitrum protocol gives us, for each incoming message.
// It is declared identically in inbox.mini and elsewhere
type MessageFromL1 = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    inboxSeqNum: uint,        // sequence number in L1 inbox
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

type MessageBatch = struct {
    template: MessageFromL1,
    stream: ByteStream,
}

public func messageBatch_tryNew(msg: MessageFromL1) -> option<MessageBatch> {
    if ( (msg.kind == 3) && (marshalledBytes_firstByte(msg.msgData) == 3) ) {
        let stream = bytestream_new(bytearray_unmarshalBytes(msg.msgData));
        stream = bytestream_skipBytes(stream, 1)?;
        return Some(
            struct {
                template: msg,
                stream: stream,
            }
        );
    } else {
        // it's not a batch
        return None;
    }
}

public func messageBatch_get(batch: MessageBatch) -> option<(MessageFromL1, MessageBatch)> {
    // returns next message in the batch (and updated batch), or None if no more messages in batch
    let (stream, l2MsgLength) = bytestream_get64(batch.stream)?;

    let (bs, extractedL2data) = bytestream_getN(stream, l2MsgLength)?;
    stream = bs;

    let l2MsgType = bytearray_getByte(extractedL2data, 0);
    let l2MsgSize = bytearray_size(extractedL2data);
    if (l2MsgType == 4) {
        // it's a signed message, recover sender address from signature
        let preSigSize = l2MsgSize-65;
        let signer = recoverSigner(extractedL2data, preSigSize)?;

        // turn it into an unsigned message
        let newL2message = bytearray_setByte(
            bytearray_extract(extractedL2data, 0, preSigSize),
            0,
            0
        );

        let rlpForId = rlp_encodeMessageInfo(
            bytearray_get256(extractedL2data, 2*32),                   // seqNum: uint,
            bytearray_get256(extractedL2data, 1*32),                   // gasPrice: uint,
            bytearray_get256(extractedL2data, 0),                      // gasLimit: uint,
            address(bytearray_get256(extractedL2data, 3*32)),          // to: address,
            bytearray_get256(extractedL2data, 4*32),                   // value: uint,
            bytearray_extract(extractedL2data, 5*32, preSigSize-5*32), // data: ByteArray,
            bytearray_getByte(extractedL2data, preSigSize+64),         // v: uint,
            bytearray_get256(extractedL2data, preSigSize),             // r: uint,
            bytearray_get256(extractedL2data, preSigSize+32)           // s: uint
        );
        let txId = keccak256(rlpForId, 0, bytearray_size(rlpForId));

        return Some((
            batch.template with {
                sender: signer
            } with {
                inboxSeqNum: uint(txId)
            } with {
                msgData: bytearray_marshalFull(newL2message)
            },
            batch with {
                stream: stream
            }
        ));
    } else {
        // it's an unsigned message, just return it
        return Some((
            batch.template with {
                msgData: bytearray_marshalFull(extractedL2data)
            },
            batch with {
                stream : stream
            }
        ));
    }

    return None;
}

func recoverSigner(msgData: ByteArray, preSigSize: uint) -> option<address> {
    let maxGas = bytearray_get256(msgData, 1);
    let gasPriceBid = bytearray_get256(msgData, 32+1);
    let sequenceNum = bytearray_get256(msgData, 2*32+1);
    let destAddress = address(bytearray_get256(msgData, 3*32+1));
    let payment = bytearray_get256(msgData, 4*32+1);
    let rlpEncoded = rlp_encodeMessageInfo(
        sequenceNum,
        gasPriceBid,
        maxGas,
        destAddress,
        payment,
        bytearray_extract(msgData, 5*32+1, preSigSize-(5*32+1)),
        chainParams_chainId(),
        0,
        0,
    );
    let rlpHash = keccak256(rlpEncoded, 0, bytearray_size(rlpEncoded));

    let signer = asm(
        bytearray_get256(msgData, preSigSize),
        bytearray_get256(msgData, preSigSize+32),
        1-(bytearray_getByte(msgData, preSigSize+64) % 2),
        rlpHash,
    ) address { ecrecover };

    if (signer == address(0)) {
        return None;
    } else {
        return Some(signer);
    }
}