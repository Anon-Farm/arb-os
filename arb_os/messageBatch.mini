//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::bytearray::MarshalledBytes;
use std::bytearray::ByteArray;
use std::bytestream::ByteStream;

use std::bytearray::bytearray_size;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_get256;
use std::bytearray::bytearray_setByte;
use std::bytearray::bytearray_marshalFull;
use std::bytearray::bytearray_extract;
use std::bytestream::bytestream_new;
use std::bytestream::bytestream_get64;
use std::bytestream::bytestream_getN;
use std::bytestream::bytestream_skipBytes;
use std::bytearray::marshalledBytes_firstByte;
use std::bytearray::marshalledBytes_hash;

use inbox::IncomingRequest;

use std::rlp::rlp_decodeUint;


type MessageBatch = struct {
    template: IncomingRequest,
    stream: ByteStream,
    numSoFar: uint,
}

public func messageBatch_tryNew(msg: IncomingRequest) -> option<MessageBatch> {
    if ( (msg.kind == const::L1MessageType_L2) && (bytearray_getByte(msg.msgData, 0) == const::L2MessageType_batch) ) {
        let stream = bytestream_new(msg.msgData);
        stream = bytestream_skipBytes(stream, 1)?;   // skip past type byte in message
        return Some(
            struct {
                template: msg with {
                    provenance: struct {
                        l1SeqNum: msg.provenance.l1SeqNum,
                        parentRequestId: msg.requestId,
                        indexInParent: 0,
                    }
                },
                stream: stream,
                numSoFar: 0,
            }
        );
    } elseif ( (msg.kind == const::L1MessageType_L2) && (bytearray_getByte(msg.msgData, 0) == const::L2MessageType_sequencerBatch) ) {  // sequencer batch
        let stream = bytestream_new(msg.msgData);
        stream = bytestream_skipBytes(stream, 6)?;   // skip past type byte, blocknum, and timestamp in message
        return Some(
            struct {
                template: msg with {
                    provenance: struct {
                        l1SeqNum: msg.provenance.l1SeqNum,
                        parentRequestId: msg.requestId,
                        indexInParent: 0,
                    }
                },
                stream: stream,
                numSoFar: 0,
            }
        );
    } else {
        // it's not a batch
        return None;
    }
}

public func messageBatch_get(batch: MessageBatch) -> option<(IncomingRequest, MessageBatch)> {
    // returns next message in the batch (and updated batch), or None if no more messages in batch
    let (stream, l2MsgLength) = rlp_decodeUint(batch.stream)?;
    let (bs, extractedL2data) = bytestream_getN(stream, l2MsgLength)?;
    stream = bs;

    return Some((
        batch.template with {
            msgData: extractedL2data
        } with {
            requestId: uint(hash(bytes32(batch.template.requestId), bytes32(batch.numSoFar)))
        } with {
            provenance: batch.template.provenance with { indexInParent: batch.numSoFar }
        },
        batch with {
            stream: stream
        } with {
            numSoFar: batch.numSoFar + 1
        }
    ));
}
