//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type MarshalledBytes;

import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;

import func evmCallStack_callHitError(reason: uint);

type ChainParams = struct {
    chainAddress: address,
    gracePeriodSec: uint,
    arbGasSpeedLimit: uint,
    maxExecutionSteps: uint,
    baseStake: uint,
    owner: address
}

var globalChainParams: option<ChainParams>;

public impure func chainParams_init() {
    globalChainParams = None<ChainParams>;
}

public impure func chainParams_gotParamsMessage(sender: address, data: MarshalledBytes) {
    if (globalChainParams == None<ChainParams>) {
        let ba = bytearray_unmarshalBytes(data);
        globalChainParams = Some(struct{
            chainAddress: sender,
            gracePeriodSec: bytearray_get256(ba, 0) / 1000,
            arbGasSpeedLimit: bytearray_get256(ba, 32) * 1000,
            maxExecutionSteps: bytearray_get256(ba, 2*32),
            baseStake: bytearray_get256(ba, 3*32),
            owner: address(bytearray_get256(ba, 4*32)),
        });
    }
}

public impure func chainParams_chainAddress() -> address {
    if let Some(params) = globalChainParams {
        return params.chainAddress;
    } else {
        // If we get here, the chain never received its initialization message.
        evmCallStack_callHitError(15);
        panic;
    }
}

public impure func chainParams_chainId() -> uint {
    return uint(chainParams_chainAddress()) & 0xffffffffffff;  // chainID == low 48 bits of chainAddress
}

public impure func chainParams_speedLimitPerSecond() -> uint {
    if let Some(params) = globalChainParams {
        return params.arbGasSpeedLimit;
    } else {
        return 100000000;  // reasonable default
    }
}

public impure func chainParams_baseStake() -> uint {
    if let Some(params) = globalChainParams {
        return params.baseStake;
    } else {
        return 0;
    }
}
