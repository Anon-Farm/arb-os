//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//


use evmCallStack::evmCallStack_callHitError;

use std::bytearray::MarshalledBytes;
use std::bytearray::ByteArray;
use std::bytearray::MarshalledBytes;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytearray::bytearray_get256;

use std::bytestream::ByteStream;
use std::bytestream::bytestream_new;
use std::bytestream::bytestream_get64;
use std::bytestream::bytestream_get256;
use std::bytestream::bytestream_skipBytes;

use gasAccounting::gasAccounting_setFeeParams;
use gasAccounting::gasAccounting_postInitMessage;


type ChainParams = struct {
    chainAddress: address,
    gracePeriodBlocks: uint,         // time validators are given to respond to an assertion
    arbGasSpeedLimitPerBlock: uint,  // assumed max speed of nodes tracking this chain's VM
    millisecondsPerBlock: uint,      // mean time per L1 block
    maxExecutionSteps: uint,         // max number of steps in an assertion
    baseStake: uint,                 // base stake of a validator, in wei
    stakingToken: address,           // ERC-20 token used for staking; or zero if using ETH
    owner: address,                  // owner of the chain, who has admin privileges (or zero if there is no owner)
    isProChain: bool                 // is this an Arbitrum Pro chain?
}

var globalChainParams: option<ChainParams>;

public impure func chainParams_init() {
    globalChainParams = None<ChainParams>;
}

public impure func chainParams_gotParamsMessage(sender: address, data: ByteArray) {
    if (globalChainParams == None<ChainParams>) {
        globalChainParams = Some(struct{
            chainAddress: sender,
            gracePeriodBlocks: bytearray_get256(ba, 0) / 1000,   // divide because grace period sent in ticks
            arbGasSpeedLimitPerBlock: bytearray_get256(ba, 32),
            millisecondsPerBlock: 13500,
            maxExecutionSteps: bytearray_get256(ba, 2*32),
            baseStake: bytearray_get256(ba, 3*32),
            stakingToken: address(bytearray_get256(ba, 4*32)),
            owner: address(bytearray_get256(ba, 5*32)),
            isProChain: false,
        });

        // now read and process initialization options
        if let Some(stream) = bytestream_skipBytes(bytestream_new(data), 5*32) {
            loop {
                if let Some(ustr2) = doInitializationOption(stream) {
                    stream = ustr2;
                } else {
                    return;
                }
            }
        }
    }

    gasAccounting_postInitMessage();
}

impure func doInitializationOption(stream: ByteStream) -> option<ByteStream> {
    // process one initialization option
    // on success, return Some(updated stream)
    // on end-of-stream, return None

    let (ustr, optionId) = bytestream_get64(stream)?;
    stream = ustr;
    let (ustr, numPayloadBytes) = bytestream_get64(stream)?;
    stream = ustr;
    if (optionId == 0) {   // option: Arbitrum Pro chain
        if (numPayloadBytes != 0) {
            // unexpected payload size; discard the payload and ignore this option
            return bytestream_skipBytes(stream, numPayloadBytes);
        }
        globalChainParams = Some(globalChainParams? with { isProChain: true });
        return Some(stream);
    } elseif (optionId == 1) {   // option: set seconds per block
        let (ustr, secsPerBlock) = bytestream_get256(stream)?;
        globalChainParams = Some(globalChainParams? with { millisecondsPerBlock: 1000*secsPerBlock });
        return Some(ustr);
    } elseif (optionId == 2) {   // option: set gas charging parameters
        let (ustr, baseGasPrice) = bytestream_get256(stream)?;
        let (ustr, gasFeeRecipientAsUint) = bytestream_get256(ustr)?;
        gasAccounting_setFeeParams(baseGasPrice, address(gasFeeRecipientAsUint));
        return Some(ustr);
    } else {
        // unrecognized option, discard it
        return bytestream_skipBytes(stream, numPayloadBytes);
    }
}

public impure func chainParams_chainAddress() -> address {
    if let Some(params) = globalChainParams {
        return params.chainAddress;
    } else {
        // If we get here, the chain never received its initialization message.
        evmCallStack_callHitError(15);
        panic;
    }
}

public impure func chainParams_chainId() -> uint {
    return uint(chainParams_chainAddress()) & 0xffffffffffff;  // chainID == low 48 bits of chainAddress
}

public impure func chainParams_millisecondsPerBlock() -> uint {
    if let Some(params) = globalChainParams {
        return params.millisecondsPerBlock;
    } else {
        return 13500;     // reasonable default
    }
}

public impure func chainParams_speedLimitPerSecond() -> uint {
    if let Some(params) = globalChainParams {
        return params.arbGasSpeedLimitPerBlock * 1000 / params.millisecondsPerBlock;
    } else {
        return 100000000;  // reasonable default
    }
}

public impure func chainParams_baseStake() -> (address, uint) {
    if let Some(params) = globalChainParams {
        return (params.stakingToken, params.baseStake);
    } else {
        return (address(0), 0);
    }
}

public impure func chainParams_isProChain() -> bool {
    if let Some(params) = globalChainParams {
        return params.isProChain;
    } else {
        return false;
    }
}
