//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// This implements a key-value store.
// Uses of the map data structure in Mini compile into calls to this package.
// So please consult with the team before changing APIs or semantics of any of this.

// These functions can also be imported and called directly by Mini programs.

// Normal Mini code won't ever "reach inside" a map to disturb the integrity of this
// data structure. But note that use of unsafe language features could lead to structural
// damage to the internals of a map, leading to erroneous results or even a panic.


type TreeKvsTriple = struct {  // This struct stores one item in the KVS.
    reducedKey: uint,   // hash of the item's key, divided by 8 for each level we descend in the tree
    key: any,           // item's key
    value: any          // item's value
}

type TreeKvsCell = struct {   // The KVS is represented as a tree of these.
    triple: option<TreeKvsTriple>,
    children: [8]any,    // actually [8]TreeKvs but compiler doesn't support recursive types
    size: uint
}

type TreeKvs = option<TreeKvsCell>   // will be None if tree is empty


public func builtin_kvsNew() -> TreeKvs {
    return None<TreeKvsCell>;
}

public func builtin_kvsGet(kvs: TreeKvs, key: any) -> option<any> {
    let reducedKey = uint(hash(key));
    loop {
        let cell = kvs?;
        if let Some(triple) = cell.triple {
            if (reducedKey == triple.reducedKey) {
                return Some(triple.value);
            }
        }
        kvs = unsafecast<TreeKvs>(cell.children[reducedKey % 8]);
        reducedKey = reducedKey / 8;
    }
}

public func builtin_kvsHasKey(kvs: TreeKvs, key: any) -> bool {
    return builtin_kvsGet(kvs, key) != None<any>;
}

public func builtin_kvsSet(kvs: TreeKvs, key: any, value: any) -> TreeKvs {
    if let Some(res) = builtin_kvsSet2(
        kvs,
        uint(hash(key)),
        key,
        value
    ) {
        let (newKvs, _) = res;
        return newKvs;
    } else {
        return kvs;
    }
}

func builtin_kvsSet2(
    kvs: TreeKvs,
    reducedKey: uint,
    key: any,
    value: any
) -> option<(TreeKvs, int)> {
    // Update a KVS by setting a key/value pair.
    // This returns Some((updatedKvs, sizeDiff)) if the structure changed, None if it didn't.
    if let Some(cell) = kvs {
        if let Some(triple) = cell.triple {
            if (triple.reducedKey == reducedKey) {
                // Found a cell containing the same key. Update the value.
                return Some((Some(
                    cell with {
                        triple: Some(triple with { value: value })
                    }
                ), 0s));
            } else {
                // Didn't find a match here, descend on level in the tree, recursively.
                let slot = reducedKey % 8;
                let oldKid = unsafecast<TreeKvs>(cell.children[slot]);
                let (newKid, sizeDiff) = builtin_kvsSet2(
                    oldKid,
                    reducedKey / 8,
                    key,
                    value
                )?;
                return Some((Some(
                    cell with {
                        children: cell.children with {
                            [slot] = newKid
                        }
                    } with {
                        size: uint(int(cell.size) + sizeDiff)
                    }
                ), sizeDiff));
            }
        } else {
            // This cell doesn't have a triple, so insert our new item here.
            // But there might already be an item with the same key lower in the tree,
            //     so we have to make sure to delete that one first.

            // If there is an item with the same key lower in the tree, delete it.
            let slot = reducedKey % 8;
            let sizeDiff = 1s;
            if let Some(res) = builtin_kvsDelete2(
                unsafecast<TreeKvs>(cell.children[slot]),
                reducedKey / 8
            ) {
                let (newChild, subSizeDiff) = res;
                sizeDiff = sizeDiff + subSizeDiff;
                cell = cell with {
                    children: cell.children with {
                        [slot] = newChild
                    }
                };
            }

            // Now add the new item
            return Some((Some(
                cell with {
                    triple: Some(struct {
                        reducedKey: reducedKey,
                        key: key,
                        value: value
                    })
                } with {
                    size: uint(int(cell.size) + sizeDiff)
                }
            ), sizeDiff));
        }
    } else {
        // There was nothing here, so allocate an empty cell and add this item to it.
        return Some((Some(
            struct {
                triple: Some(struct {
                    reducedKey: reducedKey,
                    key: key,
                    value: value
                }),
                children: newfixedarray(8, None<TreeKvsCell>),
                size: 1
            }
        ), 1s));
    }
}

public func builtin_kvsDelete(kvs: TreeKvs, key: any) -> TreeKvs {
    if let Some(res) = builtin_kvsDelete2(kvs, uint(hash(key))) {
        let (newKvs, _) = res;
        return newKvs;
    } else {
        return kvs;
    }
}

func builtin_kvsDelete2(kvs: TreeKvs, reducedKey: uint) -> option<(TreeKvs, int)> {
    // Delete a key.
    // Returns Some((updatedKvs, sizeDiff)) is anything changed, None otherwise.
    let cell = kvs?;
    if let Some(triple) = cell.triple {
        if (triple.reducedKey == reducedKey) {
            // Found a matching item. Delete it and return.
            return Some(
                (
                    Some(
                        cell with { triple: None<TreeKvsTriple> }
                             with { size: uint(int(cell.size) - 1s) }
                    ),
                    -1s
                )
            );
        }
    }

    // Didn't find a match here, descend the tree recursively.
    let slot = reducedKey % 8;
    let (newKid, sizeDiff) = builtin_kvsDelete2(
        unsafecast<TreeKvs>(cell.children[slot]),
        reducedKey / 8,
    )?;
    return Some((Some(
        cell with {
            children: cell.children with {
                [slot] = newKid
            }
        } with {
            size: uint(int(cell.size) + sizeDiff)
        }
    ), sizeDiff));
}

public func builtin_kvsForall(
    kvs: TreeKvs,
    callback: func(any, any, any) -> any,
    state: any  // initial value for state
) -> any {
    // Visit every item in the KVS, calling callback on each one.
    // newState = callback(thisItem.key, thisItem.value, oldState)
    // Return the final state after visiting all items.
    if let Some(cell) = kvs {
        if let Some(triple) = cell.triple {
            state = callback(triple.key, triple.value, state);
        }
        let i = 0;
        while (i < 8) {
            state = builtin_kvsForall(
                unsafecast<TreeKvs>(cell.children[i]),
                callback,
                state
            );
            i = i+1;
        }
    }

    return state;
}

public func builtin_kvsSize(kvs: TreeKvs) -> uint {
    if let Some(cell) = kvs {
        return cell.size;
    } else {
        return 0;
    }
}
