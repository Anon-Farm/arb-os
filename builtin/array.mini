
type block = [8]anytype

type array = struct {
	size: uint,  // This must be the first field--codegen relies on this.
	topstep: uint,
	contents: block,
}

func main() anytype {
	return builtin_arrayNew(13, null);
}

public func builtin_arrayNew(sz: uint, base_val: anytype) array {
	let chunk = 1;
	while (8*chunk < sz) {
		chunk = 8*chunk;
		base_val = newfixedarray(8, base_val);
	}
	return struct {
		size: sz,
		topstep: chunk,
		contents: unsafecast(newfixedarray(8, base_val), block),
	};
}

public func builtin_arrayGet(arr: array, index: uint) anytype {
	if (index >= arr.size) {
		panic;
	}
	let res = arr.contents;
	let chunk = arr.topstep;
	while (1 <= chunk) {
		res = unsafecast(res[index/chunk], block);
		index = index % chunk;
		chunk = chunk / 8;
	}
	return res;
}

public func builtin_arraySet(arr: array, index: uint, value: anytype) array {
	if (index >= arr.size) {
		panic;
	}
	return arr with { contents: arraySet2(arr.contents, arr.topstep, index, value) };
}

func arraySet2(b: block, chunk: uint, index: uint, value: anytype) block {
	if (1 == chunk) {
		return b with {[index] = value};
	} else {
		return b with {[index/chunk] = arraySet2(
			unsafecast(b[index/chunk], block), 
			chunk/8, 
			index%chunk, 
			value
		)};
	}
}

public func builtin_arraySwap(a: array, index: uint, value: anytype) (array, anytype) {
	if (index >= a.size) {
		panic;
	}
	let sub = arraySwap2(a.contents, a.topstep, index, value);
	return (
		a with { contents: sub.bloc },
		sub.val,
	);
}

type arraySwapSubResult = struct {
	bloc: block,
	val:  anytype,
}

func arraySwap2(b: block, chunk: uint, index: uint, value: anytype)  arraySwapSubResult {
	if (1 == chunk) {
		return struct {
			bloc: b with {[index] = value},
			val: b[index],
		};
	} else {
		let subIndex = index/chunk;
		let sub = arraySwap2(
			unsafecast(b[subIndex], block),
			chunk/8,
			index%chunk,
			value
		);
		return sub with { bloc: b with {[subIndex] = sub.bloc} };
	}
}

type opClosure = struct {
	f: func(anytype, anytype) (anytype, anytype),
	val: anytype,
}

public func builtin_arrayOp(a: array, index: uint, closure: opClosure) (array, anytype) {
	if (index >= a.size) {
		panic;
	}
	let sub = arrayOp2(a.contents, a.topstep, index, closure);
	return (
		a with { contents: sub.bloc },
		sub.val,
	);
}

func arrayOp2(b: block, chunk: uint, index: uint, closure: opClosure)  arraySwapSubResult {
	if (1 == chunk) {
		let result = closure.f(closure.val, b[index]);
		return struct {
			bloc: b with {[index] = result.0},
			val: result.1,
		};
	} else {
		let subIndex = index/chunk;
		let sub = arrayOp2(
			unsafecast(b[subIndex], block),
			chunk/8,
			index%chunk,
			closure
		);
		return sub with { bloc: b with {[subIndex] = sub.bloc} };
	}
}

public func array_resize(a: array, newSize: uint, baseVal: anytype) array { 
	// TODO: make this more efficient by reusing more of the tree-structure of a
	let minSize = a.size;
	if (minSize > newSize) {
		minSize = newSize;
	}
	let ret = builtin_arrayNew(newSize, baseVal);
	let i = 0;
	while (i < minSize) {
		ret = builtin_arraySet(ret, i, builtin_arrayGet(a, i));
		i = i+1;
	}
	return ret;
}