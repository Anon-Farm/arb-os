//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type AccountStore;
import type Account;
import type EvmLogs;
import type Queue;
import type ByteArray;

import func getGlobalAccountStore() -> AccountStore;
import func accountStore_get(store: AccountStore, addr: address) -> Account;
import func accountStore_set(store: AccountStore, addr: address, acct: Account) -> AccountStore;
import func account_setStorageCell(acct: Account, offset: uint, value: uint) -> Account;
import func account_getBalance(acct: Account) -> uint;
import func account_setBalance(acct: Account, bal: uint) -> Account;
import func account_deductFromEthBalance(account: Account, deduction: uint) -> option<Account>;

import func evmlogs_empty() -> EvmLogs;

import func bytearray_new(capacity: uint, variableSize: bool) -> ByteArray;

import func queue_new() -> Queue;
import func queue_isEmpty(q: Queue) -> bool;
import func queue_get(q: Queue) -> (Queue, any);
import func queue_put(q: Queue, val: any) -> Queue;


type EvmCallFrame = struct {
    addr: address,
    accountStore: AccountStore,
    currentAccount: Account,
    resumeCodePoint: option<func()>,
    calldata: ByteArray,
    callvalue: uint,
    returndata: option<ByteArray>,
    returnstatus: option<uint>,
    memory: ByteArray,
    evmLogs: EvmLogs,
    selfDestructQueue: Queue,
    parent: option<any>,      // really an option<EvmCallFrame>, but compiler doesn't allow recursive types
}

//FIXME:  add OrDie variants of the getters that return options; use in evmOps

var globalCallStack: option<EvmCallFrame>;

public impure func initEvmCallStack(
    addr: address,
    calldata: ByteArray,
    callvalue: uint,
) {
    let globalAS = getGlobalAccountStore();
    globalCallStack = Some(struct {
        addr: addr,
        accountStore: globalAS,
        currentAccount: accountStore_get(globalAS, addr),
        resumeCodePoint: None<func()>,
        calldata: calldata,
        callvalue: callvalue,
        returndata: None<ByteArray>,
        returnstatus: None<uint>,
        memory: bytearray_new(8, true),
        evmLogs: evmlogs_empty(),
        selfDestructQueue: queue_new(),
        parent: None<any>
    });
}

public impure func evmCallStack_currentFrame() -> option<EvmCallFrame> {
    return globalCallStack;
}

public impure func evmCallStack_currentAccount() -> option<Account> {
    return Some((globalCallStack?).currentAccount);
}

public impure func evmCallStack_currentAccountAndAddr() -> option<(Account, address)> {
    let topFrame = globalCallStack?;
    return Some((topFrame.currentAccount, topFrame.addr));
}

public impure func evmCallStack_writeCurrentAccount(acct: Account) -> bool {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(topFrame with { currentAccount: acct });
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_getAccount(addr: address) -> option<Account> {
    let topFrame = globalCallStack?;
    if (topFrame.addr == addr) {
        return Some(topFrame.currentAccount);
    } else {
        return Some(accountStore_get(topFrame.accountStore, addr));
    }
}

public impure func evmCallStack_setAccount(addr: address, acct: Account) -> bool {
    if let Some(topFrame) = globalCallStack {
        if (topFrame.addr == addr) {
            globalCallStack = Some(topFrame with { currentAccount: acct });
        } else {
            globalCallStack = Some(topFrame with {
                accountStore: accountStore_set(topFrame.accountStore, addr, acct)
            });
        }
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_getCurrentFrameMemoryOrDie() -> ByteArray {
    if let Some(topFrame) = globalCallStack {
        return topFrame.memory;
    } else {
        panic;
    }
}

public impure func evmCallStack_setCurrentFrameMemory(mem: ByteArray) -> bool {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(topFrame with { memory: mem });
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_transferEthFromCurrent(
    dest: address,
    amount: uint,
) -> bool {
    if let Some(topFrame) = globalCallStack {
        if (topFrame.addr == dest) {
            return false;   // can't do a self-transfer
        }
        let curAcct = topFrame.currentAccount;
        let curBalance = account_getBalance(curAcct);
        if (curBalance < amount) {
            return false;   // insufficient funds
        }
        topFrame = topFrame with {
            currentAccount: account_setBalance(curAcct, curBalance-amount)
        };
        let otherAcct = accountStore_get(topFrame.accountStore, dest);
        topFrame = topFrame with {
            accountStore: accountStore_set(
                topFrame.accountStore,
                dest,
                account_setBalance(
                    otherAcct,
                    account_getBalance(otherAcct) + amount
                )
            )
        };
        globalCallStack = Some(topFrame);
        return true;
    } else {
        return false;  // no current call frame
    }
}

public impure func evmCallStack_setCurrentFrameStorageCell(offset: uint, value: uint) -> bool {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(topFrame with {
            currentAccount: account_setStorageCell(
                topFrame.currentAccount,
                offset,
                value
            )
        });
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_selfDestructCurrentAccount(owner: address) {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(
            topFrame with {
                selfDestructQueue: queue_put(
                    topFrame.selfDestructQueue,
                    (topFrame.addr, owner)
                )
            }
        );
    }
}


public impure func evmCallStack_pop(status: uint, returndata: ByteArray) -> option<EvmCallFrame> {
    // if callstack is empty, return None
    // else pop the callstack, set up returndata and returnstatus in new top, return Some(newtopframe)
    let top = globalCallStack?;
    let parent = unsafecast<EvmCallFrame>(top.parent?);
    globalCallStack = Some(parent with { returndata: Some(returndata) }
                                  with { returnstatus: Some(status) }
                      );
    return globalCallStack;
}

public func evmCallFrame_currentAccount(frame: EvmCallFrame) -> Account {
    return frame.currentAccount;
}

public func evmCallFrame_getAccount(frame: EvmCallFrame, addr: address) -> Account {
    if (addr == frame.addr) {
        return frame.currentAccount;
    } else {
        return accountStore_get(frame.accountStore, addr);
    }
}

public func evmCallFrame_getMemory(frame: EvmCallFrame) -> ByteArray {
    return frame.memory;
}

public func evmCallFrame_getResumeCodePoint(frame: EvmCallFrame) -> option<func()> {
    return frame.resumeCodePoint;
}

public func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint {
    return frame.callvalue;
}

public func evmCallFrame_getCalldata(frame: EvmCallFrame) -> ByteArray {
    return frame.calldata;
}

public func evmCallFrame_getEvmLogs(frame: EvmCallFrame) -> EvmLogs {
    return frame.evmLogs;
}

public func evmCallFrame_getSelfDestructQueue(frame: EvmCallFrame) -> Queue {
    return frame.selfDestructQueue;
}
