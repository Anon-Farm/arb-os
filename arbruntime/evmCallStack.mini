//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type EthBridgeMessage;
import type AccountStore;
import type Account;
import type EvmLogs;
import type Queue;
import type ByteArray;
import type MarshalledBytes;
import type Stack;

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(store: AccountStore, addr: address) -> Account;
import func accountStore_set(store: AccountStore, addr: address, acct: Account) -> AccountStore;
import func accountStore_transferEthBalance(
    acctStore: AccountStore,
    from: address,
    to: address,
    amount: uint
) -> option<AccountStore>;
import func accountStore_destroyAndTransferBalance(
    acctStore: AccountStore,
    victim: address,
    recipient: address
) -> AccountStore;
import func account_setStorageCell(acct: Account, offset: uint, value: uint) -> option<Account>;
import func account_getBalance(acct: Account) -> uint;
import func account_setBalance(acct: Account, bal: uint) -> Account;
import func account_deductFromEthBalance(account: Account, deduction: uint) -> option<Account>;
import func account_getStartCodePoint(account: Account) -> option<func()>;

import func evmlogs_empty() -> EvmLogs;

import func bytearray_new(capacity: uint, variableSize: bool) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> option<ByteArray>;
import func bytearray_copy(
    from: ByteArray,   fromOffset: uint,
    to: ByteArray,     toOffset: uint,
    nbytes: uint
) -> option<ByteArray>;

import func queue_new() -> Queue;
import func queue_isEmpty(q: Queue) -> bool;
import func queue_get(q: Queue) -> (Queue, any);
import func queue_put(q: Queue, val: any) -> Queue;

import func stack_new() -> Stack;
import func stack_isEmpty(stack: Stack) -> bool;
import func stack_push(stack: Stack, value: any) -> Stack;
import func stack_pop(stack: Stack) -> option<(Stack, any)>;

import impure func mainRunLoop();


type EvmCallFrame = struct {
    addr: address,
    accountStore: AccountStore,
    currentAccount: Account,
    calldata: ByteArray,
    callvalue: uint,
    returnInfo: option<ReturnInfo>,
    memory: ByteArray,
    evmLogs: EvmLogs,
    selfDestructQueue: Queue,
    resumeInfo: option<ResumeInfo>,
    parent: option<any>,      // really an option<EvmCallFrame>, but compiler doesn't allow recursive types
}

type ReturnInfo = struct {
    data: ByteArray,
    status: bool,
}

type ResumeInfo = struct {
    codePoint: func(),
    stackContents: Stack,
    returnDataOffset: uint,
    returnDataNbytes: uint,
    callType: uint,
}

//FIXME:  add OrDie variants of the getters that return options; use in evmOps

var globalCallStack: option<EvmCallFrame>;
var globalCurrentEthMessage: EthBridgeMessage;

public impure func initEvmCallStack(
    ethMessage: EthBridgeMessage,
    addr: address,
    calldata: ByteArray,
    callvalue: uint,
) {
    globalCurrentEthMessage = ethMessage;

    let globalAS = getGlobalAccountStore();
    globalCallStack = Some(struct {
        addr: addr,
        accountStore: globalAS,
        currentAccount: accountStore_get(globalAS, addr),
        calldata: calldata,
        callvalue: callvalue,
        returnInfo: None<ReturnInfo>,
        memory: bytearray_new(8, true),
        evmLogs: evmlogs_empty(),
        selfDestructQueue: queue_new(),
        resumeInfo: None<ResumeInfo>,
        parent: None<any>
    });
}

public impure func evmCallStack_doCall(
    kind: uint,  // currently handle 0 (call),
    gas: uint,
    calleeAddr: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint,
    resumeCodePoint: func(),  // jump to this to resume the caller
) -> option<()> {
    // create a new callframe and launch execution in it
    // this handles all types of cross-contract calls (kind says which kind of call it is)
    // the callframe will have a full copy of the system state, but
    //        that state will be contingent on the call succeeding
    // if the call succeeds, we'll copy the call's state into the caller as the new
    //        state, but if call fails we'll discard the state from the caller's frame

    let topFrame = globalCallStack?;
    let callerAddr = topFrame.addr;
    if (callerAddr == calleeAddr) {
        return None;  // a contract shouldn't use the external call mechanism to call itself
    }
    let caller = topFrame.currentAccount;

    // set up the caller's frame
    //    this means (1) saving the currentAccount into the accountStore, and
    //               (2) saving the AvmStack and resumeCodePoint so we can resume later
    let stackContents = saveAvmStack();  // must be called as top level statement
    topFrame = topFrame
        with { accountStore: accountStore_set(topFrame.accountStore, callerAddr, caller) }
        with { resumeInfo: Some(struct {
                   codePoint: resumeCodePoint,
                   stackContents: stackContents,
                   returnDataOffset: retOffset,
                   returnDataNbytes: retLength,
                   callType: kind,
               }) };

    // now create a new callframe for the callee
    //     it incorporates the balance transfer from caller to callee
    //          (which is put into the callee frame so it isn't finalized unless the call succeeds)
    let callee = accountStore_get(topFrame.accountStore, calleeAddr);
    let newTopFrame = struct {
        addr: calleeAddr,
        accountStore: accountStore_transferEthBalance(
            topFrame.accountStore,
            callerAddr,
            calleeAddr,
            balance
        )?,
        currentAccount: callee,
        calldata: bytearray_extract(topFrame.memory, argsOffset, argsLength)?,
        callvalue: balance,
        returnInfo: None<ReturnInfo>,
        memory: bytearray_new(8, true),
        evmLogs: evmlogs_empty(),
        selfDestructQueue: topFrame.selfDestructQueue,
        resumeInfo: None<ResumeInfo>,
        parent: Some(topFrame)
    };

    // there were no errors in the setup, so write the result to global storage
    globalCallStack = Some(newTopFrame);

    // jump to the called code's startCodePoint -- this should never return
    let startCodePoint = account_getStartCodePoint(callee)?;
    startCodePoint();

    panic;
}

public impure func evmCallStack_returnFromCall(
    success: bool,
    returnOffset: uint,
    returnLength: uint
) -> option<()> {
    asm(101,) { debugprint };
    let topFrame = globalCallStack?;
    let memory = topFrame.memory;
    let returnData = bytearray_extract(memory, returnOffset, returnLength)?;
    if let Some(newTopFrame) = unsafecast<option<EvmCallFrame>>(topFrame.parent) {
        asm(201,) { debugprint };
        if (success) {
            asm(202,) { debugprint };
            topFrame = topFrame with {
                accountStore: accountStore_set(
                    topFrame.accountStore,
                    topFrame.addr,
                    topFrame.currentAccount
                )
            };

            // copy relevant data back to parent frame
            newTopFrame = newTopFrame
                with { accountStore: topFrame.accountStore }
                with { currentAccount: accountStore_get(topFrame.accountStore, newTopFrame.addr) }
                with { returnInfo: Some(struct{ data: returnData, status: success }) }
                with { evmLogs: topFrame.evmLogs }
                with { selfDestructQueue: topFrame.selfDestructQueue }
                with { parent: None<any> };
        }

        asm(203,) { debugprint };
        let resumeInfo = newTopFrame.resumeInfo?;
        asm(204,) { debugprint };
        if (returnLength > resumeInfo.returnDataNbytes) {
             returnLength = resumeInfo.returnDataNbytes;
        }
        asm(205,) { debugprint };
        let newMemory = bytearray_copy(
            returnData,
            0,
            newTopFrame.memory,
            returnOffset,
            returnLength
        )?;
        asm(206,) { debugprint };
        newTopFrame = newTopFrame with { memory: newMemory };

        // ready to return to caller
        // save updated EVM callstack state; restore caller's stack; jump to resume address
        globalCallStack = Some(newTopFrame);
        emptyAvmStack();
        restoreAvmStack(resumeInfo.stackContents,);
        asm(resumeInfo.codePoint,) { jump };
        panic;  // shouldn't happen -- previous instruction jumped away
    } else {
        asm(102,) { debugprint };
        // top-level call finished
        if (success) {
            asm(103,) { debugprint };
            let acctStore = accountStore_set(
                topFrame.accountStore,
                topFrame.addr,
                topFrame.currentAccount
            );
            let sdq = topFrame.selfDestructQueue;
            while( ! queue_isEmpty(sdq) ) {
                let (q, item) = queue_get(sdq);
                sdq = q;
                let (victim, owner) = unsafecast<(address, address)>(item);
                acctStore = accountStore_destroyAndTransferBalance(acctStore, victim, owner);
            }
            let marshaledReturnData = bytearray_marshalFull(returnData);
            asm(104,) { debugprint };
            asm(
                (
                    globalCurrentEthMessage,
                    topFrame.evmLogs,
                    marshaledReturnData,
                    true
                ),
            ) { log } ;

            asm(105,) { debugprint };
            setGlobalAccountStore(acctStore,);
        } else {
           asm(106,) { debugprint };
           asm(
                (
                    globalCurrentEthMessage,
                    evmlogs_empty(),  // emit no logs because txcall failed
                    bytearray_marshalFull(returnData),
                    false
                ),
            ) { log } ;
        }

        asm(107,) { debugprint };

        // save the global account state and jump back to the main run loop

        emptyAvmStack();
        cleanAvmAuxStackAndCall(mainRunLoop,);  // should never return
        panic;
    }
}

func saveAvmStack() -> Stack {
    // pop all items from the AVM stack, push them into a Stack
    let ret = stack_new();
    while( ! asm() bool { stackempty } ) {
        let stackTop = asm() any { };  // pop value from AVM stack
        ret = stack_push(ret, stackTop);
    }
    return ret;
}

func emptyAvmStack() {
    // discard everything on the AVM stack
    while( ! asm() bool { stackempty } ) {
        let _ = asm() any { };  // pop value from AVM stack
    }
}

func restoreAvmStack(savedStack: Stack) {
    // restore AVM stack state, from a Stack that was made by saveAvmStack
    while( ! stack_isEmpty(savedStack) ) {
        if let Some(res) = stack_pop(savedStack) {
            let (newStack, top) = res;
            savedStack = newStack;
            asm (top,) { };  // push top onto AVM stack
        }
    }
}

impure func cleanAvmAuxStackAndCall(funcToCall: impure func()) {
    // This cleans the AvmAuxStack, then calls funcToCall.
    // funcToCall must never try to return.

    // discard everything from the auxstack, except the current callframe (which is on top)
    // keep the callframe on top of the auxstack (except during asm blocks)
    //       in case the code generator wants to use the callframe
    while ( ! asm() bool { auxpop auxstackempty swap1 auxpush }) {
        asm() {
            auxpop
            auxpop
            pop
            auxpush
        };
    }
    asm(201,) { debugprint };

    // discard our callframe, push a fake return address, and jump to funcToCall
    // funcToCall will think somebody called it normally, with an empty auxstack
    asm(funcToCall,) {
        auxpop
        pop
        [0] swap1  // bogus return address, which funcToCall will save in its callframe but will never use
        jump
    };
}

public impure func evmCallStack_currentFrame() -> option<EvmCallFrame> {
    return globalCallStack;
}

public impure func evmCallStack_currentAccount() -> option<Account> {
    return Some((globalCallStack?).currentAccount);
}

public impure func evmCallStack_currentAccountAndAddr() -> option<(Account, address)> {
    let topFrame = globalCallStack?;
    return Some((topFrame.currentAccount, topFrame.addr));
}

public impure func evmCallStack_writeCurrentAccount(acct: Account) -> bool {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(topFrame with { currentAccount: acct });
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_getAccount(addr: address) -> option<Account> {
    let topFrame = globalCallStack?;
    if (topFrame.addr == addr) {
        return Some(topFrame.currentAccount);
    } else {
        return Some(accountStore_get(topFrame.accountStore, addr));
    }
}

public impure func evmCallStack_setAccount(addr: address, acct: Account) -> bool {
    if let Some(topFrame) = globalCallStack {
        if (topFrame.addr == addr) {
            globalCallStack = Some(topFrame with { currentAccount: acct });
        } else {
            globalCallStack = Some(topFrame with {
                accountStore: accountStore_set(topFrame.accountStore, addr, acct)
            });
        }
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_getCurrentFrameMemoryOrDie() -> ByteArray {
    if let Some(topFrame) = globalCallStack {
        return topFrame.memory;
    } else {
        panic;
    }
}

public impure func evmCallStack_setCurrentFrameMemory(mem: ByteArray) -> bool {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(topFrame with { memory: mem });
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_transferEthFromCurrent(
    dest: address,
    amount: uint,
) -> bool {
    if let Some(topFrame) = globalCallStack {
        if (topFrame.addr == dest) {
            return false;   // can't do a self-transfer
        }
        let curAcct = topFrame.currentAccount;
        let curBalance = account_getBalance(curAcct);
        if (curBalance < amount) {
            return false;   // insufficient funds
        }
        topFrame = topFrame with {
            currentAccount: account_setBalance(curAcct, curBalance-amount)
        };
        let otherAcct = accountStore_get(topFrame.accountStore, dest);
        topFrame = topFrame with {
            accountStore: accountStore_set(
                topFrame.accountStore,
                dest,
                account_setBalance(
                    otherAcct,
                    account_getBalance(otherAcct) + amount
                )
            )
        };
        globalCallStack = Some(topFrame);
        return true;
    } else {
        return false;  // no current call frame
    }
}

public impure func evmCallStack_setCurrentFrameStorageCell(offset: uint, value: uint) -> option<()> {
    let topFrame = globalCallStack?;
    globalCallStack = Some(topFrame with {
        currentAccount: account_setStorageCell(
            topFrame.currentAccount,
            offset,
            value
        )?
    });
    return Some(());
}

public impure func evmCallStack_selfDestructCurrentAccount(owner: address) {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(
            topFrame with {
                selfDestructQueue: queue_put(
                    topFrame.selfDestructQueue,
                    (topFrame.addr, owner)
                )
            }
        );
    }
}

public func evmCallFrame_currentAccount(frame: EvmCallFrame) -> Account {
    return frame.currentAccount;
}

public func evmCallFrame_getAccount(frame: EvmCallFrame, addr: address) -> Account {
    if (addr == frame.addr) {
        return frame.currentAccount;
    } else {
        return accountStore_get(frame.accountStore, addr);
    }
}

public func evmCallFrame_getMemory(frame: EvmCallFrame) -> ByteArray {
    return frame.memory;
}

public func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint {
    return frame.callvalue;
}

public func evmCallFrame_getCalldata(frame: EvmCallFrame) -> ByteArray {
    return frame.calldata;
}

public func evmCallFrame_getEvmLogs(frame: EvmCallFrame) -> EvmLogs {
    return frame.evmLogs;
}

public func evmCallFrame_getResumeCodePoint(frame: EvmCallFrame) -> option<func()> {
    return Some((frame.resumeInfo?).codePoint);
}

public func evmCallFrame_getSelfDestructQueue(frame: EvmCallFrame) -> Queue {
    return frame.selfDestructQueue;
}
