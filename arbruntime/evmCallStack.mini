//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type AccountStore;
import type Account;

import func accountStore_get(store: AccountStore, addr: address) -> Account;

type EvmCallFrame = struct {
    addr: address,
    accountStore: AccountStore,
    currentAccount: Account,
    parent: any,      // really an EvmCallFrame (or null), but compiler doesn't allow recursive types
}

var globalCallStack: EvmCallFrame;

public impure func evmCallStack_isEmpty() -> bool {
    return null == unsafecast<any>(globalCallStack);
}

public impure func evmCallStack_currentAccount() -> Account {
    if (evmCallStack_isEmpty()) {
        return unsafecast<Account>(null);
    }
    return globalCallStack.currentAccount;
}

public impure func evmCallStack_writeCurrentAccount(acct: Account) {
    if ( ! evmCallStack_isEmpty()) {
        globalCallStack = globalCallStack with { currentAccount: acct };
    }
}

public impure func evmCallStack_getAccount(addr: address) -> Account {
    if (evmCallStack_isEmpty()){
        return unsafecast<Account>(null);
    }
    if (globalCallStack.addr == addr) {
        return globalCallStack.currentAccount;
    } else {
        return accountStore_get(globalCallStack.accountStore, addr);
    }
}