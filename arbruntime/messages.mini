//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type ByteStream;
import type MarshalledBytes;
import type AccountStore;
import type Account;

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func accountStore_set(acctStore: AccountStore, addr: address, acct: Account) -> AccountStore;
import func accountStore_transferEthBalance(
    acctStore: AccountStore,
    from: address, 
    to: address, 
    amount: uint
) -> (bool, AccountStore);
import func account_checkAndIncrSeqNum(
    account: Account, 
    seqNumRecvd: uint
) -> (bool, Account);
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytestream_new(ba: ByteArray) -> ByteStream;
import func parseModule(bs: ByteStream) -> (bool, func()->any, func());


type ArbMessage = struct {
    msgType: uint,
    sender: address,
    message: any,
}

type TokenTransferMessage = struct {
    tokenAddress: address,
    dest: address,
    amount: uint,
}

type EthTransferMessage = struct {
    dest: address,
    amount: uint,
}

type TxMessage = struct {
    to: address,
    seqNumber: uint,
    value: uint,
    data: MarshalledBytes,
}

type CallMessage = struct {
    to: address,
    data: MarshalledBytes,
}

type CodeLoadMessage = struct {
    addr: address,
    data: MarshalledBytes,
}

public impure func handleEthbridgeMessage(msg: ArbMessage) {
    let msgType = msg.msgType;
    //asm(1000+msg.msgType) { log };
    if (msgType == 0) {
        let txMsg = unsafecast<TxMessage>(msg.message);
        let globalAS = getGlobalAccountStore();
        let account = accountStore_get(globalAS, msg.sender);
        let (success, updatedAcct,) = account_checkAndIncrSeqNum(account, txMsg.seqNumber);
        if (success) {
            setGlobalAccountStore(
                accountStore_set(globalAS, msg.sender, updatedAcct)
            );
            handleValidTxMessage(txMsg);
            panic; //TODO
        } else {
            // sequence number was invalid
            panic; //TODO
        }
    } elseif (msgType == 1) {
        let depMsg = unsafecast<EthTransferMessage>(msg.message);
        let globalAS = getGlobalAccountStore();
        let (success, newGAS,) = accountStore_transferEthBalance(
            globalAS, 
            msg.sender, 
            depMsg.dest, 
            depMsg.amount
        );
        if (success) {
            setGlobalAccountStore(newGAS);
            panic; // TODO
        } else {
            panic; //TODO
        }
    } elseif (msgType == 2) {
        let depMsg = unsafecast<TokenTransferMessage>(msg.message);
        panic; // deposit ERC 20
    } elseif (msgType == 3) {
        let depMsg = unsafecast<TokenTransferMessage>(msg.message);
        panic; // deposit ERC 721
    } elseif (msgType == 4) {
        panic; // contract tx call message
    } elseif (msgType == 5) {
        let callMsg = unsafecast<CallMessage>(msg.message);
        panic; // call message
    } elseif (msgType == 6) {
        let codeLoadMsg = unsafecast<CodeLoadMessage>(msg.message);
        let ba = bytearray_unmarshalBytes(codeLoadMsg.data);
        let bs = bytestream_new(ba);
        let (success, initCodePt, callCodePt,) = parseModule(bs);
        if (success) {
            let initData = initCodePt();
            // TODO: install the loaded code as a contract
            callCodePt();
        }
    }
    // if no case matches, unrecognized message type; ignore it
}

impure func handleValidTxMessage(txMsg: TxMessage) {
    //TODO
}