//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type ByteStream;
import type MarshalledBytes;
import type AccountStore;
import type Account;
import type EvmLogs;

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func accountStore_set(acctStore: AccountStore, addr: address, acct: Account) -> AccountStore;
import func accountStore_transferEthBalance(
    acctStore: AccountStore,
    from: address, 
    to: address, 
    amount: uint
) -> option<AccountStore>;
import func accountStore_createAccountFromEvmCode(
    acctStore: AccountStore,
    newAddr: address,
    evmCode: ByteArray,
    evmJumpTable: map<uint, func()>,
    startCodePt: func(),
    storageMap: map<uint, uint>
) -> option<AccountStore>;
import func account_checkAndIncrSeqNum(
    account: Account, 
    seqNumRecvd: uint
) -> option<Account>;

import func account_getStartCodePoint(acct: Account) -> option<func()>;

import impure func initEvmCallStack(
    callKind: uint,
    ethMessage: EthBridgeMessage,
    addr: address,
    caller: address,
    calldata: ByteArray,
    callvalue: uint
);
import func evmCallStack_runningCodeFromAccount() -> option<Account>;

import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;

import func bytestream_new(ba: ByteArray) -> ByteStream;

import func makeInitStructures(v: any) -> (map<uint, func()>, map<uint, uint>);
import func translateEvmCodeSegment(bs: ByteStream) -> option<(func(), map<uint, func()>)>;

import func cleanUpAndJumpToRunLoop();

type EthBridgeMessage = struct {
    blockNum: uint,
    timestamp: uint,
    txId: uint,
    message: ArbMessage,
}

type ArbMessage = struct {
    msgType: uint,
    sender: address,
    message: any,
}

type TokenTransferMessage = struct {
    tokenAddress: address,
    dest: address,
    amount: uint,
}

type EthTransferMessage = struct {
    dest: address,
    amount: uint,
}

type TxMessage = struct {
    to: address,
    seqNumber: uint,
    value: uint,
    data: MarshalledBytes,
}

type CallMessage = struct {
    to: address,
    data: MarshalledBytes,
}

type AvmCodeLoadMessage = struct {
    seqNum: uint,
    data: MarshalledBytes,
}

type EvmCodeLoadMessage = struct {
    contractAddr: address,
    data: MarshalledBytes,
    storageInfo: StorageInfo,
}
    
type StorageInfo = struct {
    offset: uint,
    value: uint,
    more: any,
}

public impure func handleEthbridgeMessage(ethMsg: EthBridgeMessage) {
    let arbMsg = ethMsg.message;
    let msgType = arbMsg.msgType;
    if (msgType == 0) {
        let txMsg = unsafecast<TxMessage>(arbMsg.message);
        let globalAS = getGlobalAccountStore();
        let account = accountStore_get(globalAS, arbMsg.sender);
        if let Some(updatedAcct) = account_checkAndIncrSeqNum(account, txMsg.seqNumber) {
            setGlobalAccountStore(
                accountStore_set(globalAS, arbMsg.sender, updatedAcct),
            );
            if ( ! handleValidTxMessage(txMsg, ethMsg)) {
                panic; // for debugging -- call failed
            }
        } else {
            // sequence number was invalid
            panic; //TODO
        }
    } elseif (msgType == 1) {
        let depMsg = unsafecast<EthTransferMessage>(arbMsg.message);
        let globalAS = getGlobalAccountStore();
        if let Some(newGAS) = accountStore_transferEthBalance(
            globalAS, 
            arbMsg.sender,
            depMsg.dest, 
            depMsg.amount
        ) {
            setGlobalAccountStore(newGAS,);
            panic; // TODO
        } else {
            panic; //TODO
        }
    } elseif (msgType == 2) {
        let depMsg = unsafecast<TokenTransferMessage>(arbMsg.message);
        panic; // deposit ERC 20
    } elseif (msgType == 3) {
        let depMsg = unsafecast<TokenTransferMessage>(arbMsg.message);
        panic; // deposit ERC 721
    } elseif (msgType == 4) {
        panic; // contract tx call message
    } elseif (msgType == 5) {
        let callMsg = unsafecast<CallMessage>(arbMsg.message);
        panic; // call message
    // msgType 6  is currently unused
    } elseif (msgType == 7) {
        let codeLoadMsg = unsafecast<EvmCodeLoadMessage>(arbMsg.message);
        let globalAS = getGlobalAccountStore();
        let ba = bytearray_unmarshalBytes(codeLoadMsg.data);
        let bs = bytestream_new(ba);
        if let Some(res) = translateEvmCodeSegment(bs) {
            let (codept, evmJumpTable) = res;
            let newAddr = codeLoadMsg.contractAddr;
            if let Some(as) = accountStore_createAccountFromEvmCode(
                globalAS,
                newAddr,
                ba,
                evmJumpTable,
                codept,
                makeStorageMap(codeLoadMsg.storageInfo)
            ) {
                globalAS = as;
            } else {
                asm((666, 0),) { log };
            }
        } else {
            asm((666, 1),) { log };
        }
        setGlobalAccountStore(globalAS,);
    }
    // if no case matches, unrecognized message type; ignore it
}

func makeStorageMap(storageInfo: StorageInfo) -> map<uint, uint> {
    let ret = newmap<uint, uint>;
    while (null != unsafecast<any>(storageInfo)) {
        ret = ret with { [storageInfo.offset] = storageInfo.value };
        storageInfo = unsafecast<StorageInfo>(storageInfo.more);
    }
    return ret;
}

impure func handleValidTxMessage(txMsg: TxMessage, fullMsg: EthBridgeMessage) -> bool {
    initEvmCallStack(
        0,    // txcall type
        fullMsg,
        txMsg.to,
        fullMsg.message.sender,
        bytearray_unmarshalBytes(txMsg.data),
        txMsg.value
    );
    if let Some(codeAcct) = evmCallStack_runningCodeFromAccount() {
        if let Some(codept) = account_getStartCodePoint(codeAcct) {
            codept();   // should never return
            panic;
        } else {
            return false;
        }
    } else {
        return false;
    }
}
