//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type ByteStream;
import type MarshalledBytes;
import type AccountStore;
import type Account;

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func accountStore_set(acctStore: AccountStore, addr: address, acct: Account) -> AccountStore;
import func accountStore_transferEthBalance(
    acctStore: AccountStore,
    from: address, 
    to: address, 
    amount: uint
) -> option<AccountStore>;
import func accountStore_createAccountFromEvmCode(
    acctStore: AccountStore,
    evmCode: ByteArray,
    evmJumpTable: map<uint, func()>,
    startCodePt: func(),
    storageMap: map<uint, uint>
) -> AccountStore;
import func account_checkAndIncrSeqNum(
    account: Account, 
    seqNumRecvd: uint
) -> option<Account>;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytestream_new(ba: ByteArray) -> ByteStream;
import func unmarshalCodeSegment(bs: ByteStream) -> option<(func()->any, func())>;
import func makeInitStructures(v: any) -> (map<uint, func()>, map<uint, uint>);
import func translateEvmCodeSegment(bs: ByteStream) -> option<(func(), map<uint, func()>)>;


type ArbMessage = struct {
    msgType: uint,
    sender: address,
    message: any,
}

type TokenTransferMessage = struct {
    tokenAddress: address,
    dest: address,
    amount: uint,
}

type EthTransferMessage = struct {
    dest: address,
    amount: uint,
}

type TxMessage = struct {
    to: address,
    seqNumber: uint,
    value: uint,
    data: MarshalledBytes,
}

type CallMessage = struct {
    to: address,
    data: MarshalledBytes,
}

type AvmCodeLoadMessage = struct {
    seqNum: uint,
    data: MarshalledBytes,
}

type EvmCodeLoadMessage = struct {
    seqNum: uint,
    data: MarshalledBytes,
    storageInfo: StorageInfo,
}
    
type StorageInfo = struct {
    offset: uint,
    value: uint,
    more: any,
}

public impure func handleEthbridgeMessage(msg: ArbMessage) {
    let msgType = msg.msgType;
    if (msgType == 0) {
        let txMsg = unsafecast<TxMessage>(msg.message);
        let globalAS = getGlobalAccountStore();
        let account = accountStore_get(globalAS, msg.sender);
        if let Some(updatedAcct) = account_checkAndIncrSeqNum(account, txMsg.seqNumber) {
            setGlobalAccountStore(
                accountStore_set(globalAS, msg.sender, updatedAcct),
            );
            handleValidTxMessage(txMsg,);
            panic; //TODO
        } else {
            // sequence number was invalid
            panic; //TODO
        }
    } elseif (msgType == 1) {
        let depMsg = unsafecast<EthTransferMessage>(msg.message);
        let globalAS = getGlobalAccountStore();
        if let Some(newGAS) = accountStore_transferEthBalance(
            globalAS, 
            msg.sender, 
            depMsg.dest, 
            depMsg.amount
        ) {
            setGlobalAccountStore(newGAS,);
            panic; // TODO
        } else {
            panic; //TODO
        }
    } elseif (msgType == 2) {
        let depMsg = unsafecast<TokenTransferMessage>(msg.message);
        panic; // deposit ERC 20
    } elseif (msgType == 3) {
        let depMsg = unsafecast<TokenTransferMessage>(msg.message);
        panic; // deposit ERC 721
    } elseif (msgType == 4) {
        panic; // contract tx call message
    } elseif (msgType == 5) {
        let callMsg = unsafecast<CallMessage>(msg.message);
        panic; // call message
    } elseif (msgType == 6) {
        let codeLoadMsg = unsafecast<AvmCodeLoadMessage>(msg.message);
        let globalAS = getGlobalAccountStore();
        let account = accountStore_get(globalAS, msg.sender);
        if let Some(updatedAcct) = account_checkAndIncrSeqNum(account, codeLoadMsg.seqNum) {
            setGlobalAccountStore(
                accountStore_set(globalAS, msg.sender, updatedAcct),
            );
            let ba = bytearray_unmarshalBytes(codeLoadMsg.data);
            let bs = bytestream_new(ba);
            if let Some(res) = unmarshalCodeSegment(bs) {
                let (initCodePt, callCodePt) = res;
                let initData = initCodePt();
                let (evmPcMap, initStorageMap,) = makeInitStructures(initData);
                callCodePt();
            }
        }
    } elseif (msgType == 7) {
        let codeLoadMsg = unsafecast<EvmCodeLoadMessage>(msg.message);
        let globalAS = getGlobalAccountStore();
        let account = accountStore_get(globalAS, msg.sender);
        if let Some(updatedAcct) = account_checkAndIncrSeqNum(account, codeLoadMsg.seqNum) {
            globalAS = accountStore_set(globalAS, msg.sender, updatedAcct);
            let ba = bytearray_unmarshalBytes(codeLoadMsg.data);
            let bs = bytestream_new(ba);
            if let Some(res) = translateEvmCodeSegment(bs) {
                let (codept, evmJumpTable) = res;
                // address of new contract is derived by hashing of the full message,
                //       then truncating to address size (20 bytes)
                // this is unique on the current chain, 
                //       because it contains sender address and sender seq number
                // also it contains the full EVM code
                let newAddr = address(hash(msg));
                globalAS = accountStore_createAccountFromEvmCode(
                    globalAS,
                    ba,
                    evmJumpTable,
                    codept,
                    makeStorageMap(codeLoadMsg.storageInfo)
                );
            }
            setGlobalAccountStore(globalAS,);
        }
    }
    // if no case matches, unrecognized message type; ignore it
}

func makeStorageMap(storageInfo: StorageInfo) -> map<uint, uint> {
    let ret = newmap<uint, uint>;
    while (null != unsafecast<any>(storageInfo)) {
        ret = ret with { [storageInfo.offset] = storageInfo.value };
        storageInfo = unsafecast<StorageInfo>(storageInfo.more);
    }
    return ret;
}

impure func handleValidTxMessage(txMsg: TxMessage) {
    //TODO
}