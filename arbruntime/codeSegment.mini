//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteStream;

import func bytestream_bytesRemaining(bs: ByteStream) -> uint;
import func bytestream_getByte(bs: ByteStream) -> (bool, ByteStream, uint);
import func bytestream_get64(bs: ByteStream) -> (bool, ByteStream, uint);
import func bytestream_getUint(bs: ByteStream) -> (bool, ByteStream, uint);

import func evm_jumptable_get(slot: uint) -> func();


type AvmCodePoint = func()
type Segment = struct {
    size: uint,
    capacity: uint,
    currentCodePt: AvmCodePoint,
    codePtMap: map<uint, AvmCodePoint>,
}


public func unmarshalCodeSegment(bs: ByteStream) -> (bool, func() -> any, func()) {
    let (success, ubs, numInsns,) = bytestream_getUint(bs);
    if ( ! success) {
        return (false, unsafecast<func()->any>(0), unsafecast<func()>(0),);
    }
    bs = ubs;

    if (bytestream_bytesRemaining(bs) > 1000000) {
        // reject module as too large
        return (false, unsafecast<func()->any>(0), unsafecast<func()>(0),);
    }

    let seg = segment_new(numInsns);
    let twoAgo = unsafecast<func()>(0);
    let oneAgo = unsafecast<func()>(0);
    while (seg.size < seg.capacity) {
        twoAgo = oneAgo;
        oneAgo = seg.currentCodePt;
        let (success, uSeg, ubs,) = parseAndAddInsn(seg, bs);
        if (! success) {
            return (false, unsafecast<func()->any>(0), unsafecast<func()>(0),);
        }
        seg = uSeg;
        bs = ubs;
    }

    seg = segment_close(seg);
    return (
        true, 
        unsafecast<func()->any>(seg.currentCodePt), 
        twoAgo,
    );
}

func parseAndAddInsn(seg: Segment, bs: ByteStream) -> (bool, Segment, ByteStream) {
    let (success, ubs, opcode,) = bytestream_getByte(bs);
    if ( ! success) {
        return (false, seg, bs,);
    }
    bs = ubs;
    if (opcode == 0) {
        return (false, seg, bs,);
    }
    let (success, ubs, isImm,) = bytestream_getByte(bs);
    if ( ! success) {
        return (false, seg, bs,);
    }
    bs = ubs;
    if (isImm == 0) {
        return (
            true, 
            segment_addInsn(seg, opcode, false, 0), 
            bs,
        );
    } else {
        let (success, ubs, val,) = parseAvmValue(bs);
        if ( ! success) {
            return (false, seg, bs,);
        }
        return (
            true, 
            segment_addInsn(seg, opcode, true, val), 
            ubs,
        );
    }
}

func parseAvmValue(bs: ByteStream) -> (bool, ByteStream, any) {
    let (success, ubs, kind,) = bytestream_getByte(bs);
    if ( ! success) {
        return (false, bs, 0,);
    }
    bs = ubs;
    if (kind == 0) {
        // parse and return an int
        let (success, ubs, val,) = bytestream_getUint(bs);
        if (success) {
            return (true, ubs, val,);
        } else {
            return (false, bs, 0,);
        }
    } elseif (kind == 8) {
        // parse and return a codepoint inside the segment, as 64-bit int
        let (success, ubs, val,) = bytestream_get64(bs);
        if (success) {
            return (true, ubs, val,);
        } else {
            return (false, bs, 0,);
        }
    } elseif (kind == 9) {
        // parse and return a codepoint of a runtime call, as byte
        let (success, ubs, val,) = bytestream_getByte(bs);
        if (success) {
            return (true, bs, evm_jumptable_get(val),);
        } else {
            return (false, bs, 0,);
        }
    } elseif (kind >= 16 && kind <= 24) {
        let tup = unsafecast<any>(0);
        if (kind == 16) {
            return (true, bs, (),);
        } elseif(kind == 17) {
            let ret = newfixedarray(1);
            let i = 0;
            while (i < kind-16) {
                let (success, ubs, val,) = parseAvmValue(bs);
                if ( ! success) {
                    return (false, bs, 0,);
                }
                bs = ubs;
                i = i+1;
            }
            return (true, bs, ret,);
        } elseif(kind == 18) {
            let ret = newfixedarray(2);
            let i = 0;
            while (i < kind-16) {
                let (success, ubs, val,) = parseAvmValue(bs);
                if ( ! success) {
                    return (false, bs, 0,);
                }
                bs = ubs;
                i = i+1;
            }
            return (true, bs, ret,); 
        } elseif(kind == 19) {
            let ret = newfixedarray(3);
            let i = 0;
            while (i < kind-16) {
                let (success, ubs, val,) = parseAvmValue(bs);
                if ( ! success) {
                    return (false, bs, 0,);
                }
                bs = ubs;
                i = i+1;
            }
            return (true, bs, ret,);
        } elseif(kind == 20) {
            let ret = newfixedarray(4);
            let i = 0;
            while (i < kind-16) {
                let (success, ubs, val,) = parseAvmValue(bs);
                if ( ! success) {
                    return (false, bs, 0,);
                }
                bs = ubs;
                i = i+1;
            }
            return (true, bs, ret,);  
        } elseif(kind == 21) {
            let ret = newfixedarray(5);
            let i = 0;
            while (i < kind-16) {
                let (success, ubs, val,) = parseAvmValue(bs);
                if ( ! success) {
                    return (false, bs, 0,);
                }
                bs = ubs;
                i = i+1;
            }
            return (true, bs, ret,);  
        } elseif(kind == 22) {
            let ret = newfixedarray(6);
            let i = 0;
            while (i < kind-16) {
                let (success, ubs, val,) = parseAvmValue(bs);
                if ( ! success) {
                    return (false, bs, 0,);
                }
                bs = ubs;
                i = i+1;
            }
            return (true, bs, ret,);   
        } elseif(kind == 23) {
            let ret = newfixedarray(7);
            let i = 0;
            while (i < kind-16) {
                let (success, ubs, val,) = parseAvmValue(bs);
                if ( ! success) {
                    return (false, bs, 0,);
                }
                bs = ubs;
                i = i+1;
            }
            return (true, bs, ret,);  
        } else {   // kind==24 is the only possibility here
            let ret = newfixedarray(8);
            let i = 0;
            while (i < kind-16) {
                let (success, ubs, val,) = parseAvmValue(bs);
                if ( ! success) {
                    return (false, bs, 0,);
                }
                bs = ubs;
                i = i+1;
            }
            return (true, bs, ret,);  
        }
    } else {
        return (false, bs, 0,);
    }
}

func segment_new(capacity: uint) -> Segment {
    return struct {
        size: 1,
        capacity: capacity+1,
        currentCodePt: asm() AvmCodePoint { errcodept },
        codePtMap: newmap<uint, AvmCodePoint>,
    };
}

func segment_addInsn(seg: Segment, opcode: uint, hasImm: bool, imm: any) -> Segment {
    let sizeIn = seg.size;
    let curCodePt = seg.currentCodePt;
    if (hasImm) {
        curCodePt = asm(opcode, imm, seg.currentCodePt) AvmCodePoint { pushinsnimm };
    } else {
        curCodePt = asm(opcode, seg.currentCodePt) AvmCodePoint { pushinsn };
    }
    return seg with { currentCodePt: curCodePt }
               with { size: sizeIn+1 }
               with { codePtMap: seg.codePtMap with { [sizeIn] = curCodePt } };
}

func pushInstruction(code: AvmCodePoint, opcode: uint) -> AvmCodePoint {
    return asm(opcode, code) AvmCodePoint { pushinsn };
}

func pushInstructionImm(code: AvmCodePoint, opcode: uint, val: any) -> AvmCodePoint {
    return asm(opcode, val, code) AvmCodePoint { pushinsnimm };
}

func segment_close(seg: Segment) -> Segment {
    // we might eventually have something to do here
    return seg;
}

type EvmPcStruct = struct {
    rest: any,   // actually an EvmPcStruct, but language doesn't allow recursive types
    evmPc: uint,
    codePt: func(),
}

public func makeEvmPcMap(v: any) -> map<uint, func()> {
    let ret = newmap<uint, func()>;
    let ve = unsafecast<EvmPcStruct>(v);
    while(null != unsafecast<any>(ve)) {
        ret = ret with { [ve.evmPc] = ve.codePt };
        ve = unsafecast<EvmPcStruct>(ve.rest);
    }
    return ret;
}