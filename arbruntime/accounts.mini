//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;

import func bytearray_size(ba: ByteArray) -> uint;
import func tokens_getERC20template() -> address;
import func tokens_getERC721template() -> address;


type AccountStore = map<address, Account>

type Account = struct {
    addr: address,
    nextSeqNum: uint,
    code: option<ByteArray>,
    evmJumpTable: map<uint, func()>,
    codePoint: option<func()>,
    codeHash: bytes32,
    storage: map<uint, uint>,
    ethBalance: uint,
}

var globalAccountStore: AccountStore;   // needs to be initialized before use
var pristineAccount: Account;           // needs to be initialized before use


public impure func accountStore_init() {   // This must be called first!
     if (unsafecast<any>(globalAccountStore) == null) {
        pristineAccount = struct {
            addr: address(0),
            nextSeqNum: 1,
            code: None<ByteArray>,
            evmJumpTable: newmap<uint, func()>,
            codePoint: None<func()>,
            codeHash: bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470),
            storage: newmap<uint, uint>,
            ethBalance: 0,
        };
        globalAccountStore = newmap<address, Account>;
    }   
}

public impure func getGlobalAccountStore() -> AccountStore {
    return globalAccountStore;
}

public impure func setGlobalAccountStore(acctStore: AccountStore) {
    globalAccountStore = acctStore;;
}

public func accountStore_get(acctStore: AccountStore, addr: address) -> Account {
    if let Some(acct) = acctStore[addr] {
        return acct;
    } else {
        return pristineAccount with { addr: addr };
    }
}

public func accountStore_set(
    acctStore: AccountStore, 
    addr: address, 
    acct: Account
) -> AccountStore {
    return acctStore with { [addr] = acct };
}

public func account_isEmpty(acct: Account) -> bool {
    return (acct.nextSeqNum == 1) && (acct.ethBalance == 0) && (acct.code == None<ByteArray>);
}

public func account_checkAndIncrSeqNum(
    account: Account, 
    seqNumRecvd: uint
) -> option<Account> {
    // if seqNumRecvd has the expected value, increment seqNum in account and return true
    // else just return false
    let nextSeq = account.nextSeqNum;
    if (nextSeq == seqNumRecvd) {
        account = account with {
            nextSeqNum: nextSeq+1
        };
        return Some(account);
    } else {
        return None<Account>;
    }
}

public func account_getAddress(account: Account) -> address {
    return account.addr;
}

public func account_getCodePoint(account: Account) -> option<func()> {
    return account.codePoint;
}

public func account_getBalance(account: Account) -> uint {
    return account.ethBalance;
}

public func account_setBalance(account: Account, balance: uint) -> Account {
    return account with { ethBalance: balance };
}

public func account_getEvmJumpTable(account: Account) -> map<uint, func()> {
    return account.evmJumpTable;
}

public func account_fetchAndIncrSeqNum(account: Account) -> (uint, Account) {
    let ret = account.nextSeqNum;
    account = account with {
        nextSeqNum: ret+1
    };
    return (ret, account,);
}

public func accountStore_createAccountFromEvmCode(
    store: AccountStore,
    newAddr: address,
    code: ByteArray,
    evmJumpTable: map<uint, func()>,
    initCodePt: func(),
    storageMap: map<uint, uint>
) -> option<AccountStore> {
    let oldAcct = accountStore_get(store, newAddr);
    if (account_isEmpty(oldAcct)) {
        return Some(accountStore_set(
            store,
            newAddr,
            oldAcct with { code: Some(code) }
                    with { evmJumpTable: evmJumpTable }
                    with { codePoint: Some(initCodePt) }
                    // BUGBUG: need to init codeHash
                    with { storage: storageMap }
                    with { ethBalance: 0 }
        ));
    } else {
        return None<AccountStore>;
    }
}

public func accountStore_createERC20(
    acctStore: AccountStore, 
    addr: address
) -> option<AccountStore> {
    // returns true iff success
    if (account_isEmpty(accountStore_get(acctStore, addr))) {
        acctStore = accountStore_cloneContract(
            acctStore, 
            tokens_getERC20template(), 
            addr
        );
        return Some(acctStore);
    } else {
        return None<AccountStore>;
    }
}

public func accountStore_createERC721(
    acctStore: AccountStore,
    addr: address
) -> option<AccountStore> {
    // returns true iff success
    if (account_isEmpty(accountStore_get(acctStore, addr))) {
        acctStore = accountStore_cloneContract(
            acctStore,
            tokens_getERC721template(), 
            addr
        );
        return Some(acctStore);
    } else {
        return None<AccountStore>;
    }
}

public func accountStore_cloneContract(
    acctStore: AccountStore,
    oldAddr: address, 
    newAddr: address
) -> AccountStore {
    let oldAccount = accountStore_get(acctStore, oldAddr);
    let newAccount = oldAccount with { ethBalance: 0 }
                                with { nextSeqNum: 1 }
                                with { storage: newmap<uint, uint> };
    return acctStore with { [newAddr] = newAccount };
}

public func account_getEthBalance(account: Account) -> uint {
    return account.ethBalance;
}

public func account_setEthBalance(account: Account, newBal: uint) -> Account {
    return account with { ethBalance: newBal };
}

public func account_addToEthBalance(account: Account, addition: uint) -> Account {
    return account with { ethBalance: account.ethBalance + addition };
}

public func account_deductFromEthBalance(account: Account, deduction: uint) -> option<Account> {
    if (account.ethBalance >= deduction) {
        return Some(
            account with { ethBalance: account.ethBalance-deduction }
        );
    } else {
        return None<Account>;
    }
}

// transfer eth; return None if insufficient funds
public func accountStore_transferEthBalance(
    acctStore: AccountStore,
    from: address, 
    to: address, 
    amount: uint
) -> option<AccountStore> {
    let fromAcct = accountStore_get(acctStore, from);
    if (fromAcct.ethBalance < amount) {
        return None<AccountStore>;
    }
    let toAcct = accountStore_get(acctStore, to);
    acctStore = acctStore 
        with { [from] = fromAcct with { ethBalance: fromAcct.ethBalance - amount }}
        with { [to] = fromAcct with { ethBalance: toAcct.ethBalance + amount }};
    return Some(acctStore);
}

public func account_getAllStorage(account: Account) -> map<uint, uint> {
    return account.storage;
}

public func account_getStorageCell(account: Account, cell: uint) -> uint {
    if let Some(contents) = account.storage[cell] {
        return contents;
    } else {
        return 0;
    }
}

public func account_setStorageCell(
    account: Account, 
    cell: uint, 
    value: uint
) -> Account {
    return account with {
        storage: account.storage with {
            [cell] = value
        }
    };
}

public func account_getCodeSize(acct: Account) -> uint {
    if let Some(code) = acct.code {
        return bytearray_size(code);
    } else {
        return 0;
    }
}

public func account_getCode(acct: Account) -> option<ByteArray> {
    return acct.code;
}