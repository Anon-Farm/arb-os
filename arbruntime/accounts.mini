//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import func tokens_getERC20template() -> address;
import func tokens_getERC721template() -> address;

type Account = struct {
    nextSeqNum: uint,
    code: ByteArray,
    codePoint: func(),  
    codeSize: uint,
    codeHash: bytes32,
    storage: map<uint, uint>,
    ethBalance: uint,
}

var accountStore: map<address, Account>;   // needs to be initialized before use
var pristineAccount: Account;              // needs to be initialized before use


impure func get_account(addr: address) -> Account {
    if (unsafecast<any>(accountStore) == null) {
        pristineAccount = struct {
            nextSeqNum: 1,
            code: unsafecast<ByteArray>(null),
            codePoint: unsafecast<func()>(null),
            codeSize: 0,
            codeHash: bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470),
            storage: newmap<uint, uint>,
            ethBalance: 0,
        };
        accountStore = newmap<address, Account>;
    }
    let (acct, exists,) = accountStore[addr];
    if (exists) {
        return acct;
    } else {
        return pristineAccount;
    }
}

public func account_isEmpty(acct: Account) -> bool {
    return (acct.nextSeqNum == 0) && (acct.ethBalance == 0) && (acct.codeSize == 0);
}

public impure func account_checkAndIncrSeqNum(addr: address, seqNumRecvd: uint) -> bool {
    // if seqNumRecvd has the expected value, increment seqNum in account and return true
    // else just return false
    let account = get_account(addr);
    let nextSeq = account.nextSeqNum;
    if (nextSeq == seqNumRecvd) {
        accountStore = accountStore with {
            [addr] = account with {
                nextSeqNum: nextSeq+1
            }
        };
        return true;
    } else {
        return false;
    }
}

public impure func account_fetchAndIncrSeqNum(addr: address) -> uint {
    let account = get_account(addr);
    let ret = account.nextSeqNum;
    accountStore = accountStore with {
        [addr] = account with {
            nextSeqNum: ret+1
        }
    };
    return ret;
}

public impure func createERC20(addr: address) -> bool {
    // returns true iff success
    if (account_isEmpty(get_account(addr))) {
        cloneContract(tokens_getERC20template(), addr);
        return true;
    } else {
        return false;
    }
}

public impure func createERC721(addr: address) -> bool {
    // returns true iff success
    if (account_isEmpty(get_account(addr))) {
        cloneContract(tokens_getERC721template(), addr);
        return true;
    } else {
        return false;
    }
}

public impure func cloneContract(oldAddr: address, newAddr: address) {
    let oldAccount = get_account(oldAddr);
    let newAccount = oldAccount with { ethBalance: 0 }
                                with { nextSeqNum: 1 }
                                with { storage: newmap<uint, uint> };
    accountStore = accountStore with { [newAddr] = newAccount };
}

public impure func account_getEthBalance(addr: address) -> uint {
    return get_account(addr).ethBalance;
}

public impure func account_setEthBalance(addr: address, newBal: uint) {
    accountStore = accountStore with { 
        [addr] = get_account(addr) with { 
            ethBalance: newBal 
        } 
    };
}

public impure func account_addToEthBalance(addr: address, addition: uint) {
    let account = get_account(addr);
    accountStore = accountStore with {
        [addr] = account with {
            ethBalance: account.ethBalance + addition
        }
    };
}

// transfer eth; return true if transfer happened, or false if insufficient funds
public impure func account_transferEthBalance(from: address, to:address, amount: uint) -> bool {
    let fromAcct = get_account(from);
    if (fromAcct.ethBalance < amount) {
        return false;
    }
    let toAcct = get_account(to);
    accountStore = accountStore with { [from] = fromAcct with { ethBalance: fromAcct.ethBalance - amount }}
                                with { [to] = fromAcct with { ethBalance: toAcct.ethBalance + amount }};
    return true;
}

public impure func account_getAllStorage(addr: address) -> map<uint, uint> {
    return get_account(addr).storage;
}

public impure func account_getStorageCell(addr: address, cell: uint) -> uint {
    let (contents, exists,) = get_account(addr).storage[cell];
    if (exists) {
        return contents;
    } else {
        return 0;
    }
}

public impure func account_setStorageCell(addr: address, cell: uint, value: uint) {
    let myAccount = get_account(addr);
    accountStore = accountStore with {
        [addr] = myAccount with {
            storage: myAccount.storage with {
                [cell] = value
            }
        }
    };
}
