//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type Account;
import type EvmCallFrame;
import type EvmLogs;
import type ByteArray;
import type Queue;

import impure func evmCallStack_currentFrame() -> option<EvmCallFrame>;
import impure func evmCallStack_getCurrentFrameMemoryOrDie() -> ByteArray;
import impure func evmCallStack_setCurrentFrameMemory(mem: ByteArray) -> bool;
import impure func evmCallStack_setCurrentFrameStorageCell(addr: address, offset: uint, val: uint) -> bool;
import impure func evmCallStack_selfDestructCurrentAccount(owner: address);
import impure func evmCallStack_pop(status: uint, returnData: ByteArray) -> option<EvmCallFrame>;

import func evmCallFrame_currentAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_getAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_getMemory(frame: EvmCallFrame) -> ByteArray;
import func evmCallFrame_getResumeCodePoint(frame: EvmCallFrame) -> option<func()>;
import func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint;
import func evmCallFrame_getCalldata(frame: EvmCallFrame) -> ByteArray;
import func evmCallFrame_getEvmLogs(frame: EvmCallFrame) -> EvmLogs;
import func evmCallFrame_getSelfDestructQueue(frame: EvmCallFrame) -> Queue;

import func account_getAddress(acct: Account) -> address;
import func account_getCodeSize(acct: Account) -> uint;
import func account_getBalance(acct: Account) -> uint;
import func account_getCode(acct: Account) -> ByteArray;
import func account_getStorageCell(acct: Account, offset: uint) -> option<uint>;
import func account_getEvmJumpTable(acct: Account) -> option<map<uint, func()>>;

import impure func inbox_currentTimestamp() -> uint;
import impure func inbox_currentBlockNumber() -> uint;

import func messages_callFinished(status: uint, returndata: ByteArray, logs: EvmLogs);

import func evmlogs_empty() -> EvmLogs;

import func bytearray_new(capacity: uint, autoExpand: bool) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> option<uint>;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> option<ByteArray>;
import func bytearray_get256(ba: ByteArray, offset: uint) -> option<uint>;
import func bytearray_set256(ba: ByteArray, offset: uint, val: uint) -> option<ByteArray>;
import func bytearray_copy(from: ByteArray, fromOffset: uint, to: ByteArray, toOffset: uint, nbytes: uint) -> option<ByteArray>;

import func queue_isEmpty(q: Queue) -> bool;
import func queue_get(q: Queue) -> (Queue, any);

import func keccak256(array: ByteArray, offset: uint, nbytes: uint) -> bytes32;


public func evmOp_stop() {
    evm_notYetImplemented(1,);
}

public func evmOp_sha3(baseMemAddr: uint, nbytes: uint) -> bytes32 {
    return keccak256(evmCallStack_getCurrentFrameMemoryOrDie(), baseMemAddr, nbytes);
}

public func evmOp_address() -> address {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return account_getAddress(
            evmCallFrame_currentAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return address(0);
    }
}

public func evmOp_balance(addr: address) -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return account_getBalance(
            evmCallFrame_getAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}
    
public func evmOp_origin() -> address {
    evm_notYetImplemented(2,);
    return address(0);
}
    
public func evmOp_caller() -> address {
    evm_notYetImplemented(3,);
    return address(0);
}

public func evmOp_callvalue() -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return evmCallFrame_getCallvalue(topFrame);
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public func evmOp_calldataload(offset: uint) -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if let Some(val) = bytearray_get256(evmCallFrame_getCalldata(topFrame), offset) {
            return val;
        }
    }

    evm_runtimePanic();
    return 0;
}

public func evmOp_calldatasize() -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return bytearray_size(evmCallFrame_getCalldata(topFrame));
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public func evmOp_calldatacopy(memAddr: uint, calldataOffset: uint, nbytes: uint) {
    evm_notYetImplemented(4,);
}

public impure func evmOp_codesize() -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return account_getCodeSize(
            evmCallFrame_currentAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_codecopy(memAddr: uint, codeOffset: uint, nbytes: uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        if let Some(updatedMemory) = bytearray_copy(
            account_getCode(
                evmCallFrame_currentAccount(topFrame)
            ),
            codeOffset,
            memory,
            memAddr,
            nbytes
        ) {
            if (evmCallStack_setCurrentFrameMemory(updatedMemory,)) {
                return;
            }
        }
    }

    evm_runtimePanic();
}

public func evmOp_extcodesize(addr: address) -> uint {
    evm_notYetImplemented(5,);
    return 0;
}

public func evmOp_extcodecopy(addr: address, memAddr: uint, codeOffset: uint, nbytes: uint) {
    evm_notYetImplemented(6,);
}

public func evmOp_returndatasize() -> uint {
    evm_notYetImplemented(7,);
    return 0;
}

public func evmOp_returndatacopy(memAddr: uint, dataOffset: uint, nbytes: uint) {
    evm_notYetImplemented(8,);
}

public impure func evmOp_timestamp() -> uint {
    return inbox_currentTimestamp();
}

public func evmOp_number() -> uint {
    return inbox_currentBlockNumber();
}

public impure func evmOp_mload(memAddr: uint) -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if let Some(val) = bytearray_get256(
            evmCallFrame_getMemory(topFrame),
            memAddr
        ) {
            return val;
        }
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_mstore(memAddr: uint, value: uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if let Some(memory) = bytearray_set256(
            evmCallFrame_getMemory(topFrame),
            memAddr,
            value
        ) {
            if (evmCallStack_setCurrentFrameMemory(memory)) {
                return;
            }
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_mstore8(memAddr: uint, value:uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if let Some(memory) = bytearray_setByte(
            evmCallFrame_getMemory(topFrame),
            memAddr,
            value
        ) {
            if (evmCallStack_setCurrentFrameMemory(memory)) {
                return;
            }
        }
    }

    evm_runtimePanic();
}
    
public impure func evmOp_sload(storageAddr: uint) -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if let Some(val) = account_getStorageCell(
            evmCallFrame_currentAccount(topFrame),
            storageAddr
        ) {
            return val;
        }
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_sstore(storageAddr: uint, value: uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if ( ! evmCallStack_setCurrentFrameStorageCell(
            account_getAddress(
                evmCallFrame_currentAccount(topFrame)
            ),
            storageAddr,
            value
        )) {
            evm_runtimePanic();
        }
    } else {
        evm_runtimePanic();
    }
}
    
public func evmOp_getjumpaddr(evm_pc: uint) -> func() {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        let theTable = account_getEvmJumpTable(
            evmCallFrame_currentAccount(topFrame)
        );
        if let Some(jumpTable) = account_getEvmJumpTable(
            evmCallFrame_currentAccount(topFrame)
        ) {
            if let Some(codePt) = account_getEvmJumpTable(
                evmCallFrame_currentAccount(topFrame)
            ) {
                if let Some(codept) = jumpTable[evm_pc] {
                    return codept;
                } else {
                    evm_error();   // EVM code tried to jump to a forbidden code address
                    panic;
                }
            }
        }
    }

    evm_runtimePanic();
    panic;
}

public func evmOp_msize() -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return bytearray_size(
            evmCallFrame_getMemory(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public func evmOp_log0(
    memAddr: uint, 
    nbytes: uint
) {
    evm_notYetImplemented(9,);
}

public func evmOp_log1(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint
) {
    evm_notYetImplemented(10,);
}

public func evmOp_log2(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
) {
    evm_notYetImplemented(11,);
}

public func evmOp_log3(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
    topic2: uint,
) {
    evm_notYetImplemented(12,);
}

public func evmOp_log4(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
    topic2: uint,
    topic3: uint,
) {
    evm_notYetImplemented(13,);
}

public func evmOp_sloadbytes() {
    //BUGBUG: don't know type signature of this one
    evm_notYetImplemented(14,);
}

public func evmOp_sstorebytes() {
    //BUGBUG: don't know type signature of this one
    evm_notYetImplemented(15,);
}

public func evmOp_ssize() {
    //BUGBUG: don't know type signature of this one
    evm_notYetImplemented(16,);
}

public func evmOp_call(
    gas: uint,
    callee: address,
    balance: uint,
    inMemOffset: uint,
    inNbytes: uint,
    outMemOffset: uint,
    outMemSize: uint
) -> bool {
    evm_notYetImplemented(17,);
    return false;
}

public func evmOp_callcode(
    gas: uint,
    callee: address,
    balance: uint,
    inMemOffset: uint,
    inNbytes: uint,
    outMemOffset: uint,
    outMemSize: uint
) -> bool {
    evm_notYetImplemented(18,);
    return false;
}

public func evmOp_delegatecall(
    gas: uint,
    callee: address,
    inMemOffset: uint,
    inNbytes: uint,
    outMemOffset: uint,
    outMemSize: uint
) -> bool {
    evm_notYetImplemented(19,);
    return false;
}

public func evmOp_staticcall(
    gas: uint,
    callee: address,
    inMemOffset: uint,
    inNbytes: uint,
    outMemOffset: uint,
    outMemSize: uint
) -> bool {
    evm_notYetImplemented(20,);
    return false;
}

public func evmOp_revert(memOffset: uint, memNbytes: uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        if let Some(returnData) = bytearray_copy(
            memory,
            memOffset,
            bytearray_new(0, true),
            0,
            memNbytes
        ) {
            if let Some(newTopFrame) = evmCallStack_pop(0, returnData) {
                // return control to evm caller
                if let Some(evmTargetCodept) = evmCallFrame_getResumeCodePoint(newTopFrame) {
                    // replace the return address on our stack with evmTargetCodept
                    asm(evmTargetCodept,) {
                        auxpop
                        auxpop
                        swap2
                        auxpush
                        auxpush
                        pop
                    };
                    // now return, which will throw control to evmTargetCodept
                    return;
                }
            } else {
                // top-level call finished
                messages_callFinished(
                    0,
                    returnData,
                    evmlogs_empty()
                );  // this should never return
                panic;
            }
        }
    }

    evm_runtimePanic();
}

public func evmOp_return(memOffset: uint, memNbytes: uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        if let Some(returnData) = bytearray_copy(
            memory,
            memOffset,
            bytearray_new(memNbytes, true),
            0,
            memNbytes
        ) {
            if let Some(newTopFrame) = evmCallStack_pop(0, returnData) {
                // copy the relevant state back to the parent frame
                evm_notYetImplemented(22,);
                return;
            } else {
                // top-level call finished
                let selfDestructQueue = evmCallFrame_getSelfDestructQueue(topFrame);
                while ( ! queue_isEmpty(selfDestructQueue)) {
                    let (q, item,) = queue_get(selfDestructQueue);
                    selfDestructQueue = q;
                    let (addr, owner,) = unsafecast<(address, address)>(item);
                    //BUGBUG: destroy addr, send addr's funds to owner
                }
                messages_callFinished(
                    1,
                    returnData,
                    evmCallFrame_getEvmLogs(topFrame),
                );  // this should never return
                panic;
            }
        }
    }

    evm_runtimePanic();
}

public func evmOp_txexecgas() {
    //BUGBUG: don't know the type signature of this one
    evm_notYetImplemented(23,);
}

public func evmOp_selfdestruct(owner: address) {
    evmCallStack_selfDestructCurrentAccount(owner,);
}

func evm_error() {
    // This should be called when EVM code has generated an EVM error.
    evmOp_revert(0, 0);  // should never return
    panic;
}

func evm_runtimePanic() {
    // This should be called when something that "shouldn't ever happen" has occurred.
    // It should only be called if something has gone wrong in the trusted code.
    // If untrusted code has encountered an error, that will be handled elsewhere.
    panic;
}

func evm_notYetImplemented(op: uint) {
    asm((66, op),) { debugprint };
    panic;
}
