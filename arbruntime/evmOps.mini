//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type Account;
import type EvmCallFrame;
import type ByteArray;

import impure func evmCallStack_currentFrame() -> option<EvmCallFrame>;
import impure func evmCallStack_setCurrentFrameMemory(mem: ByteArray) -> bool;
import impure func evmCallStack_setCurrentFrameStorageCell(addr: address, offset: uint, val: uint) -> bool;

import func evmCallFrame_currentAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_getAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_getMemory(frame: EvmCallFrame) -> ByteArray;
import func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint;
import impure func selfDestructQueue_put(victim: address, owner: address);

import func account_getAddress(acct: Account) -> address;
import func account_getCodeSize(acct: Account) -> uint;
import func account_getBalance(acct: Account) -> uint;
import func account_getCode(acct: Account) -> ByteArray;
import func account_getStorageCell(acct: Account, offset: uint) -> uint;
import func account_getEvmJumpTable(acct: Account) -> map<uint, func()>;

import impure func inbox_currentTimestamp() -> uint;
import impure func inbox_currentBlockNumber() -> uint;

import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set256(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_copy(from: ByteArray, fromOffset: uint, to: ByteArray, toOffset: uint, nbytes: uint) -> ByteArray;

import func keccak256(array: ByteArray, offset: uint, nbytes: uint) -> bytes32;


public func evmOp_stop() {
    panic; //TODO
}

public func evmOp_sha3(baseMemAddr: uint, nbytes: uint) -> bytes32 {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        return keccak256(memory, baseMemAddr, nbytes);
    } else {
        evm_runtimePanic();
        return bytes32(0);
    }
}

public func evmOp_address() -> address {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return account_getAddress(
            evmCallFrame_currentAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return address(0);
    }
}

public func evmOp_balance(addr: address) -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return account_getBalance(
            evmCallFrame_getAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}
    
public func evmOp_origin() -> address {
    panic; //TODO
}
    
public func evmOp_caller() -> address {
    panic; //TODO
}

public func evmOp_callvalue() -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return evmCallFrame_getCallvalue(topFrame);
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public func evmOp_calldataload(offset: uint) -> uint {
    panic; //TODO
}

public func evmOp_calldatasize() -> uint {
    panic; //TODO
}

public func evmOp_calldatacopy(memAddr: uint, calldataOffset: uint, nbytes: uint) {
    panic; //TODO
}

public impure func evmOp_codesize() -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return account_getCodeSize(
            evmCallFrame_currentAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_codecopy(memAddr: uint, codeOffset: uint, nbytes: uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        memory = bytearray_copy(
            account_getCode(
                evmCallFrame_currentAccount(topFrame)
            ),
            codeOffset,
            memory,
            memAddr,
            nbytes
        );
        if ( ! evmCallStack_setCurrentFrameMemory(memory,)) {
            evm_runtimePanic();
        }
    } else {
        evm_runtimePanic();
    }
}

public func evmOp_extcodesize(addr: address) -> uint {
    panic; //TODO
}

public func evmOp_extcodecopy(addr: address, memAddr: uint, codeOffset: uint, nbytes: uint) {
    panic; //TODO
}

public func evmOp_returndatasize() -> uint {
    panic; //TODO
}

public func evmOp_returndatacopy(memAddr: uint, dataOffset: uint, nbytes: uint) {
    panic; //TODO
}

public impure func evmOp_timestamp() -> uint {
    return inbox_currentTimestamp();
}

public func evmOp_number() -> uint {
    return inbox_currentBlockNumber();
}

public impure func evmOp_mload(memAddr: uint) -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return bytearray_get256(
            evmCallFrame_getMemory(topFrame),
            memAddr
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_mstore(memAddr: uint, value: uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if ( ! evmCallStack_setCurrentFrameMemory(
            bytearray_set256(
                evmCallFrame_getMemory(topFrame),
                memAddr,
                value
            ),
        )) {
            evm_runtimePanic();
        }
    } else {
        evm_runtimePanic();
    }
}

public impure func evmOp_mstore8(memAddr: uint, value:uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if ( ! evmCallStack_setCurrentFrameMemory(
            bytearray_setByte(
                evmCallFrame_getMemory(topFrame),
                memAddr,
                value
            ),
        )) {
            evm_runtimePanic();
        }
    } else {
        evm_runtimePanic();
    }
}
    
public impure func evmOp_sload(storageAddr: uint) -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return account_getStorageCell(
            evmCallFrame_currentAccount(topFrame),
            storageAddr
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_sstore(storageAddr: uint, value: uint) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if ( ! evmCallStack_setCurrentFrameStorageCell(
            account_getAddress(
                evmCallFrame_currentAccount(topFrame)
            ),
            storageAddr,
            value
        )) {
            evm_runtimePanic();
        }
    } else {
        evm_runtimePanic();
    }
}
    
public func evmOp_getjumpaddr(evm_pc: uint) -> func() {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        if let Some(codePt) = account_getEvmJumpTable(
            evmCallFrame_currentAccount(topFrame)
        )[evm_pc] {
            return codePt;
        } else {
            evm_error();   // EVM code tried to jump to a forbidden code address
            panic;
        }
    } else {
        evm_runtimePanic();
        panic;             // there is no safe value to return here, so better to panic
    }
}

public func evmOp_msize() -> uint {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        return bytearray_size(
            evmCallFrame_getMemory(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public func evmOp_log0(
    memAddr: uint, 
    nbytes: uint
) {
    panic; //TODO
}

public func evmOp_log1(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint
) {
    panic; //TODO
}

public func evmOp_log2(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
) {
    panic; //TODO
}

public func evmOp_log3(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
    topic2: uint,
) {
    panic; //TODO
}

public func evmOp_log4(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
    topic2: uint,
    topic3: uint,
) {
    panic; //TODO
}

public func evmOp_sloadbytes() {
    //BUGBUG: don't know type signature of this one 
    panic; //TODO
}

public func evmOp_sstorebytes() {
    //BUGBUG: don't know type signature of this one 
    panic; //TODO
}

public func evmOp_ssize() {
    //BUGBUG: don't know type signature of this one 
    panic; //TODO
}

public func evmOp_call(
    gas: uint,
    callee: address,
    balance: uint,
    inMemOffset: uint,
    inNbytes: uint,
    outMemOffset: uint,
    outMemSize: uint
) -> bool {
    panic; //TODO
}

public func evmOp_callcode(
    gas: uint,
    callee: address,
    balance: uint,
    inMemOffset: uint,
    inNbytes: uint,
    outMemOffset: uint,
    outMemSize: uint
) -> bool {
    panic; //TODO
}

public func evmOp_delegatecall(
    gas: uint,
    callee: address,
    inMemOffset: uint,
    inNbytes: uint,
    outMemOffset: uint,
    outMemSize: uint
) -> bool {
    panic; //TODO
}

public func evmOp_staticcall(
    gas: uint,
    callee: address,
    inMemOffset: uint,
    inNbytes: uint,
    outMemOffset: uint,
    outMemSize: uint
) -> bool {
    panic; //TODO
}

public func evmOp_revert(memOffset: uint, memNbytes: uint) {
    panic; //TODO
}

public func evmOp_return(memOffset: uint, memNbytes: uint) {
    panic; //TODO
}

public func evmOp_txexecgas() {
    //BUGBUG: don't know the type signature of this one 
    panic; //TODO
}

public func evmOp_selfdestruct(owner: address) {
    if let Some(topFrame) = evmCallStack_currentFrame() {
        selfDestructQueue_put(
            account_getAddress(
                evmCallFrame_currentAccount(topFrame)
            ),
            owner
        );
    } else {
        evm_runtimePanic();
    }
}

func evm_error() {
    // This should be called when EVM code has generated an EVM error.
    // We'll revert the transaction per the EVM spec.
    panic;  //BUGBUG
}

func evm_runtimePanic() {
    // This should be called when something that "shouldn't ever happen" has occurred.
    // It should only be called if something has gone wrong in the trusted code.
    // If untrusted code has encountered an error, that will be handled elsewhere.
    panic;
}
