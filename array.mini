
type block = [8]anytype

type array = struct {
	size: uint,
	topstep: uint,
	contents: block,
}

func main() anytype {
	let arr = builtin_arrayNew(13, null);
	return arr;
}

public func builtin_arraySize(arr: array) uint {
	return arr.size;
}

public func builtin_arrayNew(sz: uint, base_val: anytype) array {
	let chunk = 1;
	let height = 1;
	while ((chunk*8) < sz) {
		chunk = 8*chunk;
		height = 1+height;
	}
	let tup = buildTree(height, base_val);
	return struct {
		size: sz,
		topstep: chunk,
		contents: tup,
	};
}

func buildTree(height: uint, base_val: anytype) block {
	if (height == 1) {
		return newfixedarray(8, base_val);
	} else {
		let res = buildTree(height-1, base_val);
		return newfixedarray(8, res);
	}
}

public func builtin_arrayGet(arr: array, index: uint) anytype {
	if (index >= arr.size) {
		panic;
	}
	let res = arr.contents;
	let chunk = arr.topstep;
	while (chunk >= 1) {
		let slot = index / chunk;
		index = index % chunk;
		res = unsafecast(res[slot], block);
		chunk = chunk / 8;
	}
	return res;
}

public func builtin_arraySet(arr: array, index: uint, value: anytype) array {
	if (index >= arr.size) {
		panic;
	}
	return arr with { contents: arraySet2(arr.contents, arr.topstep, index, value) };
}

func arraySet2(b: block, chunk: uint, index: uint, value: anytype) block {
	if (chunk == 1) {
		return b with {[index] = value};
	} else {
		return b with {[index/chunk] = arraySet2(
			unsafecast(b[index/chunk], block), 
			chunk/8, 
			index%chunk, 
			value
		)};
	}
}

public func builtin_arraySwap(a: array, index: uint, value: anytype) (array, anytype) {
	if (index >= a.size) {
		panic;
	}
	let sub = arraySwap2(a.contents, a.topstep, index, value);
	return (
		a with { contents: sub.bloc },
		sub.val,
	);
}

type arraySwapSubResult = struct {
	bloc: block,
	val:  anytype,
}

func arraySwap2(b: block, chunk: uint, index: uint, value: anytype)  arraySwapSubResult {
	if (chunk == 1) {
		let v = b[index];
		return struct {
			bloc: b with {[index] = value},
			val: v,
		};
	} else {
		let sub = arraySwap2(
			unsafecast(b[index/chunk], block),
			chunk/8,
			index%chunk,
			value
		);
		return sub with { bloc: b with {[index/chunk] = sub.bloc} };
	}
}
