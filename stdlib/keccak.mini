//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import func bytearray_new(size: uint, variableSize: bool) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set256(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_get64(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set64(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_copy(src: ByteArray, srcOffset: uint, dest: ByteArray, destOffset: uint, nbytes: uint) -> ByteArray;


public func keccak256(ba: ByteArray, offset: uint, nbytes: uint) -> bytes32 {
    let accumulator = newfixedarray(25, 0);
    while (nbytes >= 136) {
        // process a full block
        accumulator = keccak_permutation(
            keccak_xorblock(accumulator, ba, offset)
        );
        offset = offset+136;
        nbytes = nbytes-136;
    }

    // finish the last block, with padding
    // approach is to build a bytearray to hold this block
    let lastBlock = bytearray_new(136, false);
    lastBlock = bytearray_copy(ba, offset, lastBlock, 0, nbytes);
    if (nbytes == 135) {
        // add one byte of padding
        lastBlock = bytearray_setByte(lastBlock, 135, 0x86);
    } else {
        // add nbytes of padding
        // take advantage of the fact that lastBlock is already zero-filled
        lastBlock = bytearray_setByte(
            bytearray_setByte(lastBlock, 135, 0x06),
            nbytes,
            0x80
        );
    }
    accumulator = keccak_permutation(
        keccak_xorblock(accumulator, lastBlock, 0)
    );

    return bytes32(
        accumulator[0] + 10000000000000000 * (
            accumulator[1] + 0x10000000000000000 * (
                accumulator[2] + 0x10000000000000000 * accumulator[3]
            )
        )
    );
}

func keccak_xorblock(accumulator: [25]uint, ba: ByteArray, offset: uint) -> [25]uint {
    let i = 0;
    while (i < 4) {
        let word = bytearray_get256(ba, offset+32*i);
        accumulator = accumulator 
            with { [4*i] = accumulator[4*i] ^ (word & 0xffffffffffffffff) }
            with { [4*i+1] = accumulator[4*i+1] ^ ((word/0x10000000000000000) & 0xffffffffffffffff) }
            with { [4*i+2] = accumulator[4*i+2] ^ ((word/0x100000000000000000000000000000000) & 0xffffffffffffffff) }
            with { [4*i+3] = accumulator[4*i+3] ^ ((word/0x1000000000000000000000000000000000000000000000000) & 0xffffffffffffffff) };
        i = i+1;
    }
    return accumulator with { [24] = accumulator[24] ^ bytearray_get64(ba, offset+128) };
}

var keccakConstants: struct {
    rndc: [24]uint,
    piln: [24]uint,
};

// keccak permutation function
// input and out are 1600-bit values, broken into 64-bit chunks
func keccak_permutation(s: [25]uint) -> [25]uint {
    if (null == unsafecast<any>(keccakConstants)) {
        initKeccakConstants();
    }
    let round = 0;
    let keccak_rotc = 1;
    while (round < 24) {
        // theta
        let bc = newfixedarray(5, 0);
        let i = 0;
        while (i < 5) {
            bc = bc with { [i] = s[i]^s[i+5]^s[i+10]^s[i+15]^s[i+20] };
            i = i+1;
        }
        i = 0;
        while (i < 5) {
            let t = bc[(i + 4) % 5] + sha3_rotl64(bc[(i + 1) % 5], 1);
            i = i+1;
            let j = 0;
            while (j < 25) {
                s = s with { [j+i] = s[j+i]^t };
                j = j+5;
            }
        }

        // rho pi
        let t = s[1];
        i = 0;
        while (i < 24) {
            let j = keccakConstants.piln[i];
            bc = bc with { [0] = s[j] };
            s = s with { [j] = sha3_rotl64(t, keccak_rotc) };
            t = bc[0];
            i = i+1;
        }

        // chi
        let j = 0;
        while (j < 25) {
            i = 0;
            while (i < 5) {
                bc = bc with { [i] = s[j+i] };
                i = i+1;
            }
            i = 0;
            while (i < 5) {
                t = (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
                s = s with { [j+i] = s[j+i]^t };
                i = i+1;
            }
            j = j+5;
        }

        // iota
        s = s with { [0] = s[0]^keccakConstants.rndc[round] };

        keccak_rotc = (keccak_rotc+round+2) % 64;        
        round = round+1;
    }

    return s;
}

func sha3_rotl64(x: uint, y: uint) -> uint {
    return (
        (x * (asm(2, y) uint { exp })) |
        (x / (asm(2, 64-y) uint { exp }))
    ) & 0xffffffffffffffff;
}

impure func initKeccakConstants() {
    keccakConstants = struct {
        rndc: newfixedarray(24, 0) 
            with { [0] = 0x0000000000000001 }
            with { [1] = 0x0000000000008082 }
            with { [2] = 0x800000000000808a }
            with { [3] = 0x8000000080008000 }
            with { [4] = 0x000000000000808b }
            with { [5] = 0x0000000080000001 }
            with { [6] = 0x8000000080008081 }
            with { [7] = 0x8000000000008009 }
            with { [8] = 0x000000000000008a }
            with { [9] = 0x0000000000000088 }
            with { [10] = 0x0000000080008009 }
            with { [11] = 0x000000008000000a }
            with { [12] = 0x000000008000808b }
            with { [13] = 0x800000000000008b }
            with { [14] = 0x8000000000008089 }
            with { [15] = 0x8000000000008003 }
            with { [16] = 0x8000000000008002 }
            with { [17] = 0x8000000000000080 }
            with { [18] = 0x000000000000800a }
            with { [19] = 0x800000008000000a }
            with { [20] = 0x8000000080008081 }
            with { [21] = 0x8000000000008080 }
            with { [22] = 0x0000000080000001 }
            with { [23] = 0x8000000080008008 },
        piln: newfixedarray(24, 0) 
            with { [0] = 10 }
            with { [1] = 7 }
            with { [2] = 11 }
            with { [3] = 17 }
            with { [4] = 18 }
            with { [5] = 3 }
            with { [6] = 5 }
            with { [7] = 16 }
            with { [8] =  8 }
            with { [9] = 21 } 
            with { [10] = 24 }
            with { [11] = 4 }
            with { [12] = 15 }
            with { [13] = 23 }
            with { [14] = 19 }
            with { [15] = 13 }
            with { [16] = 12 }
            with { [17] = 2 }
            with { [18] = 20 }
            with { [19] = 14 }
            with { [20] = 22 }
            with { [21] = 9 }
            with { [22] = 6 }
            with { [23] = 1 },
    };      
}