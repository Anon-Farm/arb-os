//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import func bytearray_new(size: uint) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set256(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_get64(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set64(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_copy(src: ByteArray, srcOffset: uint, dest: ByteArray, destOffset: uint, nbytes: uint) -> ByteArray;



public func keccak256(ba: ByteArray, offset: uint, nbytes: uint) -> bytes32 {
    if (nbytes == 32) {
        return hash(bytearray_get256(ba, offset));
    }
    if (nbytes == 64) {
        return hash(
            bytes32(bytearray_get256(ba, offset)),
            bytes32(bytearray_get256(ba, offset+32))
        );
    }

    let accumulator = unsafecast<[7]uint>((0,0,0,0,0,0,0));

    // Process as many complete 136-byte blocks as we can
    while (nbytes >= 136) {
        // Process one complete block
        accumulator = asm(keccak_xorblock(accumulator, ba, offset),) [7]uint { keccakf };
        offset = offset+136;
        nbytes = nbytes-136;
    }

    // Build a bytearray to hold the final block
    let lastBlock = bytearray_new(136);
    lastBlock = bytearray_copy(ba, offset, lastBlock, 0, nbytes);

    // Add padding to fill the final block
    if (nbytes == 135) {
        // only one byte of padding needed
        lastBlock = bytearray_setByte(lastBlock, 135, 0x81);
    } else {
        // padding is 0x01 0x00* 0x80
        // take advantage of the fact that lastBlock is already zero-filled
        lastBlock = bytearray_setByte(
            bytearray_setByte(lastBlock, 135, 0x80),
            nbytes,
            0x01
        );
    }

    // Process the final block
    accumulator = asm(keccak_xorblock(accumulator, lastBlock, 0),) [7]uint { keccakf };

    // Extract the return value, with properly adjusted endianness
    return bytes32(flipEndian256(accumulator[0]));
}

func keccak_xorblock(accumulator: [7]uint, ba: ByteArray, offset: uint) -> [7]uint {
    return accumulator with {
        [0] = accumulator[0] ^ flipEndian256(bytearray_get256(ba, offset))
    } with {
        [1] = accumulator[1] ^ flipEndian256(bytearray_get256(ba, offset+32))
    } with {
        [2] = accumulator[2] ^ flipEndian256(bytearray_get256(ba, offset+32*2))
    } with {
        [3] = accumulator[3] ^ flipEndian256(bytearray_get256(ba, offset+32*3))
    } with {
        [4] = accumulator[4] ^ flipEndian64(bytearray_get64(ba, offset+32*4))
    };
}

public func keccak_permutation(s: [7]uint) -> [7]uint {
    return asm(s,) [7]uint { keccakf };
}

func flipEndian64(x: uint) -> uint {
    x = ((x & 0xffffffff) * 0x100000000) | ((x / 0x100000000) & 0xffffffff);
    x = ((x & 0xffff0000ffff) * 0x10000) | ((x / 0x10000) & 0xffff0000ffff);
    x = ((x & 0xff00ff00ff00ff) * 0x100) | ((x / 0x100) & 0xff00ff00ff00ff);
    return x;
}

func flipEndian256(x: uint) -> uint {
    let acc = 0;
    let i = 0;
    while (i < 4) {
        acc = 0x10000000000000000 * acc + flipEndian64(x & 0xffffffffffffffff);
        x = x / 0x10000000000000000;
        i = i+1;
    }
    return acc;
}