//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type MarshalledBytes;

import func bytearray_new(size: uint) -> ByteArray;
import func bytearray_unmarshalBytes(mbytes: MarshalledBytes) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, idx: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, idx: uint, val: uint) -> ByteArray;
import func bytearray_get64(ba: ByteArray, idx: uint) -> uint;
import func bytearray_set64(ba: ByteArray, idx: uint, val: uint) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> ByteArray;
import func bytearray_copy(
    from: ByteArray,
    fromOffset: uint,
    to: ByteArray,
    toOffset: uint,
    nbytes: uint,
) -> ByteArray;
import func keccak256(ba: ByteArray, offset: uint, nbytes: uint) -> bytes32;


impure func main() {
    if let Some(x) = tests() {
	    asm(x,) { log };
	} else {
	    asm(666,) { log };
	}
}

func tests() -> option<bytes32> {
    //let acc = newfixedarray(25, 0)
    //    with { [0] = 1 }
    //    with { [16] = 0x8000000000000000 };
    //let accOut = keccak_permutation(acc);
    //return Some(accOut[0]);

	let ba = bytearray_new(0);
	let kecEmpty = keccak256(ba, 0, 0);
    if (kecEmpty != bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470)) {
		return Some(bytes32(1));
	}

    ba = bytearray_new(0);
    ba = bytearray_setByte(ba, 0, 0xcc);
    let kecCC = keccak256(ba, 0, 1);
    if (kecCC != bytes32(0xeead6dbfc7340a56caedc044696a168870549a6a7f6f56961e84a54bd9970b8a)) {
        return Some(bytes32(2));
    }

    ba = bytearray_new(0);
    ba = bytearray_setByte(ba, 0, 0xcc);
    ba = bytearray_setByte(ba, 1, 0xaa);
    let kecCCAA = keccak256(ba, 0, 2);
    if (kecCCAA != bytes32(0x33f234f4a499894af4036ace8c63b93a0bb7685472d79f3a9808cf95ed7047b4)) {
        return Some(bytes32(3));
    }

    let kec67 = keccak256(setupFromUnmarshal(), 0, 67);
    if (kec67 != bytes32(0x3dd4c9bc4aa93bb5b8a21a06ecbef5336c378a7b9814a5a3a743406a54a3cc7b)) {
        return Some(bytes32(4));
    }

    let kec67 = keccak256(
        bytearray_copy(setupFromUnmarshal(), 0, bytearray_new(0), 13, 67),
        13,
        67
    );
    if (kec67 != bytes32(0x3dd4c9bc4aa93bb5b8a21a06ecbef5336c378a7b9814a5a3a743406a54a3cc7b)) {
        return Some(bytes32(5));
    }

    let ba = bytearray_new(0);
    let i = 0;
    while (i < 5) {
        ba = bytearray_set256(ba, i*32, 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);
        i = i+1;
    }
    let kec532 = keccak256(ba, 0, 5*32);
    if (kec532 != bytes32(0xaa9038072c0559cb6890b2632b172625239a59d6d93c1ef69df62aebfdd2f4e2)) {
        return Some(bytes32(6));
    }

	return Some(bytes32(0));
}

func setupFromUnmarshal() -> ByteArray {
	let marshalledStruct = unsafecast<MarshalledBytes>((
		67,
		(
            0x4041420000000000000000000000000000000000000000000000000000000000,
			(
				0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f,
				(
					0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,
					null,
				),
			),
		),
	));
	return bytearray_unmarshalBytes(marshalledStruct);
}