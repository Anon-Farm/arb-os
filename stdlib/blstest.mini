//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

import type ByteArray;
import type BLSKey;
import type BLSSignature;
import type BLSHashedMessage;

import func bytearray_new(size: uint) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint)-> ByteArray; 
import func bytearray_set256(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func hashToField(
        domain:     ByteArray,
        messages:   ByteArray)
        -> [2]uint;


import func bls_verifySignature(
    numMsgs:   uint,
    messages:  []ByteArray,
    keys:      []BLSKey,
    signature: BLSSignature
) -> bool;

import func expandMsgTo96(
    domain:     ByteArray,
    message:    ByteArray)
        -> ByteArray;


import func hashToPoint(
    domain:     ByteArray,
    message:    ByteArray
    )
        ->BLSHashedMessage;

import func bls_initialize();

import func bls_verifySingleSig(
    message:  BLSHashedMessage,
    key:      BLSKey,
    signature: BLSSignature
) -> bool;


impure func main() {
	asm(tests(),) { log };
}

func tests() -> uint {
    if (2+2 != 4) {
        return 1;
    }

    if (6*7 != 42) {
        return 2;
    }

    bls_initialize();

    //let message = bytearray_new(1);
    //message = bytearray_setByte(message,0,0x02);
    //message = bytearray_setByte(message,1,0xe9);
    //message = bytearray_setByte(message,2,0x52);
    //message = bytearray_setByte(message,3,0xcd);

    //let domain = bytes32(0xe290d51bc9150c2a28da4a57b3222edd019b96df4eca341c409e0eecf0ca43f0);
    //let res = expandMsgTo96(domain, message);
    //let first = bytearray_get256(res,0);
    //asm(res,) { debugprint };
    //if(first != 0) {
    //    return 3;
    //}

//let  domain = bytes32(0x787878);
let message = bytearray_new(3);
message = bytearray_setByte(message,0,0x61);
message = bytearray_setByte(message,1,0x62);
message = bytearray_setByte(message,2,0x63);


let domain = bytearray_new(3);
domain = bytearray_setByte(domain,0,0x78);
domain = bytearray_setByte(domain,1,0x78);
domain = bytearray_setByte(domain,2,0x78);
let res = hashToPoint(domain,message);
//asm(res,) { debugprint };


let domain2 = bytearray_new(32);
domain = bytearray_set256(domain, 0,0x2d889d03243d367c56457383bb04bcdadff3a522dbf9c97145d0a58c1e88d6f9);



let message2 = bytearray_new(12);
message2 = bytearray_setByte(message2,0,0x46);
message2 = bytearray_setByte(message2,1,0xf5);
message2 = bytearray_setByte(message2,2,0xa4);
message2 = bytearray_setByte(message2,3,0x33);
message2 = bytearray_setByte(message2,4,0x9d);
message2 = bytearray_setByte(message2,5,0x68);
message2 = bytearray_setByte(message2,6,0x7a);
message2 = bytearray_setByte(message2,7,0x8c);
message2 = bytearray_setByte(message2,8,0x2f);
message2 = bytearray_setByte(message2,9,0x7e);
message2 = bytearray_setByte(message2,10,0x1d);
message2 = bytearray_setByte(message2,11,0x7b);

let hashedmessage = hashToPoint(domain2,message2);
let signature = unsafecast<BLSSignature>((0x0d9c060fbeb416fc52d052764a0774cbe6f2a998034645bf5f4c1726b0da6289,0x240e4d2d8958684713d37f2f7c20a67627bbecb60450e62aeb5b2eab6d4dbbff));

let pubkey = unsafecast<BLSKey>((0x16d85ac6b1495562dabf0e052b323cb27095143a8dd228dceeccd94ca23fce6e,0x252f8568427a600d5e7b2db105ca1bdf8b4f10c2c98a78da764f0cdb6fa9547d,0x2bb33da900a0cc9a13e56fd0d3226c562d1fc54106754f11dc992daa153407a0,0x236e9f6e5631d4800ea7f50debef4d331ea50f50e6c1c03a3efdd292e30a52ff));

bls_verifySingleSig(hashedmessage,pubkey,signature);

return 4;
 

    return 0;   // passed all tests
}