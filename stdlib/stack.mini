//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

type Stack = option<StackCell>

type StackCell = struct {
    top: any,
    rest: option<any>   // really option<StackCell>, but compiler doesn't support recursive types
}


public func stack_new() -> Stack {
    return None<StackCell>;
}

public func stack_push(stack: Stack, value: any) -> Stack {
    return Some(struct {
        top: value,
        rest: stack
    });
}

public func stack_isEmpty(stack: Stack) -> bool {
    return stack == None<StackCell>;
}

public func stack_pop(stack: Stack) -> option<(Stack, any)> {
    let cell = stack?;
    return Some((
        unsafecast<Stack>(cell.rest),
        cell.top
    ));
}

public func stack_discardDeepestItems(stack: Stack, numToDiscard: uint) -> Stack {
    return stack_ddi2(stack, numToDiscard).0;
}

func stack_ddi2(stack: Stack, numToDiscard: uint) -> (Stack, uint) {
    if let Some(res) = stack_pop(stack) {
        let (ustack, val) = res;
        let (subStack, subNum) = stack_ddi2(ustack, numToDiscard);
        if (subNum == 0) {
            return (stack_push(subStack, val), 0);
        } else {
            return (subStack, subNum-1);
        }
    } else {
        return (stack, numToDiscard);  // stack is empty
    }
}