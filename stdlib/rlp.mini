//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type ByteStream;

import func bytearray_new(capacity: uint) -> ByteArray;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytestream_getByte(bs: ByteStream) -> option<(ByteStream, uint)>;
import impure func keccak256(ba: ByteArray, offset: uint, nbytes: uint) -> bytes32;


public func rlp_encodeUint(val: uint, ba: ByteArray, offset: uint) -> (ByteArray, uint) {
    // RLP-encode val, writing the result to ba at offset
    // return (updated_ba, nbytes_written)

    if (val <= 0x7f) {
        return (
            bytearray_setByte(ba, offset, val),
            1
        );
    } else {
        let length = bytesNeededToRepresentUint(val);
        let origLen = length;
        ba = bytearray_setByte(ba, offset, 0x80+length);
        offset = offset + 1;
        while (length > 0) {
            length = length-1;
            ba = bytearray_setByte(ba, offset, (val / asm(256, length) uint { exp }) & 0xff);
            offset = offset+1;
        }
        return (ba, origLen+1);
    }
}

public func rlp_encodeAddress(addr: address, ba: ByteArray, offset: uint) -> (ByteArray, uint) {
    return rlp_encodeUint(uint(addr), ba, offset);
}

public func rlp_encodeAddrUintPair(
    addr: address,
    ui: uint,
    ba: ByteArray,
    offset: uint
) -> (ByteArray, uint) {
    // Leave one byte of space for the RLP list length indicator
    // It will always fit in one byte because max RLP size of address is 21 bytes, uint is 33,
    //        and one-byte indicator covers sum-of-lengths <= 55
    let (uba, rlpAddrLen) = rlp_encodeAddress(addr, ba, offset+1);
    ba = uba;
    let (uba, rlpUiLen) = rlp_encodeUint(ui, ba, offset+1+rlpAddrLen);
    ba = uba;
    ba = bytearray_setByte(ba, offset, 0xc0+rlpAddrLen+rlpUiLen);
    return (ba, 1+rlpAddrLen+rlpUiLen);
}

public impure func keccakOfRlpEncodedAddrUintPair(addr: address, ui: uint) -> bytes32 {
    let ba = bytearray_new(64);
    let (uba, nbytes) = rlp_encodeAddrUintPair(addr, ui, ba, 0);
    return keccak256(uba, 0, nbytes);
}

public func rlp_decodeUint(bs: ByteStream) -> option<(ByteStream, uint)> {
    // read an RLP-encoded uint from bs
    // return None if end-of-stream error, or Some((updated_bs, uint_read))
    let (ubs, firstByte) = bytestream_getByte(bs)?;
    bs = ubs;
    if (firstByte <= 0x7f) {
        return Some((bs, firstByte));
    } else {
        let length = firstByte - 0x80;
        let ret = 0;
        let i = 0;
        while (i < length) {
            let (ubs, x) = bytestream_getByte(bs)?;
            bs = ubs;
            ret = 256*ret + x;
            i = i+1;
        }
        return Some((bs, ret));
    }
}

public func rlp_decodeAddress(bs: ByteStream) -> option<(ByteStream, address)> {
    let (bs, val) = rlp_decodeUint(bs)?;
    if (bytesNeededToRepresentUint(val) <= 20) {
        return Some((bs, address(val)));
    } else {
        return None;
    }
}

public func bytesNeededToRepresentUint(val: uint) -> uint {
    let ret = 0;
    let bytes = 16;
    while (bytes > 0) {
        let threshold = asm(256, bytes) uint { exp };
        if (val >= threshold) {
            ret = ret + bytes;
            val = val / threshold;
        }
        bytes = bytes / 2;
    }
    if (val == 0) {
        return ret;
    } else {
        return ret+1;
    }
}