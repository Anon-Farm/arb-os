//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type ByteStream;

import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytestream_getByte(bs: ByteStream) -> option<(ByteStream, uint)>;


public func rlp_encodeUint(val: uint, ba: ByteArray, offset: uint) -> (ByteArray, uint) {
    // RLP-encode val, writing the result to ba at offset
    // return (updated_ba, nbytes_written)

    if (val <= 0x7f) {
        return (
            bytearray_setByte(ba, offset, val),
            1
        );
    } else {
        let length = bytesNeededToRepresentUint(val);
        let origLen = length;
        ba = bytearray_setByte(ba, offset, 0x80+length);
        offset = offset + 1;
        while (length > 0) {
            length = length-1;
            ba = bytearray_setByte(ba, offset, (val / asm(256, length) uint { exp }) & 0xff);
            offset = offset+1;
        }
        return (ba, origLen+1);
    }
}

public func rlp_decodeUint(bs: ByteStream) -> option<(ByteStream, uint)> {
    // read an RLP-encoded uint from bs
    // return None if end-of-stream error, or Some((updated_bs, uint_read))
    let (ubs, firstByte) = bytestream_getByte(bs)?;
    bs = ubs;
    if (firstByte <= 0x7f) {
        return Some((bs, firstByte));
    } else {
        let length = firstByte - 0x80;
        let ret = 0;
        let i = 0;
        while (i < length) {
            let (ubs, x) = bytestream_getByte(bs)?;
            bs = ubs;
            ret = 256*ret + x;
            i = i+1;
        }
        return Some((bs, ret));
    }
}

func bytesNeededToRepresentUint(val: uint) -> uint {
    let ret = 0;
    let bytes = 16;
    while (bytes > 0) {
        let threshold = asm(2, bytes) uint { exp };
        if (val > threshold) {
            ret = ret + bytes;
            val = val / threshold;
        }
        bytes = bytes / 2;
    }
    if (val == 0) {
        return ret;
    } else {
        return ret+1;
    }
}