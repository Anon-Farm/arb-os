
use std::bytearray::ByteArray;
use std::bytearray::MarshalledBytes;

use std::bytearray::bytearray_new;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_setByte;
use std::bytearray::bytearray_get64;
use std::bytearray::bytearray_set64;
use std::bytearray::bytearray_get256;
use std::bytearray::bytearray_set256;
use std::bytearray::bytearray_copy;
use std::bytearray::bytearray_buffer;

type AvmCodePoint = impure func(any, any, any)

impure func main() {
    let buf = #include "/home/sami/avm2wasm/pkg/avm2wasm_bg.wasm";
    let ln = 236012;
    let compiled = asm(ln, buf,) any { compilewasm };

	let code_buf = #include "/home/sami/arb-os/wasm-tests/test-buffer.wasm";
	let code_len = 143;

    let (res_len, res_buf) = asm(code_len,code_buf,compiled,) (int, buffer) { runwasm };
    debug(res_buf);

	let segment = asm() AvmCodePoint { errcodept };

	let list = newarray<any>(8*8*8*8*8);
	let list_idx = 0;

	let i = 0;
	while (getbuffer8(res_buf, i) != 255) {
		let opcode = getbuffer8(res_buf, i);
		debug(opcode);
		i = i + 1;
		let immed_type = getbuffer8(res_buf, i);
		i = i + 1;
		if (immed_type == 0) {
			segment = pushInstruction(opcode, segment);
		} elseif (immed_type == 2) {
			segment = pushInstructionImm(opcode, (\x00, 0, \x112233, 3, 100000), segment);
		} elseif (immed_type == 3) {
			segment = pushInstructionImm(opcode, (\x00, getbuffer64(res_buf, i)), segment);
			i = i + 8;
		} elseif (immed_type == 1) {
			segment = pushInstructionImm(opcode, getbuffer64(res_buf, i), segment);
			i = i + 8;
		} else {
			debug(123456);
		}
		let has_label = getbuffer8(res_buf, i);
		i = i + 1;
		if (has_label == 1) {
			list = list with {[list_idx] = segment};
			debug(list[list_idx]);
			list_idx = list_idx + 1;
		}
	}

	debug(list_idx);

	let list_rev = newarray<any>(8*8*8*8*8);
	i = 0;
	while (i < list_idx) {
		list_rev = list_rev with {[i] = list[list_idx-1-i]};
		debug(list_rev[i]);
		i = i + 1;
	}

	let table = make_table(list_rev, list_idx);

	debug(999999);

	// segment(table, \x112233, 3);
	asm(segment, table, \x112233, 3, ) any { jump };

}

func table_to_tuple(tab: []any, prefix: uint, shift: uint, level: uint, limit: uint) -> any {
    if (prefix > limit) {
		return 0;
	}
	if (level == 0) {
		return (
			tab[prefix + (0 * shift)],
			tab[prefix + (1 * shift)],
			tab[prefix + (2 * shift)],
			tab[prefix + (3 * shift)],
			tab[prefix + (4 * shift)],
			tab[prefix + (5 * shift)],
			tab[prefix + (6 * shift)],
			tab[prefix + (7 * shift)]
		);
    }
	return (
		table_to_tuple(tab, prefix + 0*shift, shift * 8, level - 1, limit),
		table_to_tuple(tab, prefix + 1*shift, shift * 8, level - 1, limit),
		table_to_tuple(tab, prefix + 2*shift, shift * 8, level - 1, limit),
		table_to_tuple(tab, prefix + 3*shift, shift * 8, level - 1, limit),
		table_to_tuple(tab, prefix + 4*shift, shift * 8, level - 1, limit),
		table_to_tuple(tab, prefix + 5*shift, shift * 8, level - 1, limit),
		table_to_tuple(tab, prefix + 6*shift, shift * 8, level - 1, limit),
		table_to_tuple(tab, prefix + 7*shift, shift * 8, level - 1, limit)
	);
}

func make_table(lst: []any, limit: uint) -> any {
	return table_to_tuple(lst, 0, 1, 5-1, limit);
}

impure func pushInstruction(opcode: uint, restOfCode: AvmCodePoint) -> AvmCodePoint {
    // Push an instruction onto the beginning of a code segment, and return the resulting CodePoint.
    return asm(opcode, restOfCode) AvmCodePoint { pushinsn };
}

impure func pushInstructionImm(opcode: uint, val: any, restOfCode: AvmCodePoint) -> AvmCodePoint {
    // Push an instruction (with immediate value) onto the beginning of a code segment, and return the resulting CodePoint.
    return asm(opcode, val, restOfCode) AvmCodePoint { pushinsnimm };
}

