//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

type StorageMap = struct {
    tree: StorageMapNode,
    size: uint,
}

type StorageMapNode = [8]any

type StorageMapCell = struct {
    key: uint,
    value: uint,
}


public func storageMap_new() -> StorageMap {
    return struct {
        tree: unsafecast<StorageMapNode>(0),
        size: 0,
    };
}

public func storageMap_size(kvs: StorageMap) -> uint {
    return kvs.size;
}

public func storageMap_get(kvs: StorageMap, key: uint) -> uint {
    let s = kvs.tree;
    let reductionFactor = 1;
    loop {
        if (s == unsafecast<StorageMapNode>(0)) {
            return 0;
        } elseif (asm(s,) uint { length } == 2) {
            if (key == unsafecast<StorageMapCell>(s).key) {
                return unsafecast<StorageMapCell>(s).value;
            } else {
                return 0;
            }
        } else {
            s = unsafecast<StorageMapNode>(s[(key/reductionFactor) & 0x7]);
            reductionFactor = reductionFactor * 8;
        }
    }
}

type Unwinder = struct {
    kvs: [8]any,
    index: uint,
    next: option<any>,   // really option<Unwinder>, but compiler doesn't do recursive types
}

public func storageMap_set(s: StorageMap, key: uint, value: uint) -> StorageMap {
    let (utree, maybeUnwinder, delta) = storageMap_set2(s.tree, key, value);
    loop {
        if let Some(unwinder) = maybeUnwinder {
            utree = unwinder.kvs with {
                [unwinder.index] = utree
            };
            maybeUnwinder = unsafecast<option<Unwinder>>(unwinder.next);
        } else {
            if (delta != int(0)) {
                s = s with { size: uint(int(s.size) + delta) };
            }
            return s with { tree: utree };
        }
    }
}

public func storageMap_set2(s: StorageMapNode, key: uint, value: uint) -> (StorageMapNode, option<Unwinder>, int) {
    let reductionFactor = 1;
    let unwinder = None<Unwinder>;
    loop {
        if (s == unsafecast<StorageMapNode>(0)) {
            if (value == 0) {
                return (s, unwinder, int(0));
            } else {
                return (
                    unsafecast<StorageMapNode>(
                        struct {
                            key: key,
                            value: value
                        }
                    ),
                    unwinder,
                    int(1)
                );
            }
        } elseif (asm(s,) uint { length } == 2) {
            let kid = unsafecast<StorageMapCell>(s);
            if (kid.key == key) {
                if (value == 0) {
                    return (
                        unsafecast<StorageMapNode>(0),
                        unwinder,
                        -1s,
                    );
                } else {
                    return (
                        unsafecast<StorageMapNode>(kid with { value: value }),
                        unwinder,
                        int(0)
                    );
                }
            } else {
                s = unsafecast<StorageMapNode>(newfixedarray(8, 0)) with {
                    [(kid.key/reductionFactor) & 0x7] = kid
                };
            }
        } else {
            let slot = (key / reductionFactor) & 0x7;
            unwinder = Some(struct {
                kvs: s,
                index: slot,
                next: unwinder,
            });
            s = unsafecast<StorageMapNode>(s[slot]);
            reductionFactor = reductionFactor * 8;
        }
    }
}

public func storageMap_delete(s: StorageMap, key: uint) -> StorageMap {
    return storageMap_set(s, key, 0);
}

public func storageMap_forall(
    s: StorageMap,
    closure: func(uint, uint, any) -> any,
    state: any
) -> any {
    return storageMap_forall_tree(s.tree, closure, state);
}

public func storageMap_forall(
    s: StorageMap,
    closure: func(uint, uint, any) -> any,
    state: any
) -> any {
    return storageMap_forall_tree(s.tree, closure, state);
}

public func storageMap_forall_tree(
    t: StorageMapNode,
    closure: func(uint, uint, any) -> any,
    state: any
) -> any {
    if (t == unsafecast<StorageMapNode>(0)) {
        return state;
    } elseif (asm(t,) uint { length } == 2) {
        return closure(
            unsafecast<StorageMapCell>(t).key,
            unsafecast<StorageMapCell>(t).value,
            state
        );
   } else {
        let i = 0;
        while (i < 8) {
            state = storageMap_forall_tree(unsafecast<StorageMapNode>(t[i]), closure, state);
            i = i+1;
        }
        return state;
   }
}
