//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::bytestream::ByteStream;
use std::bytestream::bytestream_atEof;
use std::bytestream::bytestream_getByte;

use std::rlp::rlp_decodeUint;


type AvmCodePoint = impure func()

type AvmCodeBuilder = struct {
    requireSafe: bool,
    allowEvmOps: bool,
    code: AvmCodePoint,
    size: uint,
    codeMap: map<uint, AvmCodePoint>,
}

public impure func pushInstruction(opcode: uint, restOfCode: AvmCodePoint) -> AvmCodePoint {
    // Push an instruction onto the beginning of a code segment, and return the resulting CodePoint.
    return asm(opcode, restOfCode) AvmCodePoint { pushinsn };
}

public impure func pushInstructionImm(opcode: uint, val: any, restOfCode: AvmCodePoint) -> AvmCodePoint {
    // Push an instruction (with immediate value) onto the beginning of a code segment, and return the resulting CodePoint.
    return asm(opcode, val, restOfCode) AvmCodePoint { pushinsnimm };
}

public impure func pushValue(val: any, restOfCode: AvmCodePoint) -> AvmCodePoint {
    // Push a noop (with immediate value) onto the beginning of a code segment, and return the resulting CodePoint.
    return asm(const::AVM_nop, val, restOfCode) AvmCodePoint { pushinsnimm };
}

public impure func pushEvmInsnCall(evmOpNum: uint, code: AvmCodePoint) -> AvmCodePoint {
    // Some EVM instructions compile to a procedure call to some Mini code.
    // Generate the appropriate procedure call.
    // Note that the EVM code will already have put the args to the call on the stack,
    //     and the Mini code will leave return values on the stack.
    return pushValue(
        evmOpNum,
        pushValue(
            code,
            pushInstruction(
                const::AVM_rpush,
                pushInstructionImm(
                    const::AVM_tget,
                    0,
                    pushInstruction(
                        const::AVM_jump,
                        code,
                    ),
                ),
            ),
        ),
    );
}

public impure func avmCodeBuilder_new(requireSafe: bool, allowEvmOps: bool) -> AvmCodeBuilder {
    let code = asm() AvmCodePoint { errcodept };
    return struct {
        requireSafe: requireSafe,
        allowEvmOps: allowEvmOps,
        code: code,
        size: 1,
        codeMap: newmap<uint, AvmCodePoint> with { [0] = code },
    };
}

public impure func avmCodeBuilder_append(builder: AvmCodeBuilder, stream: ByteStream) -> option<AvmCodeBuilder> {
    let requireSafe = builder.requireSafe;
    let code = builder.code;
    let size = builder.size;
    let codeMap = builder.codeMap;

    while( ! bytestream_atEof(stream) ) {
        let (ustr, insn) = bytestream_getByte(stream)?;
        if ( requireSafe && !isSafeInstruction(insn) ) {
            return None;
        }
        stream = ustr;
        let (ustr, hasImm) = bytestream_getByte(stream)?;
        stream = ustr;
        if (hasImm == 0) {
            code = pushInstruction(insn, code);
        } else {
            let (ustr, val) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            if (builder.allowEvmOps && (insn == const::AVM_pseudoOp_evmOp)) {
                if let Some(opNum) = getValueIfUint(val) {
                    if (opNum < const::NumEvmOps) {
                        code = pushEvmInsnCall(opNum, code);
                    }
                }
                // otherwise ignore, because EVM op number was invalid
            } else {
                code = pushInstructionImm(insn, val, code);
            }
        }
        codeMap = codeMap with { [size] = code };
        size = size+1;
    }

    return Some(builder with {
        code: code
    } with {
        size: size
    } with {
        codeMap: codeMap
    });
}

func getValueIfUint(val: any) -> option<uint> {
    return xif (asm(val,) uint { gettype } == 0) {
        Some(unsafecast<uint>(val))
    } else {
        None<uint>
    };
}

public func avmCodeBuilder_getCodeHash(builder: AvmCodeBuilder) -> bytes32 {
    return hash(builder.code);
}

public func avmCodeBuilder_finish(builder: AvmCodeBuilder) -> AvmCodePoint {
    return builder.code;
}

func isSafeInstruction(insn: uint) -> bool {
    return (insn != const::AVM_spush)
        && (insn != const::AVM_rpush)
        && (insn != const::AVM_rset)
        && (insn != const::AVM_errset)
        && ((insn < 0x60) || (insn > 0x7f));   // various unsafe instructions
}

func unmarshalValue(stream: ByteStream, codeMap: map<uint, AvmCodePoint>) -> option<(ByteStream, any)> {
    let (ustr, kind) = bytestream_getByte(stream)?;
    stream = ustr;
    return xif (kind == 0) {  // integer
        let (ustr, val) = rlp_decodeUint(stream)?;
        Some((ustr, val))
    } elseif (kind == 1) { // codepoint
        let (ustr, idx) = rlp_decodeUint(stream)?;
        xif let Some(codePt) = codeMap[idx] {
            Some((ustr, codePt))
        } else {
            None<(ByteStream, any)>
        }
    } elseif (kind == 2) { // empty buffer
        Some((ustr, newbuffer()))
    } elseif (kind == 10) {   // 0-tuple
        Some((stream, ()))
    } elseif (kind == 11) {   // 1-tuple
        let val = unsafecast<[1]any>(None<any>);
        let (ustr, x) = unmarshalValue(stream, codeMap)?;
        Some((ustr, val with { [0] = x }))
    } elseif (kind == 12) {   // 2-tuple
        let val = unsafecast<[2]any>((0,0));
        let i = 0;
        while (i < 2) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        Some((stream, val))
    } elseif (kind == 13) {   // 3-tuple
        let val = unsafecast<[3]any>((0,0,0));
        let i = 0;
        while (i < 3) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        Some((stream, val))
    } elseif (kind == 14) {   // 4-tuple
        let val = unsafecast<[4]any>((0,0,0,0));
        let i = 0;
        while (i < 4) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        Some((stream, val))
    } elseif (kind == 15) {   // 5-tuple
        let val = unsafecast<[5]any>((0,0,0,0,0));
        let i = 0;
        while (i < 5) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        Some((stream, val))
    } elseif (kind == 16) {   // 6-tuple
        let val = unsafecast<[6]any>((0,0,0,0,0,0));
        let i = 0;
        while (i < 6) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        Some((stream, val))
    } elseif (kind == 17) {   // 7-tuple
        let val = unsafecast<[7]any>((0,0,0,0,0,0,0));
        let i = 0;
        while (i < 7) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        Some((stream, val))
    } elseif (kind == 18) {   // 8-tuple
        let val = unsafecast<[8]any>((0,0,0,0,0,0,0,0));
        let i = 0;
        while (i < 8) {
            let (ustr, x) = unmarshalValue(stream, codeMap)?;
            stream = ustr;
            val = val with { [i] = x };
            i = i+1;
        }
        Some((stream, val))
    } else {
        None<(ByteStream, any)>
    };
}
