//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type MarshalledBytes;

import func bytearray_new(size: uint, autoExpand: bool) -> ByteArray;
import func bytearray_unmarshalBytes(mbytes: MarshalledBytes) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, idx: uint) -> option<uint>;
import func bytearray_setByte(ba: ByteArray, idx: uint, val: uint) -> option<ByteArray>;
import func bytearray_get64(ba: ByteArray, idx: uint) -> option<uint>;
import func bytearray_set64(ba: ByteArray, idx: uint, val: uint) -> option<ByteArray>;
import func bytearray_get256(ba: ByteArray, offset: uint) -> option<uint>;
import func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> option<ByteArray>;


func main() {
	asm(tests(),) { log };
}

func tests() -> uint {
	let ba = bytearray_new(33, false);
	if (bytearray_size(ba) != 33) {
		return 1;
	}

	ba = bytearray_new(117, true);
	if let Some(ba2) = bytearray_setByte(ba, 33, 42) {
		if (bytearray_getByte(ba2, 33) != Some(42)) {
			return 2;
		}
	} else {
		return 102;
	}

	ba = bytearray_new(117, false);
	if let Some(ba2) = bytearray_setByte(ba, 33, 42) {
		if let Some(ba3) = bytearray_setByte(ba2, 37, 99) {
		    if (bytearray_getByte(ba3, 33) != Some(42)) {
		        return 3;
		    }
		} else {
			return 103;
		}
	} else {
		return 103;
	}

	ba = bytearray_new(117, true);
	if let Some(ba2) = bytearray_setByte(ba, 37, 42+99*256) {
		if let Some(ba3) = bytearray_setByte(ba2, 36, 999999999999999999) {
			if (bytearray_getByte(ba3, 37) != Some(42)) {
				return 4;
			}
		} else {
			return 104;
		}
	} else {
		return 104;
	}

	ba = bytearray_new(117, false);
	if let Some(ba2) = bytearray_set256(ba, 64, 7373) {
		if (bytearray_get256(ba2, 64) != Some(7373)) {
			return 5;
		}
	} else {
		return 105;
	}

	ba = bytearray_new(117, true);
	if let Some(ba2) = bytearray_set256(ba, 64, 7373) {
	    if let Some(res) = bytearray_get256(ba2, 63) {
	        if (res != 7373/256) {
	            return 60000+res;
	        }
	    } else {
	        return 106;
	    }
	} else {
		return 106;
	}

	ba = bytearray_new(117, true);
	if let Some(ba2) = bytearray_set256(ba, 13, ~0) {
		if let Some(ba3) = bytearray_set256(ba2, 13+32, 0) {
			if let Some(ba4) = bytearray_set256(ba3, 13+64, ~0) {
				if ( (bytearray_get256(ba4, 13) != Some(~0)) 
					|| (bytearray_get256(ba4, 13+32) != Some(0))
					|| (bytearray_get256(ba4, 13+64) != Some(~0)) ) {
					return 7;	
				}		
			} else {
				return 107;
			}
		} else {
			return 107;
		}
	} else {
		return 107;
	}

	let marshalledStruct = unsafecast<MarshalledBytes>((
		67,
		(
			(
				(
					null,
					0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,
				),
				0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f,
			),
			0x4041420000000000000000000000000000000000000000000000000000000000,
		),
	));
	ba = bytearray_new(67, false);
	ba = bytearray_unmarshalBytes(marshalledStruct);
	let i = 0;
	while (i < 67) {
		let b = bytearray_getByte(ba, i);
		if (b != Some(i)) {
			return 100+i;
		}
		i = i+1;
	}

	ba = setupFromUnmarshal();
	if let Some(res) = bytearray_get64(ba, 3) {
	    if (res != 0x030405060708090a) {
		    return 9;
		}
	} else {
	    return 109;
	}

	ba = setupFromUnmarshal();
	if (bytearray_get64(ba, 29) != Some(0x1d1e1f2021222324)) {
		return 10;
	}

	ba = setupFromUnmarshal();
	let before = bytearray_get256(ba, 32);
	let _ = bytearray_get64(ba, 29); // ^ 0x24232221201f1e1d;
	if (bytearray_get256(ba, 32) != before) {
		return 11;
	}

	// test for big-endian byte order
	ba = bytearray_new(32, false);
	if let Some(ba2) = bytearray_setByte(ba, 31, 1) {
	    if (bytearray_get256(ba2, 0) != Some(1)) {
	        return 12;
	    }
	} else {
	    return 1012;
	}

	return 0;
}

func setupFromUnmarshal() -> ByteArray {
	let marshalledStruct = unsafecast<MarshalledBytes>((
		67,
		(
			(
				(
					null,
					0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,
				),
				0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f,
			),
			0x4041420000000000000000000000000000000000000000000000000000000000,
		),
	));
	return bytearray_unmarshalBytes(marshalledStruct);
}
