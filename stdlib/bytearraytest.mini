//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type MarshalledBytes;

import func bytearray_new(size: uint, autoExpand: bool) -> ByteArray;
import func bytearray_unmarshalBytes(mbytes: MarshalledBytes, dest: ByteArray, offset: uint) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, idx: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, idx: uint, val: uint) -> ByteArray;
import func bytearray_get64(ba: ByteArray, idx: uint) -> uint;
import func bytearray_set64(ba: ByteArray, idx: uint, val: uint) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> ByteArray;


func tests(which: uint) -> any {
	if (which == 0) {
		let ba = bytearray_new(33, false);
		return bytearray_size(ba);
	} elseif (which == 1) {
		let ba = bytearray_new(117, true);
		ba = bytearray_setByte(ba, 33, 42);
		return bytearray_getByte(ba, 33);
	} elseif (which == 2) {
		let ba = bytearray_new(117, false);
		ba = bytearray_setByte(ba, 33, 42);
		ba = bytearray_setByte(ba, 37, 99);
		return bytearray_getByte(ba, 33);
	} elseif (which == 3) {
		let ba = bytearray_new(117, true);
		ba = bytearray_setByte(ba, 37, 42+99*256);
		ba = bytearray_setByte(ba, 36, 999999999999999999);
		return bytearray_getByte(ba, 37);
	} elseif (which == 4) {
		let ba = bytearray_new(117, false);
		ba = bytearray_set256(ba, 64, 7373);
		return bytearray_get256(ba, 64);
	} elseif (which == 5) {
		let ba = bytearray_new(117, true);
		ba = bytearray_set256(ba, 64, 7373);
		return bytearray_get256(ba, 65);
	} elseif (which == 6) {
		let ba = bytearray_new(117, true);
		ba = bytearray_set256(ba, 13, ~0);
		ba = bytearray_set256(ba, 13+32, 0);
		ba = bytearray_set256(ba, 13+64, ~0);
		return (bytearray_get256(ba, 13) == ~0) 
			&& (bytearray_get256(ba, 13+32) == 0)
			&& (bytearray_get256(ba, 13+64) == ~0);
	} elseif (which == 7) {
		let marshalledStruct = unsafecast<MarshalledBytes>((
			67,
			(
				(
					(
						null,
						0x1f1e1d1c1b1a191817161514131211100f0e0d0c0b0a09080706050403020100,
					),
					0x3f3e3d3c3b3a393837363534333231302f2e2d2c2b2a29282726252423222120,
				),
				0x424140,
			),
		));
		let ba = bytearray_new(67, false);
		ba = bytearray_unmarshalBytes(marshalledStruct, ba, 0);
		let i = 0;
		while (i < 67) {
			let b = bytearray_getByte(ba, i);
			if (b != i) {
				return (i, b,);
			}
			i = i+1;
		}
		return 100;
	} elseif (which == 8) {
		let ba = setupFromUnmarshal();
		return bytearray_get64(ba, 3) ^ 0x0a09080706050403;
	} elseif (which == 9) {
		let ba = setupFromUnmarshal();
		return bytearray_get64(ba, 29) ^ 0x24232221201f1e1d;
	} elseif (which == 10) {
		let ba = setupFromUnmarshal();
		let before = bytearray_get256(ba, 32);
		let _ = bytearray_get64(ba, 29) ^ 0x24232221201f1e1d;
		return bytearray_get256(ba, 32) ^ before;
	} else {
		return null;
	}
}

func setupFromUnmarshal() -> ByteArray {
	let marshalledStruct = unsafecast<MarshalledBytes>((
		67,
		(
			(
				(
					null,
					0x1f1e1d1c1b1a191817161514131211100f0e0d0c0b0a09080706050403020100,
				),
				0x3f3e3d3c3b3a393837363534333231302f2e2d2c2b2a29282726252423222120,
			),
			0x424140,
		),
	));
	let ba = bytearray_new(67, false);
	return bytearray_unmarshalBytes(marshalledStruct, ba, 0);
}
