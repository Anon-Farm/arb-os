//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import func builtin_arrayResize(a: []uint, newSize: uint, baseVal: uint) -> []uint;
import func builtin_arrayGetConsecutive(a: []uint, index: uint) -> (uint, uint);
import func builtin_arrayOp(a: []uint, index: uint, closure: opClosure) -> ([]uint, uint);
import func builtin_arrayOpConsecutive(a: []uint, index: uint, closure1: opClosure, closure2: opClosure) -> ([]uint, uint, uint);

type opClosure = struct {
	f: func((uint, uint), uint) -> (uint, uint),  // (closure.val, oldVal) -> (newVal, return)
	val: (uint, uint),
}

type ByteArray = struct { 
    size: uint, 
    contents: []uint,
    autoExpand: bool,
    sizeNeeded: uint,   // minimum size array that could have accepted all writes so far
}

public func bytearray_new(size: uint, autoExpand: bool) -> ByteArray {
    if (autoExpand) {
        let roundedUpSize = 8*32;
        while (roundedUpSize < size) {
            roundedUpSize = 8*roundedUpSize;
        }
        size = roundedUpSize;
    }
    return struct { 
        size: size, 
        contents: newarray<uint>((size+31)/32),
        autoExpand: autoExpand,
        sizeNeeded: 0,
    };
}

type MarshalledBytes = struct {
    nbytes: uint,
    contents: MarshalledBytesCell,
}

type MarshalledBytesCell = struct {
    rest: any,  // really a MarshalledbytesCell, but compiler can't handle recursive types
    first: uint,
}

public func bytearray_unmarshalBytes(
    mbytes: MarshalledBytes, 
    dest: ByteArray,
    offset: uint
) -> ByteArray {
    // unmarshal bytes from the bytestack data structure that we receive from L1
    let nbytes = mbytes.nbytes;
    let words = mbytes.contents;
    if ((nbytes % 32) != 0) {
        let first = words.first;
        words = unsafecast<MarshalledBytesCell>(words.rest);
        let bytesLeft = nbytes % 32;
        nbytes = nbytes-bytesLeft;
        while (bytesLeft > 0) {
            bytesLeft = bytesLeft-1;
            dest = bytearray_setByte(
                dest, 
                nbytes+bytesLeft, 
                (first / (asm(2, 8*bytesLeft) uint {exp})) & 0xff
            );
        }
    }
    let wordsLeft = nbytes/32;
    while (nbytes > 0) {
        let first = words.first;
        words = unsafecast<MarshalledBytesCell>(words.rest);
        nbytes = nbytes-32;
        dest = bytearray_set256(dest, offset+nbytes, first);
    }
    return dest;
}

public func bytearray_size(ba: ByteArray) -> uint {
    // if autoExpand==false, this returns the size
    // if autoExpand==true, this returns sizeNeeded
    if (ba.autoExpand) {
        return ba.sizeNeeded;
    } else {
        return ba.size;
    }
}

public func bytearray_getByte(ba: ByteArray, idx: uint) -> uint {
    if (idx >= ba.size) {
        if (ba.autoExpand) {
            return 0;
        } else {
            panic;
        }
    }
    let slot = ba.contents[idx/32];
    let byteno = idx%32;
    return (slot / (asm (2, 8*byteno) uint { exp })) & 0xff;
}

public func bytearray_setByte(ba: ByteArray, idx: uint, val: uint) -> ByteArray {
    if (idx >= ba.size) {
        if (ba.autoExpand) {
            let newSize = 8*ba.size;
            while (newSize < idx) {
                newSize = 8*newSize;
            }
            ba = ba with { size: newSize }
                    with { contents: builtin_arrayResize(ba.contents, newSize/32, 0) };
        } else {
            panic;
        }
    }
    if (idx >= ba.sizeNeeded) {
        ba = ba with { sizeNeeded: idx+1 };
    }
    return ba with {
        contents: builtin_arrayOp(
            ba.contents, 
            idx/32, 
            struct { f: basb_closure_func, val: (idx%32, val,), } 
        ).0
    };
}

public func bytearray_get256(ba: ByteArray, offset: uint) -> uint {
    let lowWordIndex = offset / 32;
    let alignment = offset % 32;
    if (alignment == 0) {
        if (offset+32 > ba.size) {
            if (ba.autoExpand) {
                // because size is a multiple of 32 in this case, access is entirely outside the ByteArray
                return 0;
            } else {
                panic;
            }
        } 
        return ba.contents[lowWordIndex];
    } else {
        let lowWord = 0;
        let hiWord = 0;
        if (ba.autoExpand) {
            if (offset+32 > ba.size) {
                let offsetBase = offset & 0x1f;
                let offsetBaseDiv32 = offsetBase / 32;
                if (offsetBase < ba.size) {
                    lowWord = ba.contents[offsetBaseDiv32];
                }
                if (offsetBase+32 < ba.size) {
                    hiWord = ba.contents[1+offsetBaseDiv32];
                }
            } else {
                let words = builtin_arrayGetConsecutive(ba.contents, lowWordIndex);
                lowWord = words.0;
                hiWord = words.1;
            }
            let shiftFactor = asm(2, 8*alignment) uint { exp };
            let invShiftFactor = asm(2, 256-8*alignment) uint { exp };
            return (lowWord/shiftFactor) | (hiWord*invShiftFactor);
        } else {
            let words = builtin_arrayGetConsecutive(ba.contents, lowWordIndex);
            lowWord = words.0;
            hiWord = words.1;
        }
        let shiftFactor = asm(2, 8*alignment) uint { exp };
        let invShiftFactor = asm(2, 256-8*alignment) uint { exp };
        return (lowWord/shiftFactor) | (hiWord*invShiftFactor);
    }
}

public func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> ByteArray {
    if (offset+32 >= ba.sizeNeeded) {
        ba = ba with { sizeNeeded: offset+32 };
    }
    let lowWordIndex = offset / 32;
    let alignment = offset % 32;
    if (alignment == 0) {
        return ba with {
            contents: ba.contents with { [lowWordIndex] = value }
        };
    } else {
        return ba with {
            contents: builtin_arrayOpConsecutive(
                ba.contents,
                lowWordIndex,
                struct { f: bas256_low_closure_func, val: (alignment, value,), },
                struct { f: bas256_hi_closure_func, val: (alignment, value,), }
            ).0
        };
    }
}

public func bytearray_copy(
    from: ByteArray, 
    fromOffset: uint,
    to: ByteArray,
    toOffset: uint,
    nbytes: uint,
) -> ByteArray {   // TODO: optimize this to exploit alignment and speed up the endgame
    if (toOffset+nbytes >= to.sizeNeeded) {
        to = to with { sizeNeeded: toOffset+nbytes };
    }
    while (nbytes >= 32) {
        to = bytearray_set256(
            to,
            toOffset,
            bytearray_get256(from, fromOffset)
        );
        fromOffset = 32+fromOffset;
        toOffset = 32+toOffset;
        nbytes = nbytes-32;
    }
    while (nbytes > 0) {
        to = bytearray_setByte(
            to,
            toOffset,
            bytearray_getByte(from, fromOffset)
        );
        fromOffset = 1+fromOffset;
        toOffset = 1+toOffset;
        nbytes = nbytes-1;
    }
    return to;
}

func basb_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (subidx, newbval,) = args;
    let shiftFac = asm (2, 8*subidx) uint { exp };
    let mask = 0xff * shiftFac;
    let pasteIn = (newbval & 0xff) * shiftFac;
    return (
        (oldval & ~mask) | pasteIn,
        0, 
    );
}

func bas256_low_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (alignment, value,) = args; 
    let revAlignment = 32-alignment;
    let factor = asm(2, 8*revAlignment) uint { exp };
    let newVal = (value*factor) | (oldval & (factor-1));
    return (newVal, 0,);
}

func bas256_hi_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (alignment, value,) = args; 
    let revAlignment = 32-alignment;
    let factor = asm(2, 8*alignment) uint { exp };
    let invFactor = asm(2, 8*revAlignment) uint { exp };
    let newVal = (value/factor) | (oldval & (invFactor * ~0));
    return (newVal, 0,);
}