//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import func array_resize(a: []uint, newSize: uint, baseVal: uint) -> []uint;
import func builtin_arrayGetSafe(a: []uint, index: uint) -> option<uint>;
import func builtin_arrayGetConsecutiveSafe(a: []uint, index: uint) -> option<(uint, uint)>;
import func builtin_arrayOpSafe(
    a: []uint, 
    index: uint, 
    closure: opClosure
) -> option<([]uint, uint)>;
import func builtin_arrayOpConsecutiveSafe(
    a: []uint, 
    index: uint, 
    closure1: opClosure, 
    closure2: opClosure
    ) -> option<([]uint, uint, uint)>;

type opClosure = struct {
	f: func((uint, uint), uint) -> (uint, uint),  // (closure.val, oldVal) -> (newVal, return)
	val: (uint, uint),
}

type ByteArray = struct { 
    size: uint,
    capacity: uint, 
    contents: []uint,
    variableSize: bool,
}

// bytearray_new makes a new ByteArray
// if variableSize is true, it will initially have size zero, 
//                          reads beyond the end will return zero,
//                          size will expand to fit all writes,
//                          and the capacity arg is a hint about how big it will get
// if variableSize is false, capacity is the size of the bytearray, which cannot change
//                           and accesses beyond the end will panic
public func bytearray_new(capacity: uint, variableSize: bool) -> ByteArray {
    if (variableSize) {
        let roundedUpCapacity = 8*32;
        while (roundedUpCapacity < capacity) {
            roundedUpCapacity = 8*roundedUpCapacity;
        }
        return struct {
            size: 0,
            capacity: roundedUpCapacity,
            contents: newarray<uint>(roundedUpCapacity/32),
            variableSize: true,
        };
    } else {
        return struct {
            size: capacity,
            capacity: capacity,
            contents: newarray<uint>((capacity+31)/32),
            variableSize: false,
        };
    }
}

type MarshalledBytes = struct {
    nbytes: uint,
    contents: MarshalledBytesCell,
}

type MarshalledBytesCell = struct {
    rest: any,  // really a MarshalledbytesCell, but compiler can't handle recursive types
    first: uint,
}

// bytearray_unmarshalBytes unmarshals a bytestack object that we got from L1
//        returns a new bytearray holding the unmarshaled bytes
public func bytearray_unmarshalBytes(inBytes: MarshalledBytes) -> ByteArray {
    // unmarshal bytes from the bytestack data structure that we receive from L1
    let nbytes = inBytes.nbytes;
    let ba = bytearray_new(nbytes, true) with { size: nbytes };
    let nwords = (nbytes+31)/32;

    let words = inBytes.contents;
    while (nwords > 0) {
        nwords = nwords-1;
        ba = ba with { contents: ba.contents with { [nwords] = words.first } };
        words = unsafecast<MarshalledBytesCell>(words.rest);
    }
    return ba;
}

public func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes {
    let nbytes = ba.size;
    let nwords = (nbytes+31)/32;
    let words = unsafecast<MarshalledBytesCell>(());
    let i = 0;
    while (i < nwords) {
        words = struct {
            rest: words,
            first: ba.contents[i],
        };
        i = i+1;
    }
    return struct {
        nbytes: nbytes,
        contents: words,
    };
}

// bytearray_size gets the size of a ByteArray
public func bytearray_size(ba: ByteArray) -> uint {
    return ba.size;
}

// bytearray_getByte reads one byte from a ByteArray
public func bytearray_getByte(ba: ByteArray, offset: uint) -> option<uint> {
    if (offset >= ba.capacity) {
        if (ba.variableSize) {
            return Some(0);
        } else {
            return None<uint>;
        }
    }
    if let Some(slot) = builtin_arrayGetSafe(ba.contents, offset/32) {
        let byteno = offset%32;
        return Some((slot / (asm (2, 8*byteno) uint { exp })) & 0xff);
    } else {
        return None<uint>;
    }
}

// bytearray_setbyte writes one byte to a ByteArray, returns the resulting ByteArray
public func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> option<ByteArray> {
    if (offset >= ba.capacity) {
        if let Some(expandedBa) = bytearray_expandToFit(ba, offset+1) {
            ba = expandedBa;
        } else {
            return None<ByteArray>;
        }
    }
    if (ba.variableSize && (offset >= ba.size)) {
        ba = ba with { size: offset+1 };
    }
    if let Some(res) = builtin_arrayOpSafe(
        ba.contents, 
        offset/32, 
        struct { f: basb_closure_func, val: (offset%32, val,), } 
    ) {
        return Some(ba with { contents: res.0 });
    } else {
        return None<ByteArray>;
    }
}

// bytearray_get64 reads a chunk of 8 bytes from a ByteArray 
public func bytearray_get64(ba: ByteArray, offset: uint) -> option<uint> {
    if ( (!ba.variableSize) && (offset+8 > ba.size)) {
        return None<uint>;
    }
    let alignment = offset % 32;
    if (alignment <= 24) {
        if let Some(res) = builtin_arrayGetSafe(ba.contents, offset/32) {
            return Some((res / asm(2, 8*alignment) uint { exp }) & 0xffffffffffffffff);
        } else {
            return None<uint>;
        }
    } elseif (ba.variableSize) {
        if let Some(res) = bytearray_get256(ba, offset) {
            return Some(res & 0xffffffffffffffff);
        } else {
            return None<uint>;
        }
    } else {
        if let Some(words) = builtin_arrayGetConsecutiveSafe(ba.contents, offset/32) {
            let shiftFactor = asm(2, 8*alignment) uint { exp };
            let invShiftFactor = asm(2, 256-8*alignment) uint { exp };
            return Some((((words.0)/shiftFactor) | ((words.1)*invShiftFactor)) & 0xffffffffffffffff);        
        } else {
            return None<uint>;
        }
    }
}

// bytearray_set64 writes an 8-byte chunk to a ByteArray, returning the resulting ByteArray
public func bytearray_set64(ba: ByteArray, offset: uint, value: uint) -> option<ByteArray> {
    if (offset+8 > ba.size) {
        if let Some(expandedBa) = bytearray_expandToFit(ba, offset+8) {
            ba = expandedBa;
        } else {
            return None<ByteArray>;
        }
    }
    let lowWordIndex = offset / 32;
    let alignment = offset % 32;
    if (alignment <= 24) {
        if let Some(res) = builtin_arrayOpSafe(
            ba.contents,
            lowWordIndex,
            struct{ f: bas64_single_closure_func, val: (alignment, value,), }
        ) {
            return Some(ba with { contents: res.0 });
        } else {
            return None<ByteArray>;
        }
    } else {
        if let Some(res) = builtin_arrayOpConsecutiveSafe(
            ba.contents,
            lowWordIndex,
            struct { f: basmulti_low_closure_func, val: (alignment, value,), }, 
            struct { f: bas64_hi_closure_func, val: (alignment, value,), }
        ) {
            return Some(ba with { contents: res.0 });
        } else {
            return None<ByteArray>;
        }
    }
}

// bytearray_get256 reads a chunk of 32 bytes from a ByteArray
public func bytearray_get256(ba: ByteArray, offset: uint) -> option<uint> {
    let lowWordIndex = offset / 32;
    let alignment = offset % 32;
    if (alignment == 0) {
        if (offset+32 > ba.capacity) {
            if (ba.variableSize) {
                // because capacity is a multiple of 32 in this case, access is entirely beyond size
                return Some(0);
            } else {
                return None<uint>;
            }
        } 
        return builtin_arrayGetSafe(ba.contents, lowWordIndex);
    } else {
        let lowWord = 0;
        let hiWord = 0;
        if (ba.variableSize) {
            if (offset+32 > ba.capacity) {
                let offsetBase = offset & 0x1f;
                let offsetBaseDiv32 = offsetBase / 32;
                if (offsetBase < ba.capacity) {
                    if let Some(lw) = builtin_arrayGetSafe(ba.contents, offsetBaseDiv32) {
                        lowWord = lw;
                    } else {
                        return None<uint>;
                    }
                }
                if (offsetBase+32 < ba.capacity) {
                    if let Some(hw) = builtin_arrayGetSafe(ba.contents, 1+offsetBaseDiv32) {
                        hiWord = hw;
                    } else {
                        return None<uint>;
                    }
                }
            } else {
                if let Some(words) = builtin_arrayGetConsecutiveSafe(ba.contents, lowWordIndex) {
                    lowWord = words.0;
                    hiWord = words.1;
                } else {
                    return None<uint>;
                }
            }
            let shiftFactor = asm(2, 8*alignment) uint { exp };
            let invShiftFactor = asm(2, 256-8*alignment) uint { exp };
            return Some((lowWord/shiftFactor) | (hiWord*invShiftFactor));
        } else {
            if let Some(words) = builtin_arrayGetConsecutiveSafe(ba.contents, lowWordIndex) {
                lowWord = words.0;
                hiWord = words.1;
            } else {
                return None<uint>;
            }
        }
        let shiftFactor = asm(2, 8*alignment) uint { exp };
        let invShiftFactor = asm(2, 256-8*alignment) uint { exp };
        return Some((lowWord/shiftFactor) | (hiWord*invShiftFactor));
    }
}

// bytearray_set256 writes a 32-byte chunk to a ByteArray, returning the resulting ByteArray
public func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> option<ByteArray> {
    if (offset+32 > ba.size) {
        if let Some(expandedBa) = bytearray_expandToFit(ba, offset+32) {
            ba = expandedBa;
        } else {
            return None<ByteArray>;
        }
    }
    let lowWordIndex = offset / 32;
    let alignment = offset % 32;
    if (alignment == 0) {
        return Some(ba with {
            contents: ba.contents with { [lowWordIndex] = value }
        });
    } else {
        if let Some(res) = builtin_arrayOpConsecutiveSafe(
            ba.contents,
            lowWordIndex,
            struct { f: basmulti_low_closure_func, val: (alignment, value,), },
            struct { f: bas256_hi_closure_func, val: (alignment, value,), }
        ) {
            return Some(ba with { contents: res.0 });
        } else {
            return None<ByteArray>;
        }
    }
}

// bytearray_copy copies bytes from one ByteArray to another, 
//       returning the updated destination ByteArray
public func bytearray_copy(
    from: ByteArray, 
    fromOffset: uint,
    to: ByteArray,
    toOffset: uint,
    nbytes: uint,
) -> option<ByteArray> {   
    // TODO: optimize this to exploit alignment and speed up the endgame
    while (nbytes >= 32) {
        if let Some(val) = bytearray_get256(from, fromOffset) {
            if let Some(nto) = bytearray_set256(to, toOffset, val) {
                to = nto;
                fromOffset = 32+fromOffset;
                toOffset = 32+toOffset;
                nbytes = nbytes-32;
            } else {
                return None<ByteArray>;
            }
        } else {
            return None<ByteArray>;
        }
    }
    while (nbytes > 0) {
        if let Some(val) = bytearray_getByte(from, fromOffset) {
            if let Some(nto) = bytearray_setByte(to, toOffset, val) {
                to = nto;
                fromOffset = 1+fromOffset;
                toOffset = 1+toOffset;
                nbytes = nbytes-1;
            } else {
                return None<ByteArray>;
            }
        } else {
            return None<ByteArray>;
        }
    }
    return Some(to);
}

func bytearray_expandToFit(ba: ByteArray, neededCapacity: uint) -> option<ByteArray> {
    if (ba.capacity < neededCapacity) {
        if ( ! ba.variableSize) {
            return None<ByteArray>;  // tried to expand a fixed-size array
        }
        let newCapacity = ba.capacity*8;
        while (newCapacity < neededCapacity) {
                newCapacity = 8*newCapacity;
        }
        return Some(ba with { capacity: newCapacity }
                  with { contents: array_resize(ba.contents, newCapacity/32, 0) });   
    } else {
        return Some(ba);
    }
}

func basb_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (subidx, newbval,) = args;
    let shiftFac = asm (2, 8*subidx) uint { exp };
    let mask = 0xff * shiftFac;
    let pasteIn = (newbval & 0xff) * shiftFac;
    return (
        (oldval & ~mask) | pasteIn,
        0, 
    );
}

func bas64_single_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (subidx, newbval,) = args;
    let shiftFac = asm (2, 8*subidx) uint { exp };
    let mask = 0xffffffffffffffff * shiftFac;
    let pasteIn = (newbval & 0xff) * shiftFac;
    return (
        (oldval & ~mask) | pasteIn,
        0, 
    );
}

func basmulti_low_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (alignment, value,) = args; 
    let revAlignment = 32-alignment;
    let factor = asm(2, 8*revAlignment) uint { exp };
    let newVal = (value*factor) | (oldval & (factor-1));
    return (newVal, 0,);
}

func bas64_hi_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (alignment, value,) = args; 
    let revAlignment = 8-alignment;
    let factor = asm(2, 8*alignment) uint { exp };
    let invFactor = asm(2, 8*revAlignment) uint { exp };
    let newVal = (value/factor) | (oldval & (invFactor * ~0));
    return (newVal, 0,);
}

func bas256_hi_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (alignment, value,) = args; 
    let revAlignment = 32-alignment;
    let factor = asm(2, 8*alignment) uint { exp };
    let invFactor = asm(2, 8*revAlignment) uint { exp };
    let newVal = (value/factor) | (oldval & (invFactor * ~0));
    return (newVal, 0,);
}