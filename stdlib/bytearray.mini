//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

type OpClosureFunc = func(any, uint) -> (uint, any)
type opClosure = struct {
	f: OpClosureFunc,
	val: any,
} // usage: (newSlotContents, returnValue) = closure.f(closure.val, oldSlotContents)

type ByteArray = struct { 
    size: uint,
    sliceOffset: uint,
    contents: buffer,
    copy: bool,
}

// bytearray_new makes a new ByteArray
// it will initially have size zero,
//        reads beyond the end will return zero,
//        size will expand to fit all writes (but max size is 2**64 bytes),
//        and the capacity arg is a hint about how big it will get
public func bytearray_new(ignored: uint) -> ByteArray {
    return struct {
        size: 0,
        sliceOffset: 0,
        contents: newbuffer(),
        copy: false,
    };
}

type MarshalledBytes = struct {
    nbytes: uint,
    contents: MarshalledBytesCell,
}

type MarshalledBytesCell = struct {
    first: uint,
    rest: any,  // really a MarshalledbytesCell, but compiler can't handle recursive types
}

public func marshalledBytes_firstByte(mb: MarshalledBytes) -> uint {
    let nbytes = mb.nbytes;
    let contents = mb.contents;
    if (nbytes < 1) {
        return 0;
    }
    while (nbytes > 32) {
        contents = unsafecast<MarshalledBytesCell>(contents.rest);
        nbytes = nbytes-32;
    }
    return asm(256-8, contents.first) uint { shr };
}

public func marshalledBytes_hash(mb: MarshalledBytes) -> bytes32 {
    // This is an easy-to-compute cryptographic hash of a MarshalledBytes
    // It is collision-free, assuming that the underlying hash operation is collision-free.

    let ret = bytes32(mb.nbytes);
    let x = unsafecast<any>(mb.contents);
    while(x != ()) {
        let cell = unsafecast<MarshalledBytesCell>(x);
        ret = hash(ret, bytes32(cell.first));
        x = cell.rest;
    }
    return ret;
}

// bytearray_unmarshalBytes unmarshals a bytestack object that we got from L1
//        returns a new bytearray holding the unmarshaled bytes, or None if unmarshalled array would be too large
public func bytearray_unmarshalBytes(inBytes: MarshalledBytes) -> option<ByteArray> {
    let nbytes = inBytes.nbytes;
    if (nbytes > 0x100000000000000000000000000000000) {
        return None;
    }
    let nwords = (nbytes+31)/32;
    let words = inBytes.contents;

    // We'll also build 8-tuples of 32-byte words, and insert each tuple into the ExpIntArr with a single call.
    let eia = newbuffer();
    let block = unsafecast<[8]any>((0,0,0,0,0,0,0,0));

    while (nwords > 0) {
        nwords = nwords-1;
        eia = setbuffer256(eia, nwords*32, words.first);
        words = unsafecast<MarshalledBytesCell>(words.rest);
    }

    return Some(struct {
        size: inBytes.nbytes,
        sliceOffset: 0,
        contents: eia,
        copy: false,
    });
}

public func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes {
    if (ba.copy) {
        ba = bytearray_copy(make(ba), ba.sliceOffset, bytearray_new(0), 0, ba.size);
    }
    let nbytes = ba.size;
    let nwords = (nbytes+31)/32;
    let words = unsafecast<MarshalledBytesCell>(());
    let i = 0;
    while (i < nwords) {
        words = struct {
            first: getbuffer256(ba.contents, 32*i),
            rest: words,
        };
        // debug((333, 32*i, words.first));
        i = i+1;
    }
    // debug((111, nbytes, words));
    return struct {
        nbytes: nbytes,
        contents: words,
    };
}

// bytearray_size gets the size of a ByteArray
public func bytearray_size(ba: ByteArray) -> uint {
    // debug((444, ba.size));
    return ba.size;
}

public func bytearray_buffer(ba: ByteArray) -> buffer {
    return ba.contents;
}

public func bytearray_slice(ba: ByteArray) -> uint {
    return ba.sliceOffset;
}

// bytearray_getByte reads one byte from a ByteArray
public func bytearray_getByte(ba: ByteArray, offset: uint) -> uint {
    if (offset >= ba.size) {
        // debug((111,offset,0));
        return 0;
    }
    offset = offset + ba.sliceOffset;
    let res = getbuffer8(ba.contents, offset);
    // debug((111,offset,res));
    return res;
}

// bytearray_get64 reads a chunk of 8 bytes from a ByteArray
public func bytearray_get64(ba: ByteArray, offset: uint) -> uint {
    if (offset >= ba.size) {
        // debug((123, 0));
        return 0;
    }
    if (offset+7 >= ba.size) {
        ba = bytearray_copy(make(ba), ba.sliceOffset, bytearray_new(0), 0, ba.size);
    }
    offset = offset + ba.sliceOffset;
    let res = getbuffer64(ba.contents, offset);
    // debug((123, res));
    return res;
}

// bytearray_get256 reads a chunk of 32 bytes from a ByteArray
public func bytearray_get256(ba: ByteArray, offset: uint) -> uint {
    if (offset >= ba.size) {
        // debug((333,offset,0));
        return 0;
    }
    if (offset+31 >= ba.size) {
        // offset = offset + ba.sliceOffset;
        let res = getbuffer256(ba.contents, offset+ba.sliceOffset);
        // ba = bytearray_copy(make(ba), ba.sliceOffset, bytearray_new(0), 0, ba.size);
        let diff = offset+32 - ba.size;
        let ret = ((res SHR (diff*8)) SHL (diff*8));
        // debug((333,offset+ba.sliceOffset,ret));
        return ret;
    }
    offset = offset + ba.sliceOffset;
    let res = getbuffer256(ba.contents, offset);
    // debug((333,offset,res));
    return res;
}

func make(cont: ByteArray) -> ByteArray {
    return struct {
        size: cont.size + cont.sliceOffset + 32,
        sliceOffset: 0,
        contents: cont.contents,
        copy: true,
    };
}

public func bytearray_wrap(cont: buffer, size: uint) -> ByteArray {
    return struct {
        size: size,
        sliceOffset: 0,
        contents: cont,
        copy: false,
    };
}

// bytearray_setbyte writes one byte to a ByteArray, returns the resulting ByteArray
public func bytearray_setByte(ba: ByteArray, offset: uint, value: uint) -> ByteArray {
    // debug((1,offset,value));
    if (offset >= ba.size) {
        if (offset >= 0x100000000000000000000000000000000) {
            return ba;    // ignore out-of-bounds write
        }
        ba = ba with { size: offset+1 };
    }
    offset = offset + ba.sliceOffset;
    return ba with { contents: setbuffer8(ba.contents, offset, value) };
    // return ba with { contents: ba.contents };
}

// bytearray_set64 writes an 8-byte chunk to a ByteArray, returning the resulting ByteArray
public func bytearray_set64(ba: ByteArray, offset: uint, value: uint) -> ByteArray {
    // debug((2,offset,value));
    if (offset >= 0x100000000000000000000000000000000-7) {
        return ba;    // ignore out-of-bounds write
    }
    if (offset+8 > ba.size) {
        ba = ba with { size: offset+8 };
    }
    offset = offset + ba.sliceOffset;
    return ba with { contents: setbuffer64(ba.contents, offset, value) };
}

// bytearray_set256 writes a 32-byte chunk to a ByteArray, returning the resulting ByteArray
public func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> ByteArray {
    // debug((3,offset,value));
    if (offset >= 0x100000000000000000000000000000000-31) {
        return ba;    // ignore out-of-bounds write
    }
    if (offset+32 > ba.size) {
        ba = ba with { size: offset+32 };
    }
    offset = offset + ba.sliceOffset;
    return ba with { contents: setbuffer256(ba.contents, offset, value) };
}

// bytearray_copy copies bytes from one ByteArray to another, 
//       returning the updated destination ByteArray
public func bytearray_copy(
    from: ByteArray, 
    fromOffset: uint,
    to: ByteArray,
    toOffset: uint,
    nbytes: uint,
) -> ByteArray {
    if ((fromOffset >= 0x100000000000000000000000000000000)
        || (toOffset >= 0x100000000000000000000000000000000)
        || (nbytes >= 0x100000000000000000000000000000000) ) {
        return to;  // ignore out-of-bounds parameters
    }

    // TODO: optimize this to exploit alignment and speed up the endgame
    // debug(nbytes);
    if (to.size < toOffset + nbytes) {
        to = to with { size: toOffset + nbytes };
    }
    fromOffset = fromOffset + from.sliceOffset;
    toOffset = toOffset + to.sliceOffset;
    let toContents = to.contents;
    let fromContents = from.contents;
    while (nbytes >= 32) {
        let val = getbuffer256(fromContents, fromOffset);
        // debug((333, fromOffset, val));
        toContents = setbuffer256(toContents, toOffset, val);
        fromOffset = 32+fromOffset;
        toOffset = 32+toOffset;
        nbytes = nbytes-32;
    }
    while (nbytes > 0) {
        let val = getbuffer8(fromContents, fromOffset);
        // debug((111, fromOffset, val));
        toContents = setbuffer8(toContents, toOffset, val);
        fromOffset = 1+fromOffset;
        toOffset = 1+toOffset;
        nbytes = nbytes-1;
    }
    return to with { contents: toContents };
}

public func bytearray_extract(from: ByteArray, offset: uint, nbytes: uint) -> ByteArray {
    if (offset >= 0x100000000000000000000000000000000) {
        return bytearray_new(0);
    }
    if ((nbytes >= 0x100000000000000000000000000000000) || (offset+nbytes >= 0x100000000000000000000000000000000)) {
        return bytearray_new(0);
    }
    // return bytearray_copy(make(from), from.sliceOffset+offset, bytearray_new(0), 0, nbytes);
    
    return struct { size: nbytes, sliceOffset: offset + from.sliceOffset, contents: from.contents, copy: true };
}


public func bytearray_wrap_slice(cont: buffer, offset: uint, size: uint) -> ByteArray {
    return struct {
        size: size,
        sliceOffset: offset,
        contents: cont,
        copy: true,
    };
}

