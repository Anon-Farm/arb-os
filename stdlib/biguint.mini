//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::bytearray::ByteArray;
use std::bytearray::bytearray_new;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_extract;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_set256;

use std::random::RandomGenerator;
use std::random::random_next;


func modDigit(x: uint) -> uint {
    return x & 0xffffffffffffffffffff;
}

func divDigit(x: uint) -> uint {
    return asm(80, x) uint { shr };
}

func mulDigit(x: uint) -> uint {
    return asm(80, x) uint { shl };
}

func realSize(x: []uint) -> uint {
    let reducedSize = len(x);
    while( (reducedSize > 1) && (x[reducedSize-1] == 0) ) {
        reducedSize = reducedSize-1;
    }
    return reducedSize;
}

func shrinkToFit(x: []uint) -> []uint {
    let reducedSize = realSize(x);
    if (reducedSize < len(x)) {
        let ret = newarray<uint>(reducedSize);
        while(reducedSize > 0) {
            reducedSize = reducedSize-1;
            ret = ret with { [reducedSize] = x[reducedSize] };
        }
        return ret;
    } else {
        return x;
    }
}

func shiftPowerOfDigit(x: []uint, n: uint) -> []uint {
    let ret = newarray<uint>(len(x) + n);
    let i = len(x);
    while(i > 0) {
        i = i-1;
        ret = ret with { [i+n] = x[i] };
    }
    return ret;
}

public func biguint_zero() -> []uint {
    return newarray<uint>(1) with { [0] = 0 };
}

public func biguint_one() -> []uint {
    return newarray<uint>(1) with { [0] = 1 };
}

public func biguint_fromUint(x: uint) -> []uint {
    let ret = newarray<uint>(4);  // assume this will be big enough
    let i = 0;
    while(x > 0) {
        ret = ret with { [i] = modDigit(x) };
        ret = ret with { [i] = modDigit(x) };
        x = divDigit(x);
        i = i+1;
    }
    return ret;
}

public func biguint_fromBytes(ba: ByteArray) -> []uint {
    let nbytes = bytearray_size(ba);
    let nwords = 10*((nbytes+9)/10);
    let ret = newarray<uint>(nwords);

    let i = 0;
    let acc = 0;
    while(i < nbytes) {
        acc = acc*10 + bytearray_getByte(ba, i);
        if ((i % 10) == 9) {
            ret = ret with { [i/10] = acc };
            acc = 0;
        }
        i = i+1;
    }
    if (acc != 0) {
        ret = ret with { [i/10] = acc };
    }

    return ret;
}

public func biguint_toBytes(x: []uint) -> ByteArray {
    let nbytes = biguint_sizeBytes(x);
    let ndigits = 10*((nbytes+9)/10);
    let ret = bytearray_new(0);

    let digit = ndigits;
    while (digit > 0) {
        digit = digit-1;
        ret = bytearray_set256(ret, 10*digit, asm(256-80, x[digit]) uint { shl });
    }

    return bytearray_extract(ret, 9-(nbytes%10), nbytes);
}

public func biguint_sizeBytes(x: []uint) -> uint {
    let lenDigits = realSize(x);
    if (lenDigits == 0) {    return 0;    }
    let topWord = x[lenDigits-1];
    let lenBytes = 0;

    if (topWord >= 0x10000000000) {
        lenBytes = lenBytes+5;
        topWord = topWord / 10000000000;
    }
    if (topWord > 0x10000) {
        lenBytes = lenBytes+2;
        topWord = topWord / 10000;
    }
    if (topWord >= 4) {
        lenBytes = lenBytes+3;
    } elseif(topWord >= 2) {
        lenBytes = lenBytes+2;
    } elseif(topWord == 1) {
        lenBytes = lenBytes+1;
    }
    return lenBytes + 10 * (lenDigits-1);
}

public func biguint_random(nwords: uint, gen: RandomGenerator) -> ([]uint, RandomGenerator) {
    let ret = newarray<uint>(nwords);
    while(nwords > 0) {
        nwords = nwords - 1;
        let (ugen, val) = random_next(gen);
        gen = ugen;
        ret = ret with { [nwords] = modDigit(uint(val)) };
    }
    return (ret, gen);
}

public func biguint_marshal(x: []uint) -> any {
    let sz = realSize(x);
    let ret = unsafecast<any>(());
    let i = 0;
    while(i < sz) {
        ret = (x[i], ret);
        i = i+1;
    }
    return ret;
}

public func biguint_isZero(x: []uint) -> bool {
    let i = len(x);
    while(i > 0) {
        i = i-1;
        if (x[i] != 0) {
            return false;
        }
    }
    return true;
}

public func biguint_compare(x: []uint, y: []uint) -> int {
    let xSize = len(x);
    let ySize = len(y);
    let i = xSize;
    if (ySize > xSize) {  i = ySize;  }
    while(i > 0) {
        i = i-1;
        if (i >= xSize) {
            if (y[i] != 0) {    return -int(1);    }
        } elseif (i >= ySize) {
            if (x[i] != 0) {    return int(1);    }
        } else {
            let xi = x[i];
            let yi = y[i];
            if (xi > yi) {    return int(1);    }
            elseif(xi < yi) {    return -int(1);    }
        }
    }
    return int(0);
}

public func biguint_equal(x: []uint, y: []uint) -> bool {
    return biguint_compare(x, y) == int(0);
}

public func biguint_getBit(x: []uint, bnum: uint) -> uint {
    if (bnum >= 80*len(x)) {    return 0;    }

    return (asm(bnum%80, x[bnum/80]) uint { shr }) & 1;
}

public func biguint_add(x: []uint, y: []uint) -> []uint {
    let xSize = realSize(x);
    let ySize = realSize(y);

    // ensure that xSize >= ySize, swapping if needed
    if (xSize < ySize) {
        let ts = xSize;   xSize = ySize;   ySize = ts;
        let t = x;   x = y;   y = t;
    }

    let ret = newarray<uint>(xSize+1);

    let carry = 0;
    let i = 0;
    while(i < xSize) {
        let res = x[i] + carry;
        if (i < ySize) {
            res = res + y[i];
        }
        carry = divDigit(res);
        ret = ret with { [i] = modDigit(res) };
        i = i + 1;
    }

    return ret with { [xSize] = carry };
}

public func biguint_subtract(x: []uint, y: []uint) -> option<[]uint> {
    let comp = biguint_compare(x, y);
    if (comp < int(0)) {
        return None;
    } elseif(comp == int(0)) {
        return Some(newarray<uint>(1) with { [0] = 0 });
    } else {
        let resSize = realSize(x);
        let ySize = realSize(y);
        let ret = newarray<uint>(resSize);
        let i = 0;
        let carry = int(0);
        while(i < resSize) {
            let t = int(x[i]) + carry;
            if (i < ySize) {
                t = t - int(y[i]);
            }
            if(t >= int(0)) {
                ret = ret with { [i] = uint(t) };
                carry = int(0);
            } else {
                ret = ret with { [i] = uint(t)+0x100000000000000000000 };
                carry = -int(1);
            }
            i = i+1;
        }
        return Some(ret);
    }
}

public func biguint_mul(x: []uint, y: []uint) -> []uint {
    let xSize = realSize(x);
    let ySize = realSize(y);

    let ret = newarray<uint>(xSize+ySize);

    let i = 0;
    while(i < ySize) {
        let carry = 0;
        let j = 0;
        let uv = 0;
        while(j < xSize) {
            uv = ret[i+j] + x[j]*y[i] + carry;
            carry = divDigit(uv);
            ret = ret with { [i+j] = modDigit(uv) };
            j = j+1;
        }
        ret = ret with { [i+xSize] = carry };
        i = i+1;
    }

    return ret;
}

public func biguint_square(x: []uint) -> []uint {
    let t = realSize(x);
    let ret = newarray<uint>(2*t);

    let i = 0;
    while(i < t) {
        let xi = x[i];
        let uv = ret[2*i] + xi*xi;
        ret = ret with { [2*i] = modDigit(uv) };
        let c = divDigit(uv);
        let j = i+1;
        while(j < t) {
            uv = ret[i+j] + 2*x[j]*xi + c;
            ret = ret with { [i+j] = modDigit(uv) };
            c = divDigit(uv);
            j = j+1;
        }
        ret = ret with { [i+t] = c };
        i = i+1;
    }

    return ret;
}

public func biguint_divmod(x: []uint, y: []uint) -> option<([]uint, []uint)> {
    if (biguint_isZero(y)) {
        return None;
    } elseif (biguint_compare(x, y) < int(0)) {
        return Some((biguint_zero(), x));
    }

    let n = realSize(x)-1;
    let t = realSize(y)-1;
    let sizeDiff = n-t;
    let q = newarray<uint>(sizeDiff+1);

    let ybnt = shiftPowerOfDigit(y, sizeDiff);
    while(biguint_compare(x, ybnt) >= int(0)) {
        q = q with { [sizeDiff] = 1 + q[sizeDiff] };
        if let Some(diff) = biguint_subtract(x, ybnt) {
            x = diff;
        } else {
            panic;
        }
    }

    let i = n;
    while(i >= t+1) {
        if (x[i] == y[t]) {
            q = q with { [i-t-1] = mulDigit(1)-1 };
        } else {
            q = q with { [i-t-1] = (mulDigit(x[i]) + x[i-1]) / y[t] };
        }
        while(q[i-t-1]*(mulDigit(y[t])+y[t-1]) > mulDigit(mulDigit(x[i])+x[i-1])+x[i-2]) {
            q = q with { [i-t-1] = q[i-t-1]-1 };
        }
        if let Some(diff) = biguint_subtract(
            x,
            shiftPowerOfDigit(
                biguint_mul(
                    newarray<uint>(1) with { [0] = q[i-t-1] },
                    y,
                ),
                i-t-1
            ),
        ) {
            x = diff;
        } else {
            q = q with { [i-t-1] = q[i-t-1]-1 };
            if let Some(diff) = biguint_subtract(
                x,
                shiftPowerOfDigit(
                    biguint_mul(
                        newarray<uint>(1) with { [0] = q[i-t-1] },
                        y,
                    ),
                    i-t-1
                ),
            ) {
                x = diff;
            } else {
                panic;
            }
        }
        i = i-1;
    }
    return Some((q, x));
}

public func biguint_mod(x: []uint, y: []uint) -> option<[]uint> {
    if (biguint_isZero(y)) {
        return None;
    } elseif (biguint_compare(x, y) < int(0)) {
        return Some(x);
    }

    let n = realSize(x)-1;
    let t = realSize(y)-1;
    let sizeDiff = n-t;

    let ybnt = shiftPowerOfDigit(y, sizeDiff);
    while(biguint_compare(x, ybnt) >= int(0)) {
        if let Some(diff) = biguint_subtract(x, ybnt) {
            x = diff;
        } else {
            panic;
        }
    }

    let i = n;
    let qit1 = 0;
    while(i >= t+1) {
        if (x[i] == y[t]) {
            qit1 = mulDigit(1)-1;
        } else {
            qit1 = (mulDigit(x[i]) + x[i-1]) / y[t];
        }
        while(qit1*(mulDigit(y[t])+y[t-1]) > mulDigit(mulDigit(x[i])+x[i-1])+x[i-2]) {
            qit1 = qit1-1;
        }
        if let Some(diff) = biguint_subtract(
            x,
            shiftPowerOfDigit(
                biguint_mul(
                    newarray<uint>(1) with { [0] = qit1 },
                    y,
                ),
                i-t-1
            ),
        ) {
            x = diff;
        } else {
            qit1 = qit1-1;
            if let Some(diff) = biguint_subtract(
                x,
                shiftPowerOfDigit(
                    biguint_mul(
                        newarray<uint>(1) with { [0] = qit1 },
                        y,
                    ),
                    i-t-1
                ),
            ) {
                x = diff;
            } else {
                panic;
            }
        }
        i = i-1;
    }
    return Some(x);
}


public func biguint_modmul(x: []uint, y: []uint, m: []uint) -> option<[]uint> {
    return Some((biguint_divmod(biguint_mul(x, y), m)?).1);
}

public func biguint_modexp(x: []uint, e: []uint, m: []uint) -> option<[]uint> {
    if (biguint_isZero(m)) {    return None;    }

    x = shrinkToFit((biguint_divmod(x, m)?).1);    // reduce x mod m
    e = shrinkToFit(e);
    m = shrinkToFit(m);

    let ret = biguint_one();
    let b = 8*biguint_sizeBytes(x);
    while(b > 0) {
        b = b-1;
        ret = (biguint_divmod(biguint_square(ret), m)?).1;
        if (biguint_getBit(e, b) != 0) {
            ret = biguint_modmul(ret, x, m)?;
        }
    }

    return Some(ret);
}