/*
 * Copyright 2020, Offchain Labs, Inc. All rights reserved.
 */

//!Provides types and utilities for linking together compiled mini programs

use crate::compile::{
    comma_list, CompileError, CompiledProgram, DebugInfo, ErrorSystem, FileInfo, GlobalVarDecl,
    SourceFileMap, Type, TypeTree,
};
use crate::mavm::{AVMOpcode, Instruction, Label, Opcode, Value};
use crate::pos::{try_display_location, Location};
use crate::stringtable::{StringId, StringTable};
use analyze::print_code;
use serde::{Deserialize, Serialize};
use std::collections::hash_map::{DefaultHasher, HashMap};
use std::collections::BTreeMap;
use std::hash::Hasher;
use std::io;
use xformcode::make_uninitialized_tuple;

use petgraph::graph::{DiGraph, NodeIndex};
use rayon::prelude::*;

use crate::compile::miniconstants::init_constant_table;
use std::path::Path;
pub use xformcode::{value_from_field_list, TupleTree, TUPLE_SIZE};

pub mod analyze;
pub mod optimize;
mod striplabels;
mod xformcode;

#[derive(Clone, Serialize, Deserialize)]
pub struct SerializableTypeTree {
    inner: BTreeMap<String, (Type, String)>,
}

impl SerializableTypeTree {
    pub fn from_type_tree(tree: TypeTree) -> Self {
        let mut inner = BTreeMap::new();
        for ((path, id), tipe) in tree.into_iter() {
            inner.insert(format!("{}, {}", comma_list(&path), id), tipe);
        }
        Self { inner }
    }
    pub fn into_type_tree(self) -> TypeTree {
        let mut type_tree = HashMap::new();
        for (path, tipe) in self.inner.into_iter() {
            let mut x: Vec<_> = path.split(", ").map(|val| val.to_string()).collect();
            let id = x
                .pop()
                .map(|id| id.parse::<usize>())
                .expect("empty list")
                .expect("failed to parse");
            type_tree.insert((x, id), tipe);
        }
        type_tree
    }
}

///Represents a mini program that has gone through the post-link compilation step.
///
/// This is typically constructed via the `postlink_compile` function.
#[derive(Serialize, Deserialize)]
pub struct LinkedProgram {
    #[serde(default)]
    pub arbos_version: u64,
    pub code: Vec<Instruction<AVMOpcode>>,
    pub static_val: Value,
    pub globals: Vec<GlobalVarDecl>,
    #[serde(default)]
    pub file_info_chart: BTreeMap<u64, FileInfo>,
    pub type_tree: SerializableTypeTree,
}

impl LinkedProgram {
    ///Serializes self to the format specified by the format argument, with a default of json for
    /// None. The output is written to a dynamically dispatched implementor of `std::io::Write`,
    /// specified by the output argument.
    pub fn to_output(&self, output: &mut dyn io::Write, format: Option<&str>) {
        match format {
            Some("pretty") => {
                writeln!(output, "static: {}", self.static_val).unwrap();
                for (idx, insn) in self.code.iter().enumerate() {
                    writeln!(
                        output,
                        "{:05}:  {} \t\t {}",
                        idx,
                        insn,
                        try_display_location(
                            insn.debug_info.location,
                            &self.file_info_chart,
                            false
                        )
                    )
                    .unwrap();
                }
            }
            None | Some("json") => match serde_json::to_string(self) {
                Ok(prog_str) => {
                    writeln!(output, "{}", prog_str).unwrap();
                }
                Err(e) => {
                    eprintln!("failure");
                    writeln!(output, "json serialization error: {:?}", e).unwrap();
                }
            },
            Some("bincode") => match bincode::serialize(self) {
                Ok(encoded) => {
                    if let Err(e) = output.write_all(&encoded) {
                        writeln!(output, "bincode write error: {:?}", e).unwrap();
                    }
                }
                Err(e) => {
                    writeln!(output, "bincode serialization error: {:?}", e).unwrap();
                }
            },
            Some(weird_value) => {
                writeln!(output, "invalid format: {}", weird_value).unwrap();
            }
        }
    }
}

///Represents an import generated by a `use` statement.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Import {
    ///Module path, relative to logical program root.
    pub path: Vec<String>,
    ///Name of `Type` or function to be imported.
    pub name: String,
    ///`StringId` of the use-statement from parsing according to the containing module's `StringTable`
    pub id: Option<StringId>,
    ///Location of the use-statement in code
    pub location: Option<Location>,
}

impl Import {
    pub fn new(
        path: Vec<String>,
        name: String,
        id: Option<StringId>,
        location: Option<Location>,
    ) -> Self {
        Import {
            path,
            name,
            id,
            location,
        }
    }
    pub fn new_builtin(virtual_file: &str, name: &str) -> Self {
        Import {
            path: vec!["core".to_string(), virtual_file.to_string()],
            name: name.to_string(),
            id: None,
            location: None,
        }
    }
}

///Represents a function imported from another mini program or module.
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq)]
pub struct ImportedFunc {
    pub name_id: StringId,
    pub slot_num: usize,
    pub name: String,
}

impl ImportedFunc {
    pub fn new(slot_num: usize, name_id: StringId, string_table: &StringTable) -> Self {
        ImportedFunc {
            name_id,
            slot_num,
            name: string_table.name_from_id(name_id).to_string(),
        }
    }

    ///Takes self by value and returns self with slot_number increased by ext_offset. Used to assign
    /// unique slot numbers when linking multiple source files.
    pub fn relocate(mut self, _int_offset: usize, ext_offset: usize) -> Self {
        self.slot_num += ext_offset;
        self
    }
}

///Represents a function that is part of the modules public interface.  The label field represents
/// the start location of the function in the program it is contained in.
///
/// This struct differs from `ExportedFuncPoint` because the label field points to a virtual label
/// rather than an absolute address.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExportedFunc {
    pub name: String,
    pub label: Label,
    pub tipe: Type,
}

impl ExportedFunc {
    ///Takes self by value and returns a tuple. The first field of the tuple is self with internal,
    /// external, and function references increased by int_offset, ext_offset, and func_offset
    /// instructions respectively.  The second field is the instruction after the end of self,
    /// calculated by taking the sum of func_offset and the function length.
    pub fn relocate(
        self,
        int_offset: usize,
        ext_offset: usize,
        func_offset: usize,
    ) -> (Self, usize) {
        let (relocated_label, new_func_offset) =
            self.label.relocate(int_offset, ext_offset, func_offset);
        (
            ExportedFunc {
                name: self.name,
                label: relocated_label,
                tipe: self.tipe,
            },
            new_func_offset,
        )
    }
}

impl ExportedFunc {
    pub fn new(name_id: StringId, label: Label, tipe: Type, string_table: &StringTable) -> Self {
        Self {
            name: string_table.name_from_id(name_id).to_string(),
            label,
            tipe,
        }
    }
}

pub type FlowGraph = DiGraph<Vec<Instruction>, ()>;

///Converts a linked `CompiledProgram` into a `LinkedProgram` by fixing non-forward jumps,
/// converting wide tuples to nested tuples, performing code optimizations, converting the jump
/// table to a static value, and combining the file info chart with the associated argument.
pub fn postlink_compile(
    mut program: CompiledProgram,
    mut file_info_chart: BTreeMap<u64, FileInfo>,
    _error_system: &mut ErrorSystem,
    test_mode: bool,
    show_optimizations: bool,
    debug: bool,
) -> Result<LinkedProgram, CompileError> {
    if debug {
        for insn in program.code.iter_mut() {
            insn.debug_info.attributes.codegen_print = true;
        }
    }

    let code = program.code;

    if debug || show_optimizations {
        print_code(&code, "initial linking", &file_info_chart);
    }

    let (_, anon_labels, _) = analyze::count_labels(&code);
    let code = analyze::elide_useless_labels(&code, anon_labels);

    if debug || show_optimizations {
        print_code(&code, "after elide useless labels", &file_info_chart);
    }

    let mut code = code;
    loop {
        //break;

        let (inlined_code, inline_count) = analyze::inline_frames(&code);
        if show_optimizations {
            print_code(&inlined_code, "inline frames", &file_info_chart);
            println!("{} frames inlined", inline_count);
        }
        code = inlined_code;

        if inline_count == 0 {
            break;
        }
    }

    let (code, jump_table) = striplabels::fix_nonforward_labels(
        &code,
        &program.imported_funcs,
        program.globals.len() - 1,
    );
    if show_optimizations {
        print_code(&code, "fix_nonforward_labels", &file_info_chart);
    }

    let code = xformcode::fix_tuple_size(&code, program.globals.len())?;
    if debug || show_optimizations {
        print_code(&code, "fix_tuple_size", &file_info_chart);
    }

    let mut graph = analyze::create_cfg(&code);
    //let before_optimizations = graph.clone();

    loop {
        let mut do_another_pass = false;

        macro_rules! optimize {
            ($optimization:tt, $title:tt, $debug:expr) => {
                let blocks = graph
                    .node_indices()
                    .collect::<Vec<NodeIndex>>()
                    .par_iter()
                    .map(|node| optimize::$optimization(&graph[*node], $debug))
                    .collect::<Vec<(Vec<Instruction>, bool)>>();

                let mut optimized = FlowGraph::default();
                let mut unchanged = true;

                for (block, same) in blocks {
                    optimized.add_node(block);
                    unchanged = same && unchanged;
                }
                if !unchanged && show_optimizations {
                    analyze::print_cfg(&graph, &optimized, $title);
                }
                graph = optimized;
                do_another_pass = do_another_pass || !unchanged;
            };
        }

        optimize!(peephole, "peephole", false);
        optimize!(xget_elision, "xget elision", false);
        optimize!(xset_tail_elision, "xset tail elision", false);
        optimize!(tuple_annihilation, "tuple annihilation", false);
        optimize!(stack_reduce, "stack reduce", false);

        /*optimize!(xget_elision, "xget elision", false);
        optimize!(peephole, "peephole", false);
        optimize!(xset_tail_elision, "xset tail elision", false);
        optimize!(tuple_annihilation, "tuple annihilation", false);
        optimize!(stack_reduce, "stack reduce", false);*/
        
        let code = analyze::flatten_cfg(graph);
        let (_, anon_labels, _) = analyze::count_labels(&code);
        let code = analyze::elide_useless_labels(&code, anon_labels);
        graph = analyze::create_cfg(&code);

        if !do_another_pass {
            if show_optimizations {
                //analyze::print_cfg(&before_optimizations, &graph, "final output");
                analyze::print_cfg(&graph, &graph, "final output");
            }
            break;
        }
    }

    let prior_size = code
        .iter()
        .filter(|insn| insn.opcode.base_cost() > 0)
        .count() as f64;
    let prior_cost = code.iter().map(|insn| insn.opcode.base_cost()).sum::<u64>() as f64;
    let code = analyze::flatten_cfg(graph);
    let after_cost = code.iter().map(|insn| insn.opcode.base_cost()).sum::<u64>() as f64;
    let after_size = code
        .iter()
        .filter(|insn| insn.opcode.base_cost() > 0)
        .count() as f64;

    if show_optimizations {
        println!(
            "Instructions {} => {} = {:.2}%",
            prior_size,
            after_size,
            100.0 * (prior_size - after_size) / prior_size
        );
        println!(
            "ArbGas {} => {} = {:.2}%",
            prior_cost,
            after_cost,
            100.0 * (prior_cost - after_cost) / prior_cost
        );
    }

    let (mut code, jump_table_final) =
        striplabels::strip_labels(code, &jump_table, &program.imported_funcs)?;
    let jump_table_value = xformcode::jump_table_to_value(jump_table_final);

    if debug {
        print_code(&code, "strip_labels", &file_info_chart);
    }

    hardcode_jump_table_into_register(&mut code, &jump_table_value, test_mode);
    let avm_code: Vec<_> = code
        .into_iter()
        .map(|insn| {
            if let Opcode::AVMOpcode(inner) = insn.opcode {
                Ok(Instruction::new(inner, insn.immediate, insn.debug_info))
            } else {
                Err(CompileError::new(
                    String::from("Postlink error"),
                    format!("In final output encountered virtual opcode {}", insn.opcode),
                    insn.debug_info.location.into_iter().collect(),
                ))
            }
        })
        .collect::<Result<Vec<_>, CompileError>>()?;

    if debug {
        println!("============ after full compile/link =============");
        println!("static: {}", jump_table_value);
        for (idx, insn) in avm_code.iter().enumerate() {
            println!("{:04}:  {}", idx, insn);
        }
    }

    file_info_chart.extend(program.file_info_chart.clone());

    Ok(LinkedProgram {
        arbos_version: init_constant_table(Some(Path::new("arb_os/constants.json")))
            .unwrap()
            .get("ArbosVersionNumber")
            .unwrap()
            .clone()
            .trim_to_u64(),
        code: avm_code,
        static_val: Value::none(),
        globals: program.globals.clone(),
        file_info_chart,
        type_tree: SerializableTypeTree::from_type_tree(program.type_tree),
    })
}

fn hardcode_jump_table_into_register(
    code: &mut Vec<Instruction>,
    jump_table: &Value,
    test_mode: bool,
) {
    let offset = if test_mode { 1 } else { 2 };
    let old_imm = code[offset].clone().immediate.unwrap();
    code[offset] = Instruction::from_opcode_imm(
        code[offset].opcode,
        old_imm.replace_last_none(jump_table),
        code[offset].debug_info,
    );
}

///Combines the `CompiledProgram`s in progs_in into a single `CompiledProgram` with offsets adjusted
/// to avoid collisions and auto-linked programs added.
///
/// Also prints a warning message to the console if import and export types between modules don't
/// match.
pub fn link(
    progs_in: &[CompiledProgram],
    test_mode: bool,
    error_system: &mut ErrorSystem,
) -> Result<CompiledProgram, CompileError> {
    let progs = progs_in.to_vec();
    let type_tree = progs[0].type_tree.clone();
    let mut insns_so_far: usize = 3; // leave 2 insns of space at beginning for initialization
    let mut imports_so_far: usize = 0;
    let mut int_offsets = Vec::new();
    let mut ext_offsets = Vec::new();
    let mut merged_source_file_map = SourceFileMap::new_empty();
    let mut global_num_limit = vec![];

    for prog in &progs {
        merged_source_file_map.push(
            prog.code.len(),
            match &prog.source_file_map {
                Some(sfm) => sfm.get(0),
                None => "".to_string(),
            },
        );
        int_offsets.push(insns_so_far);
        insns_so_far += prog.code.len();
        ext_offsets.push(imports_so_far);
        imports_so_far += prog.imported_funcs.len();
    }

    let mut relocated_progs = Vec::new();
    let mut func_offset: usize = 0;
    for (i, prog) in progs.iter().enumerate() {
        let (relocated_prog, new_func_offset) = prog.clone().relocate(
            int_offsets[i],
            ext_offsets[i],
            func_offset,
            global_num_limit,
            prog.clone().source_file_map,
        );
        global_num_limit = relocated_prog.globals.clone();
        relocated_progs.push(relocated_prog);
        func_offset = new_func_offset + 1;
    }

    global_num_limit.push(GlobalVarDecl::new(
        usize::MAX,
        "_jump_table".to_string(),
        Type::Any,
        None,
    ));

    // Initialize globals or allow jump table retrieval
    let mut linked_code = if test_mode {
        vec![
            Instruction::from_opcode_imm(
                Opcode::AVMOpcode(AVMOpcode::Noop),
                Value::none(),
                DebugInfo::default(),
            ),
            Instruction::from_opcode_imm(
                Opcode::AVMOpcode(AVMOpcode::Noop),
                make_uninitialized_tuple(global_num_limit.len()),
                DebugInfo::default(),
            ),
            Instruction::from_opcode(Opcode::AVMOpcode(AVMOpcode::Rset), DebugInfo::default()),
        ]
    } else {
        vec![
            Instruction::from_opcode(Opcode::AVMOpcode(AVMOpcode::Rget), DebugInfo::default()),
            Instruction::from_opcode_imm(
                Opcode::AVMOpcode(AVMOpcode::Noop),
                Value::none(),
                DebugInfo::default(),
            ),
            Instruction::from_opcode_imm(
                Opcode::AVMOpcode(AVMOpcode::Rset),
                make_uninitialized_tuple(global_num_limit.len()),
                DebugInfo::default(),
            ),
        ]
    };

    let mut linked_exports = Vec::new();
    let mut linked_imports = Vec::new();
    for mut rel_prog in relocated_progs {
        linked_code.append(&mut rel_prog.code);
        linked_exports.append(&mut rel_prog.exported_funcs);
        linked_imports.append(&mut rel_prog.imported_funcs);
    }

    let mut exports_map = HashMap::new();
    let mut label_xlate_map = HashMap::new();
    for exp in &linked_exports {
        exports_map.insert(exp.name.clone(), exp.label);
    }
    for imp in &linked_imports {
        if let Some(label) = exports_map.get(&imp.name) {
            label_xlate_map.insert(Label::External(imp.slot_num), label);
        } else {
            error_system.warnings.push(CompileError::new_warning(
                String::from("Compile warning"),
                format!("Failed to resolve import \"{}\"", imp.name),
                vec![],
            ));
        }
    }

    let mut linked_xlated_code = Vec::new();
    for insn in linked_code {
        linked_xlated_code.push(insn.xlate_labels(&label_xlate_map));
    }

    Ok(CompiledProgram::new(
        linked_xlated_code,
        linked_exports,
        linked_imports,
        global_num_limit,
        Some(merged_source_file_map),
        {
            let mut map = HashMap::new();
            let mut file_hasher = DefaultHasher::new();
            file_hasher.write(b"builtin/array.mini");
            map.insert(
                file_hasher.finish(),
                FileInfo {
                    name: String::from("builtin/array.mini"),
                    path: String::from("builtin/array.mini"),
                    contents: vec![], // we assume the builtin files are correct
                },
            );
            let mut file_hasher = DefaultHasher::new();
            file_hasher.write(b"builtin/kvs.mini");
            map.insert(
                file_hasher.finish(),
                FileInfo {
                    name: String::from("builtin/kvs.mini"),
                    path: String::from("builtin/kvs.mini"),
                    contents: vec![], // we assume the builtin files are correct
                },
            );
            map
        },
        type_tree,
    ))
}
