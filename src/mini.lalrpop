use crate::ast::{TopLevelDecl, TypeDecl, FuncDecl, GlobalVarDecl, ImportFuncDecl, ImportTypeDecl, Type, StructField, FuncArg, Statement, IfArm, Expr, BinaryOp, UnaryOp, 
FieldInitializer, new_func_arg, new_type_decl};
use crate::stringtable::{StringTable, StringId};
use crate::source::Lines;
use crate::pos::BytePos;
use crate::uint256::Uint256;
use crate::mavm::Value as AvmValue;

grammar(stringtable: &mut StringTable<'input>, file_info: &Lines);

pub Decls: Vec<TopLevelDecl> = {
	<i:ImportDecl*> <n:NonImportDecl+> => TopLevelDecl::concat_vecs(i, &n),
}

ImportDecl: TopLevelDecl = {
	ImportFuncDecl => TopLevelDecl::ImpFuncDecl(<>),
	ImportTypeDecl => TopLevelDecl::ImpTypeDecl(<>),	
}

ImportFuncDecl: ImportFuncDecl = {
	"import" "func" <i:Ident> "(" <fa:FuncArgs> ")" ";" => ImportFuncDecl::new(i, fa, Type::Void),
	"import" "func" <i:Ident> "(" <fa:FuncArgs> ")" <t:Type> ";" => ImportFuncDecl::new(i, fa, t),
}

ImportTypeDecl: ImportTypeDecl = {
	"import" "type" <Ident> ";" => ImportTypeDecl::new(<>),
}

NonImportDecl: TopLevelDecl = {
	TypeDecl => TopLevelDecl::TypeDecl(<>),
	FuncDecl => TopLevelDecl::FuncDecl(<>),
	GlobalVarDecl => TopLevelDecl::VarDecl(<>),
}

TypeDecl: TypeDecl = {
	"type" <Ident> "=" <Type> => new_type_decl(<>),
}

FuncDecl: FuncDecl = {
	<lno: @L> "func" <i:Ident> "(" <fa:FuncArgs> ")" <cb:CodeBlock> => FuncDecl::new(i, fa, Type::Void, cb, false, file_info.location(BytePos::from(lno))),
	<lno: @L> "func" <i:Ident> "(" <fa:FuncArgs> ")" <t:Type> <cb:CodeBlock> => FuncDecl::new(i, fa, t, cb, false, file_info.location(BytePos::from(lno))),
	<lno: @L> "public" "func" <i:Ident> "(" <fa:FuncArgs> ")" <cb:CodeBlock> => FuncDecl::new(i, fa, Type::Void, cb, true, file_info.location(BytePos::from(lno))),
	<lno: @L> "public" "func" <i:Ident> "(" <fa:FuncArgs> ")" <t:Type> <cb:CodeBlock> => FuncDecl::new(i, fa, t, cb, true, file_info.location(BytePos::from(lno))),
}

FuncArgs: Vec<FuncArg> = {
	FuncArg* => <>,
}

FuncArg: FuncArg = {
	<i:Ident> ":" <t:Type> ","? => new_func_arg(i, t),
}

GlobalVarDecl: GlobalVarDecl = {
	<lno: @L> "var" <i:Ident> ":" <t:Type> ";" => GlobalVarDecl::new(i, t, file_info.location(BytePos::from(lno))),
}

CodeBlock: Vec<Statement> = {
	"{" <Statement*> "}" => <>
}

Statement: Statement = {
	<lno: @L> "while" "(" <e: Expr> ")" <cb: CodeBlock> => Statement::While(e, cb, file_info.location(BytePos::from(lno))),
	<lno: @L> "loop" <cb: CodeBlock> => Statement::Loop(cb, file_info.location(BytePos::from(lno))),
	<lno: @L> "if" "(" <c: Expr> ")" <t: CodeBlock> => Statement::If(IfArm::Cond(c, t, None, file_info.location(BytePos::from(lno)))),
	<lno: @L> "if" "(" <c: Expr> ")" <t: CodeBlock> <r: IfArm> => Statement::If(IfArm::Cond(c, t, Some(Box::new(r)), file_info.location(BytePos::from(lno)))),
	<lno: @L> "let" <i: Ident> "=" <e: Expr> ";" => Statement::Let(i, e, file_info.location(BytePos::from(lno))),
	<lno: @L> <i: Ident> "=" <e: Expr> ";" => Statement::Assign(i, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "return" <e: Expr> ";" => Statement::Return(e, file_info.location(BytePos::from(lno))),
	<lno: @L> "return" ";" => Statement::ReturnVoid(file_info.location(BytePos::from(lno))),
	<lno: @L> "panic" ";" => Statement::Panic(file_info.location(BytePos::from(lno))),
	<lno: @L> ";" => Statement::Noop(file_info.location(BytePos::from(lno))),
}

IfArm: IfArm = {
	<lno: @L> "else" <cb: CodeBlock> => IfArm::Catchall(cb, file_info.location(BytePos::from(lno))),
	<lno: @L> "elseif" "(" <c: Expr> ")" <cb: CodeBlock> => IfArm::Cond(c, cb, None, file_info.location(BytePos::from(lno))),
	<lno: @L> "elseif" "(" <c: Expr> ")" <cb: CodeBlock> <r: IfArm> => IfArm::Cond(c, cb, Some(Box::new(r)), file_info.location(BytePos::from(lno))),
}

StructDecl: Type = {
	"struct" "{" <StructFields> "}" => Type::Struct(<>),
};

StructFields: Vec<StructField> = {
	StructField+ => <>,
}

StructField: StructField = {
	<Ident> ":" <Type> "," => StructField::new(<>),
}

Type: Type = {
	"uint" => Type::Uint,
	"int" => Type::Int,
	"bool" => Type::Bool,
	"bytes32" => Type::Bytes32,
	StructDecl => <>,
	"(" ")" => Type::Tuple(Vec::new()),
	"(" <CommaedTypes> ")" => Type::Tuple(<>),
	"[" "]" <Type> => Type::Array(Box::new(<>)),
	"[" <s:UnsignedInteger> "]" <t:Type> => Type::FixedArray(
		Box::new(t), 
		s.to_usize().unwrap(),
	),
	"anytype" => Type::Any,
	Ident => Type::Named(<>),
};

CommaedTypes: Vec<Type> = {
	Type => vec![<>],
	<c: CommaedTypes> "," <t:Type> => {
		let mut c = c;
		c.push(t);
		c
	}
};

Ident: StringId = {
	r"[a-zA-Z_][a-zA-Z_01-9]*" => stringtable.get(<>),
};

Expr: Expr = {
	<lno: @L> "-" <e: Expr> => Expr::UnaryOp(UnaryOp::Minus, Box::new(e), file_info.location(BytePos::from(lno))),
	<lno: @L> "!" <e: Expr> => Expr::UnaryOp(UnaryOp::Not, Box::new(e), file_info.location(BytePos::from(lno))),
	<lno: @L> "~" <e: Expr> => Expr::UnaryOp(UnaryOp::BitwiseNeg, Box::new(e), file_info.location(BytePos::from(lno))),
	Expr1,
};

Expr1: Expr = {
	<lno: @L> <l:Expr1> "+" <r:Factor> => Expr::Binary(BinaryOp::Plus, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Expr1> "-" <r:Factor> => Expr::Binary(BinaryOp::Minus, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Factor,
};

Factor: Expr = {
	<lno: @L> <l:Factor> "*" <r:Term1> => Expr::Binary(BinaryOp::Times, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Factor> "/" <r:Term1> => Expr::Binary(BinaryOp::Div, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Factor> "%" <r:Term1> => Expr::Binary(BinaryOp::Mod, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Term1,
};

Term1: Expr = {
	<lno: @L> <l:Term1> "<" <r:Term2> => Expr::Binary(BinaryOp::LessThan, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Term1> ">" <r:Term2> => Expr::Binary(BinaryOp::GreaterThan, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Term1> "<=" <r:Term2> => Expr::Binary(BinaryOp::LessEq, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Term1> ">=" <r:Term2> => Expr::Binary(BinaryOp::GreaterEq, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Term2,
};

Term2: Expr = {
	<lno: @L> <l:Term2> "==" <r:Term3> => Expr::Binary(BinaryOp::Equal, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),	
	<lno: @L> <l:Term2> "!=" <r:Term3> => Expr::Binary(BinaryOp::NotEqual, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),	
	Term3,
};

Term3: Expr = {
	<lno: @L> <l:Term3> "&" <r:Term4> => Expr::Binary(BinaryOp::BitwiseAnd, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Term4,
};

Term4: Expr = {
	<lno: @L> <l:Term4> "^" <r:Term5> => Expr::Binary(BinaryOp::BitwiseXor, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Term5,
};

Term5: Expr = {
	<lno: @L> <l:Term5> "|" <r:Term6> => Expr::Binary(BinaryOp::BitwiseOr, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Term6,
};

Term6: Expr = {
	<lno: @L> <l:Term6> "&&" <r:Term7> => Expr::ShortcutAnd(Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Term7,
};

Term7: Expr = {
	<lno: @L> <l:Term7> "||" <r:Term8> => Expr::ShortcutOr(Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Term8,
};

Term8: Expr = {
	<lno: @L> "struct" "{" <fi: FieldInitializer+> "}" => Expr::StructInitializer(fi, file_info.location(BytePos::from(lno))),
	<lno: @L> "hash" "(" <e: Expr> ")" => Expr::UnaryOp(UnaryOp::Hash, Box::new(e), file_info.location(BytePos::from(lno))),
	<lno: @L> "hash" "(" <l:Expr> "," <r:Expr> ")" => Expr::Binary(BinaryOp::Hash, Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	<lno: @L> "len" "(" <e: Expr> ")" => Expr::UnaryOp(UnaryOp::Len, Box::new(e), file_info.location(BytePos::from(lno))),
	<lno: @L> "uint" "(" <e: Expr> ")" => Expr::UnaryOp(UnaryOp::ToUint, Box::new(e), file_info.location(BytePos::from(lno))),
	<lno: @L> "int" "(" <e: Expr> ")" => Expr::UnaryOp(UnaryOp::ToInt, Box::new(e), file_info.location(BytePos::from(lno))),
	<lno: @L> "bytes32" "(" <e: Expr> ")" => Expr::UnaryOp(UnaryOp::ToBytes32, Box::new(e), file_info.location(BytePos::from(lno))),
	<lno: @L> "newarray" "(" <e:Expr> "," <t:Type> ")" => Expr::NewArray(Box::new(e), t, file_info.location(BytePos::from(lno))),
	<lno: @L> "newfixedarray" "(" <s:UnsignedInteger> "," <e:Expr> ")" => Expr::NewFixedArray(
		s.to_usize().unwrap(), 
		Some(Box::new(e)),
		file_info.location(BytePos::from(lno)),
	),
	<lno: @L> "newfixedarray" "(" <s:UnsignedInteger> ")" => Expr::NewFixedArray(
		s.to_usize().unwrap(), 
		None,
		file_info.location(BytePos::from(lno)),
	),
	<lno: @L> "unsafecast" "(" <e:Expr> "," <t:Type> ")" => Expr::UnsafeCast(Box::new(e), t, file_info.location(BytePos::from(lno))),
	<lno: @L> <e1:Term8> "[" <e2:Expr> "]" => Expr::ArrayRef(Box::new(e1), Box::new(e2), file_info.location(BytePos::from(lno))),
	<lno: @L> <u: UnsignedInteger> => Expr::ConstUint(u, file_info.location(BytePos::from(lno))),
	<lno: @L> <s: SignedInteger> => Expr::ConstInt(s, file_info.location(BytePos::from(lno))),
	<lno: @L> <i: Ident> => Expr::VariableRef(i, file_info.location(BytePos::from(lno))),
	<lno: @L> <e:Term8> "." <i:Ident> => Expr::DotRef(Box::new(e), i, file_info.location(BytePos::from(lno))),
	<lno: @L> <e:Term8> "." <u:UnsignedInteger> => Expr::TupleRef(Box::new(e), u, file_info.location(BytePos::from(lno))),
	<lno: @L> <i: Ident> "(" ")" => Expr::FunctionCall(i, Vec::new(), file_info.location(BytePos::from(lno))),
	<lno: @L> <i: Ident> "(" <c: CommaedExprs> ")" => Expr::FunctionCall(i, c, file_info.location(BytePos::from(lno))),
	"(" <e: Expr> ")" => <>,
	<lno: @L> "(" <c: CommaedExprs> "," ")" => Expr::Tuple(c, file_info.location(BytePos::from(lno))),
	<lno: @L> <t:Term8> "with" "{" "[" <i:Expr> "]" "=" <v:Expr> "}" => Expr::ArrayMod(
		Box::new(t), 
		Box::new(i), 
		Box::new(v),
		file_info.location(BytePos::from(lno)),
	),
	<lno: @L> <t: Term8> "with" "{" <i:Ident> ":" <e: Expr> "}" => Expr::StructMod(Box::new(t), i, Box::new(e), file_info.location(BytePos::from(lno))),
	<lno: @L> "null" => Expr::RawValue(AvmValue::none(), file_info.location(BytePos::from(lno))),
}

FieldInitializer: FieldInitializer = {
	<Ident> ":" <Expr> "," => FieldInitializer::new(<>),
}

CommaedExprs: Vec<Expr> = {
	Expr => {
		let mut c = Vec::new();
		c.push(<>);
		c
	},
	<c: CommaedExprs> "," <e: Expr> => {
		let mut c = c;
		c.push(e);
		c
	},
}

UnsignedInteger: Uint256 = {
	"0" => Uint256::from_usize(0),
	r"[1-9][0-9]*" => Uint256::from_string(<>).unwrap(),
}

SignedInteger: Uint256 = {
	"0s" => Uint256::from_usize(0),
	r"[1-9][0-9]*s" => Uint256::from_signed_string(<>).unwrap(),
}
