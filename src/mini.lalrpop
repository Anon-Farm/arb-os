use crate::ast::{TopLevelDecl, TypeDecl, FuncDecl, ImportFuncDecl, Type, StructField, FuncArg, Statement, Expr, BinaryOp, UnaryOp, 
FieldInitializer, new_func_arg, new_type_decl};
use crate::stringtable::{StringTable, StringId};
use crate::uint256::Uint256;
use crate::mavm::Value;

grammar(stringtable: &mut StringTable<'input>);

pub Decls: Vec<TopLevelDecl> = {
	<mut i:ImportDecl*> <mut n:NonImportDecl+> => TopLevelDecl::concat_vecs(&mut i, &mut n),
}

ImportDecl: TopLevelDecl = {
	ImportFuncDecl => TopLevelDecl::ImpFuncDecl(<>),	
}

ImportFuncDecl: ImportFuncDecl = {
	"import" "func" <i:Ident> "(" <fa:FuncArgs> ")" ";" => ImportFuncDecl::new(i, fa, Type::Void),
	"import" "func" <i:Ident> "(" <fa:FuncArgs> ")" <t:Type> ";" => ImportFuncDecl::new(i, fa, t),
}

NonImportDecl: TopLevelDecl = {
	TypeDecl => TopLevelDecl::TypeDecl(<>),
	FuncDecl => TopLevelDecl::FuncDecl(<>),
}

TypeDecl: TypeDecl = {
	"type" <Ident> "=" <Type> => new_type_decl(<>),
}

FuncDecl: FuncDecl = {
	"func" <i:Ident> "(" <fa:FuncArgs> ")" <cb:CodeBlock> => FuncDecl::new(i, fa, Type::Void, cb, false),
	"func" <i:Ident> "(" <fa:FuncArgs> ")" <t:Type> <cb:CodeBlock> => FuncDecl::new(i, fa, t, cb, false),
	"public" "func" <i:Ident> "(" <fa:FuncArgs> ")" <cb:CodeBlock> => FuncDecl::new(i, fa, Type::Void, cb, true),
	"public" "func" <i:Ident> "(" <fa:FuncArgs> ")" <t:Type> <cb:CodeBlock> => FuncDecl::new(i, fa, t, cb, true),
}

FuncArgs: Vec<FuncArg> = {
	FuncArg* => <>,
}

FuncArg: FuncArg = {
	<i:Ident> ":" <t:Type> ","? => new_func_arg(i, t),
}

CodeBlock: Vec<Statement> = {
	"{" <Statement*> "}" => <>
}

Statement: Statement = {
	"while" "(" <Expr> ")" <CodeBlock> => Statement::While(<>),
	"loop" <CodeBlock> => Statement::Loop(<>),
	"if" "(" <c: Expr> ")" <t: CodeBlock> => Statement::If(c, t, None),
	"if" "(" <c: Expr> ")" <t: CodeBlock> "else" <f: CodeBlock> => Statement::If(c, t, Some(f)),
	"let" <Ident> "=" <Expr> ";" => Statement::Let(<>),
	<Ident> "=" <Expr> ";" => Statement::Assign(<>),
	"return" <Expr> ";" => Statement::Return(<>),
	"return" ";" => Statement::ReturnVoid,
	"panic" ";" => Statement::Panic,
	";" => Statement::Noop,
}

StructDecl: Type = {
	"struct" "{" <StructFields> "}" => Type::Struct(<>),
};

StructFields: Vec<StructField> = {
	StructField+ => <>,
}

StructField: StructField = {
	<Ident> ":" <Type> "," => StructField::new(<>),
}

Type: Type = {
	"uint" => Type::Uint,
	"int" => Type::Int,
	"bool" => Type::Bool,
	"bytes32" => Type::Bytes32,
	StructDecl => <>,
	"(" ")" => Type::Tuple(Vec::new()),
	"(" <CommaedTypes> ")" => Type::Tuple(<>),
	"[" "]" <Type> => Type::Array(Box::new(<>)),
	"[" <s:UnsignedInteger> "]" <t:Type> => Type::FixedArray(
		Box::new(t), 
		s.to_usize().unwrap(),
	),
	"anytype" => Type::Any,
	Ident => Type::Named(<>),
};

CommaedTypes: Vec<Type> = {
	Type => vec![<>],
	<c: CommaedTypes> "," <t:Type> => {
		let mut c = c;
		c.push(t);
		c
	}
};

Ident: StringId = {
	r"[a-zA-Z_][a-zA-Z_01-9]*" => stringtable.get(<>),
};

Expr: Expr = {
	"-" <Expr> => Expr::UnaryOp(UnaryOp::Minus, Box::new(<>)),
	"!" <Expr> => Expr::UnaryOp(UnaryOp::Not, Box::new(<>)),
	"~" <Expr> => Expr::UnaryOp(UnaryOp::BitwiseNeg, Box::new(<>)),
	Expr1,
};

Expr1: Expr = {
	<l:Expr1> "+" <r:Factor> => Expr::Binary(BinaryOp::Plus, Box::new(l), Box::new(r)),
	<l:Expr1> "-" <r:Factor> => Expr::Binary(BinaryOp::Minus, Box::new(l), Box::new(r)),
	Factor,
};

Factor: Expr = {
	<l:Factor> "*" <r:Term1> => Expr::Binary(BinaryOp::Times, Box::new(l), Box::new(r)),
	<l:Factor> "/" <r:Term1> => Expr::Binary(BinaryOp::Div, Box::new(l), Box::new(r)),
	<l:Factor> "%" <r:Term1> => Expr::Binary(BinaryOp::Mod, Box::new(l), Box::new(r)),
	Term1,
};

Term1: Expr = {
	<l:Term1> "<" <r:Term2> => Expr::Binary(BinaryOp::LessThan, Box::new(l), Box::new(r)),
	<l:Term1> ">" <r:Term2> => Expr::Binary(BinaryOp::GreaterThan, Box::new(l), Box::new(r)),
	<l:Term1> "<=" <r:Term2> => Expr::Binary(BinaryOp::LessEq, Box::new(l), Box::new(r)),
	<l:Term1> ">=" <r:Term2> => Expr::Binary(BinaryOp::GreaterEq, Box::new(l), Box::new(r)),
	Term2,
};

Term2: Expr = {
	<l:Term2> "==" <r:Term3> => Expr::Binary(BinaryOp::Equal, Box::new(l), Box::new(r)),	
	<l:Term2> "!=" <r:Term3> => Expr::Binary(BinaryOp::NotEqual, Box::new(l), Box::new(r)),	
	Term3,
};

Term3: Expr = {
	<l:Term3> "&" <r:Term4> => Expr::Binary(BinaryOp::BitwiseAnd, Box::new(l), Box::new(r)),
	Term4,
};

Term4: Expr = {
	<l:Term4> "^" <r:Term5> => Expr::Binary(BinaryOp::BitwiseXor, Box::new(l), Box::new(r)),
	Term5,
};

Term5: Expr = {
	<l:Term5> "|" <r:Term6> => Expr::Binary(BinaryOp::BitwiseOr, Box::new(l), Box::new(r)),
	Term6,
};

Term6: Expr = {
	<l:Term6> "&&" <r:Term7> => Expr::Binary(BinaryOp::LogicalAnd, Box::new(l), Box::new(r)),
	Term7,
};

Term7: Expr = {
	<l:Term7> "||" <r:Term8> => Expr::Binary(BinaryOp::LogicalOr, Box::new(l), Box::new(r)),
	Term8,
};

Term8: Expr = {
	"struct" "{" <FieldInitializer+> "}" => Expr::StructInitializer(<>),
	"hash" "(" <Expr> ")" => Expr::UnaryOp(UnaryOp::Hash, Box::new(<>)),
	"hash" "(" <l:Expr> "," <r:Expr> ")" => Expr::Binary(BinaryOp::Hash, Box::new(l), Box::new(r)),
	"len" "(" <Expr> ")" => Expr::UnaryOp(UnaryOp::Len, Box::new(<>)),
	"uint" "(" <Expr> ")" => Expr::UnaryOp(UnaryOp::ToUint, Box::new(<>)),
	"int" "(" <Expr> ")" => Expr::UnaryOp(UnaryOp::ToInt, Box::new(<>)),
	"bytes32" "(" <Expr> ")" => Expr::UnaryOp(UnaryOp::ToBytes32, Box::new(<>)),
	"newarray" "(" <e:Expr> "," <t:Type> ")" => Expr::NewArray(Box::new(e), t),
	"newfixedarray" "(" <s:UnsignedInteger> "," <e:Expr> ")" => Expr::NewFixedArray(
		s.to_usize().unwrap(), 
		Some(Box::new(e))
	),
	"newfixedarray" "(" <s:UnsignedInteger> ")" => Expr::NewFixedArray(
		s.to_usize().unwrap(), 
		None
	),
	"unsafecast" "(" <e:Expr> "," <t:Type> ")" => Expr::UnsafeCast(Box::new(e), t),
	<e1:Term8> "[" <e2:Expr> "]" => Expr::ArrayRef(Box::new(e1), Box::new(e2)),
	UnsignedInteger => Expr::ConstUint(<>),
	SignedInteger => Expr::ConstInt(<>),
	Ident => Expr::VariableRef(<>),
	<e:Term8> "." <i:Ident> => Expr::DotRef(Box::new(e), i),
	<e:Term8> "." <u:UnsignedInteger> => Expr::TupleRef(Box::new(e), u),
	<Ident> "(" ")" => Expr::FunctionCall(<>, Vec::new()),
	<Ident> "(" <CommaedExprs> ")" => Expr::FunctionCall(<>),
	"(" <Expr> ")" => <>,
	"(" <CommaedExprs> "," ")" => Expr::Tuple(<>),
	<t:Term8> "with" "{" "[" <i:Expr> "]" "=" <v:Expr> "}" => Expr::ArrayMod(
		Box::new(t), 
		Box::new(i), 
		Box::new(v)
	),
	<t: Term8> "with" "{" <i:Ident> ":" <e: Expr> "}" => Expr::StructMod(Box::new(t), i, Box::new(e)),
	"null" => Expr::RawValue(Value::none()),
}

FieldInitializer: FieldInitializer = {
	<Ident> ":" <Expr> "," => FieldInitializer::new(<>),
}

CommaedExprs: Vec<Expr> = {
	Expr => {
		let mut c = Vec::new();
		c.push(<>);
		c
	},
	<c: CommaedExprs> "," <e: Expr> => {
		let mut c = c;
		c.push(e);
		c
	},
}

UnsignedInteger: Uint256 = {
	"0" => Uint256::from_usize(0),
	r"[1-9][0-9]*" => Uint256::from_string(<>).unwrap(),
}

SignedInteger: Uint256 = {
	"0s" => Uint256::from_usize(0),
	r"[1-9][0-9]*s" => Uint256::from_signed_string(<>).unwrap(),
}
