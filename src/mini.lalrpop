//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

use crate::compile::ast::{TopLevelDecl, TypeDecl, FuncDecl, GlobalVarDecl, ImportFuncDecl, ImportTypeDecl, Type, StructField, FuncArg, Statement, MatchPattern, IfArm, Expr, BinaryOp, UnaryOp,
FieldInitializer, new_func_arg, new_type_decl};
use crate::stringtable::{StringTable, StringId};
use crate::compile::Lines;
use crate::pos::BytePos;
use crate::mavm::{Value, Instruction, Opcode};
use crate::uint256::Uint256;


grammar(stringtable: &mut StringTable<'input>, file_info: &Lines);

pub Decls: Vec<TopLevelDecl> = {
	<i:ImportDecl*> <n:NonImportDecl+> => TopLevelDecl::concat_vecs(i, n),
}

ImportDecl: TopLevelDecl = {
	ImportFuncDecl => TopLevelDecl::ImpFuncDecl(<>),
	ImportTypeDecl => TopLevelDecl::ImpTypeDecl(<>),	
}

ImportFuncDecl: ImportFuncDecl = {
	"import" "func" <i:Ident> "(" <fa:FuncArgs> ")" ";" => ImportFuncDecl::new(i, false, fa, Type::Void),
	"import" "func" <i:Ident> "(" <fa:FuncArgs> ")" "->" <t:Type> ";" => ImportFuncDecl::new(i, false, fa, t),
	"import" "impure" "func" <i:Ident> "(" <fa:FuncArgs> ")" ";" => ImportFuncDecl::new(i, true, fa, Type::Void),
	"import" "impure" "func" <i:Ident> "(" <fa:FuncArgs> ")" "->" <t:Type> ";" => ImportFuncDecl::new(i, true, fa, t),
}

ImportTypeDecl: ImportTypeDecl = {
	"import" "type" <Ident> ";" => ImportTypeDecl::new(<>),
}

NonImportDecl: TopLevelDecl = {
	TypeDecl => TopLevelDecl::TypeDecl(<>),
	FuncDecl => TopLevelDecl::FuncDecl(<>),
	GlobalVarDecl => TopLevelDecl::VarDecl(<>),
}

TypeDecl: TypeDecl = {
	"type" <Ident> "=" <Type> => new_type_decl(<>),
}

FuncDecl: FuncDecl = {
	<lno: @L> "func" <i:Ident> "(" <fa:FuncArgs> ")" <cb:CodeBlock> => FuncDecl::new(i, false, fa, Type::Void, cb, false, file_info.location(BytePos::from(lno))),
	<lno: @L> "func" <i:Ident> "(" <fa:FuncArgs> ")" "->" <t:Type> <cb:CodeBlock> => FuncDecl::new(i, false, fa, t, cb, false, file_info.location(BytePos::from(lno))),
	<lno: @L> "public" "func" <i:Ident> "(" <fa:FuncArgs> ")" <cb:CodeBlock> => FuncDecl::new(i, false, fa, Type::Void, cb, true, file_info.location(BytePos::from(lno))),
	<lno: @L> "public" "func" <i:Ident> "(" <fa:FuncArgs> ")" "->" <t:Type> <cb:CodeBlock> => FuncDecl::new(i, false, fa, t, cb, true, file_info.location(BytePos::from(lno))),
	<lno: @L> "impure" "func" <i:Ident> "(" <fa:FuncArgs> ")" <cb:CodeBlock> => FuncDecl::new(i, true, fa, Type::Void, cb, false, file_info.location(BytePos::from(lno))),
	<lno: @L> "impure" "func" <i:Ident> "(" <fa:FuncArgs> ")" "->" <t:Type> <cb:CodeBlock> => FuncDecl::new(i, true, fa, t, cb, false, file_info.location(BytePos::from(lno))),
	<lno: @L> "public" "impure" "func" <i:Ident> "(" <fa:FuncArgs> ")" <cb:CodeBlock> => FuncDecl::new(i, true, fa, Type::Void, cb, true, file_info.location(BytePos::from(lno))),
	<lno: @L> "public" "impure" "func" <i:Ident> "(" <fa:FuncArgs> ")" "->" <t:Type> <cb:CodeBlock> => FuncDecl::new(i, true, fa, t, cb, true, file_info.location(BytePos::from(lno))),

}

FuncArgs: Vec<FuncArg> = {
	FuncArg* => <>,
}

FuncArg: FuncArg = {
	<i:Ident> ":" <t:Type> ","? => new_func_arg(i, t),
}

GlobalVarDecl: GlobalVarDecl = {
	<lno: @L> "var" <i:Ident> ":" <t:Type> ";" => GlobalVarDecl::new(i, t, file_info.location(BytePos::from(lno))),
}

CodeBlock: Vec<Statement> = {
	"{" <Statement*> "}" => <>
}

Statement: Statement = {
	<lno: @L> "while" "(" <e: Expr> ")" <cb: CodeBlock> => Statement::While(e, cb, file_info.location(BytePos::from(lno))),
	<lno: @L> "loop" <cb: CodeBlock> => Statement::Loop(cb, file_info.location(BytePos::from(lno))),
	<lno: @L> "if" "(" <c: Expr> ")" <t: CodeBlock> => Statement::If(IfArm::Cond(c, t, None, file_info.location(BytePos::from(lno)))),
	<lno: @L> "if" "(" <c: Expr> ")" <t: CodeBlock> <r: IfArm> => Statement::If(IfArm::Cond(c, t, Some(Box::new(r)), file_info.location(BytePos::from(lno)))),
	<lno: @L> "let" <p: MatchPattern> "=" <e: Expr> ";" => Statement::Let(p, e, file_info.location(BytePos::from(lno))),
	<lno: @L> <f: Expr10> "(" ")" ";" => Statement::FunctionCall(f, vec![], file_info.location(BytePos::from(lno))),
	<lno: @L> <f: Expr10> "(" <c: CommaedExprs> ")" ";" => Statement::FunctionCall(f, c, file_info.location(BytePos::from(lno))),
	<lno: @L> <i: Ident> "=" <e: Expr> ";" => Statement::Assign(i, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "return" <e: Expr> ";" => Statement::Return(e, file_info.location(BytePos::from(lno))),
	<lno: @L> "return" ";" => Statement::ReturnVoid(file_info.location(BytePos::from(lno))),
	<lno: @L> "panic" ";" => Statement::Panic(file_info.location(BytePos::from(lno))),
	<lno: @L> "debug" "(" <e: Expr> ")" ";" => Statement::DebugPrint(e, file_info.location(BytePos::from(lno))),
	<lno: @L> "asm" "(" ")" "{" <body:AsmInsn*> "}" ";" => Statement::Asm(body, vec![], file_info.location(BytePos::from(lno))),
	<lno: @L> "asm" "(" <a:CommaedExprs> ")" "{" <body:AsmInsn*> "}" ";" => Statement::Asm(body, a, file_info.location(BytePos::from(lno))),
	<lno: @L> ";" => Statement::Noop(file_info.location(BytePos::from(lno))),
}

MatchPattern: MatchPattern = {
	<Ident> => MatchPattern::Simple(<>),
	"(" <CommaedMatchPatterns> ")" => MatchPattern::Tuple(<>),
}

CommaedMatchPattern: Vec<MatchPattern> = {
	MatchPattern => vec![<>], 
	<c: CommaedMatchPattern> "," <p: MatchPattern> => {
		let mut c = c;
		c.push(p);
		c
	},
}
CommaedMatchPatterns: Vec<MatchPattern> = {
	( <MatchPattern> "," )+ => <>,
}

IfArm: IfArm = {
	<lno: @L> "else" <cb: CodeBlock> => IfArm::Catchall(cb, file_info.location(BytePos::from(lno))),
	<lno: @L> "elseif" "(" <c: Expr> ")" <cb: CodeBlock> => IfArm::Cond(c, cb, None, file_info.location(BytePos::from(lno))),
	<lno: @L> "elseif" "(" <c: Expr> ")" <cb: CodeBlock> <r: IfArm> => IfArm::Cond(c, cb, Some(Box::new(r)), file_info.location(BytePos::from(lno))),
}

StructDecl: Type = {
	"struct" "{" <StructFields> "}" => Type::Struct(<>),
};

StructFields: Vec<StructField> = {
	StructField+ => <>,
}

StructField: StructField = {
	<Ident> ":" <Type> "," => StructField::new(<>),
}

Type: Type = {
	"uint" => Type::Uint,
	"int" => Type::Int,
	"bool" => Type::Bool,
	"bytes32" => Type::Bytes32,
	"address" => Type::EthAddress,
	StructDecl => <>,
	"(" ")" => Type::Tuple(Vec::new()),
	"(" <CommaedTypes> ")" => Type::Tuple(<>),
	"[" "]" <Type> => Type::Array(Box::new(<>)),
	"[" <s:UnsignedInteger> "]" <t:Type> => Type::FixedArray(
		Box::new(t), 
		s.to_usize().unwrap(),
	),
	"map" "<" <t1:Type> "," <t2:Type> ">" => Type::Map(Box::new(t1), Box::new(t2)),
	"func" <CommaedTypesInParens> => Type::Func(false, <>, Box::new(Type::Void)),
	"func" <a: CommaedTypesInParens> "->" <r: Type> => Type::Func(false, a, Box::new(r)),
	"impure" "func" <CommaedTypesInParens> => Type::Func(true, <>, Box::new(Type::Void)),
	"impure" "func" <a: CommaedTypesInParens> "->" <r: Type> => Type::Func(true, a, Box::new(r)),
	"any" => Type::Any,
	Ident => Type::Named(<>),
};

CommaedTypesInParens: Vec<Type> = {
	"(" ")" => vec![],
	"(" <CommaedTypes> ")" => <>,
}

CommaedTypes: Vec<Type> = {
	Type => vec![<>],
	<c: CommaedTypes> "," <t:Type> => {
		let mut c = c;
		c.push(t);
		c
	}
};

Ident: StringId = {
	IdentStr => stringtable.get(<>),
};

Expr: Expr = {
	<lno: @L> <t:Expr> "with" "{" "[" <i:Expr> "]" "=" <v:Expr> "}" => Expr::ArrayOrMapMod(
		Box::new(t), 
		Box::new(i), 
		Box::new(v),
		file_info.location(BytePos::from(lno)),
	),
	<lno: @L> <t: Expr> "with" "{" <i:Ident> ":" <e: Expr> "}" => Expr::StructMod(Box::new(t), i, Box::new(e), file_info.location(BytePos::from(lno))),
	Expr1,
}

Expr1: Expr = {
	<lno: @L> <l:Expr1> "||" <r:Expr2> => Expr::ShortcutOr(Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Expr2,
};

Expr2: Expr = {
	<lno: @L> <l:Expr2> "&&" <r:Expr3> => Expr::ShortcutAnd(Box::new(l), Box::new(r), file_info.location(BytePos::from(lno))),
	Expr3,
};

Expr3: Expr = {
	<lno: @L> <l:Expr3> "<" <r:Expr4> => Expr::new_binary(BinaryOp::LessThan, l, r, file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Expr3> ">" <r:Expr4> => Expr::new_binary(BinaryOp::GreaterThan, l, r, file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Expr3> "<=" <r:Expr4> => Expr::new_binary(BinaryOp::LessEq, l, r, file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Expr3> ">=" <r:Expr4> => Expr::new_binary(BinaryOp::GreaterEq, l, r, file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Expr3> "==" <r:Expr4> => Expr::new_binary(BinaryOp::Equal, l, r, file_info.location(BytePos::from(lno))),	
	<lno: @L> <l:Expr3> "!=" <r:Expr4> => Expr::new_binary(BinaryOp::NotEqual, l, r, file_info.location(BytePos::from(lno))),
	Expr4,	
}

Expr4: Expr = {
	<lno: @L> <l:Expr4> "|" <r:Expr5> => Expr::new_binary(BinaryOp::BitwiseOr, l, r, file_info.location(BytePos::from(lno))),
	Expr5,
};

Expr5: Expr = {
	<lno: @L> <l:Expr5> "^" <r:Expr6> => Expr::new_binary(BinaryOp::BitwiseXor, l, r, file_info.location(BytePos::from(lno))),
	Expr6,
};

Expr6: Expr = {
	<lno: @L> <l:Expr6> "&" <r:Expr7> => Expr::new_binary(BinaryOp::BitwiseAnd, l, r, file_info.location(BytePos::from(lno))),
	Expr7,
};

Expr7: Expr = {
	<lno: @L> <l:Expr7> "+" <r:Expr8> => Expr::new_binary(BinaryOp::Plus, l, r, file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Expr7> "-" <r:Expr8> => Expr::new_binary(BinaryOp::Minus, l, r, file_info.location(BytePos::from(lno))),
	Expr8,
};

Expr8: Expr = {
	<lno: @L> <l:Expr8> "*" <r:Expr9> => Expr::new_binary(BinaryOp::Times, l, r, file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Expr8> "/" <r:Expr9> => Expr::new_binary(BinaryOp::Div, l, r, file_info.location(BytePos::from(lno))),
	<lno: @L> <l:Expr8> "%" <r:Expr9> => Expr::new_binary(BinaryOp::Mod, l, r, file_info.location(BytePos::from(lno))),
	Expr9,
};

Expr9: Expr = {
	<lno: @L> "-" <e: Expr9> => Expr::new_unary(UnaryOp::Minus, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "!" <e: Expr9> => Expr::new_unary(UnaryOp::Not, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "~" <e: Expr9> => Expr::new_unary(UnaryOp::BitwiseNeg, e, file_info.location(BytePos::from(lno))),
	Expr10,
};

Expr10: Expr = {
	<lno: @L> <f: Expr10> "(" ")" => Expr::FunctionCall(Box::new(f), Vec::new(), file_info.location(BytePos::from(lno))),
	<lno: @L> <f: Expr10> "(" <e: Expr> ")" => Expr::FunctionCall(Box::new(f), vec![e], file_info.location(BytePos::from(lno))),
	<lno: @L> <f: Expr10> "(" <c: CommaedExprs> ")" => Expr::FunctionCall(Box::new(f), c, file_info.location(BytePos::from(lno))),
	<lno: @L> <e1:Expr10> "[" <e2:Expr> "]" => Expr::ArrayOrMapRef(Box::new(e1), Box::new(e2), file_info.location(BytePos::from(lno))),
	<lno: @L> <e:Expr10> "." <i:Ident> => Expr::DotRef(Box::new(e), i, file_info.location(BytePos::from(lno))),
	<lno: @L> <e:Expr10> "." <u:UnsignedInteger> => Expr::TupleRef(Box::new(e), u, file_info.location(BytePos::from(lno))),
	Expr11,
}

Expr11: Expr = {
	<lno: @L> "hash" "(" <e: Expr> ")" => Expr::new_unary(UnaryOp::Hash, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "hash" "(" <l:Expr> "," <r:Expr> ")" => Expr::new_binary(BinaryOp::Hash, l, r, file_info.location(BytePos::from(lno))),
	<lno: @L> "len" "(" <e: Expr> ")" => Expr::new_unary(UnaryOp::Len, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "uint" "(" <e: Expr> ")" => Expr::new_unary(UnaryOp::ToUint, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "int" "(" <e: Expr> ")" => Expr::new_unary(UnaryOp::ToInt, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "bytes32" "(" <e: Expr> ")" => Expr::new_unary(UnaryOp::ToBytes32, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "address" "(" <e: Expr> ")" => Expr::new_unary(UnaryOp::ToAddress, e, file_info.location(BytePos::from(lno))),
	<lno: @L> "newarray" "<" <t:Type> ">" "(" <e:Expr> ")" => Expr::NewArray(Box::new(e), t, file_info.location(BytePos::from(lno))),
	<lno: @L> "newfixedarray" "(" <s:UnsignedInteger> "," <e:Expr> ")" => Expr::NewFixedArray(
		s.to_usize().unwrap(), 
		Some(Box::new(e)),
		file_info.location(BytePos::from(lno)),
	),
	<lno: @L> "newfixedarray" "(" <s:UnsignedInteger> ")" => Expr::NewFixedArray(
		s.to_usize().unwrap(), 
		None,
		file_info.location(BytePos::from(lno)),
	),
	<lno: @L> "newmap" "<" <k:Type> "," <v:Type> ">" => Expr::NewMap(k, v, file_info.location(BytePos::from(lno))),
	<lno: @L> "unsafecast" "<" <t:Type> ">" "(" <e:Expr> ")" => Expr::UnsafeCast(Box::new(e), t, file_info.location(BytePos::from(lno))),
	Expr13,
}

// Expr12 does not exist

Expr13: Expr = {
	<lno: @L> "asm" "(" ")" <rt:Type> "{" <body:AsmInsn*> "}" => Expr::Asm(rt, body, vec![], file_info.location(BytePos::from(lno))),
	<lno: @L> "asm" "(" <a:CommaedExprs> ")" <rt:Type> "{" <body:AsmInsn*> "}" => Expr::Asm(rt, body, a, file_info.location(BytePos::from(lno))),
	Expr14,	
}

Expr14: Expr = {
	<lno: @L> "struct" "{" <fi: FieldInitializer+> "}" => Expr::StructInitializer(fi, file_info.location(BytePos::from(lno))),
	<lno: @L> <u: UnsignedInteger> => Expr::ConstUint(u, file_info.location(BytePos::from(lno))),
	<lno: @L> <s: SignedInteger> => Expr::ConstInt(s, file_info.location(BytePos::from(lno))),
	"(" <e: Expr> ")" => <>,
	<lno: @L> "(" <c: CommaedExprs> ")" => Expr::Tuple(c, file_info.location(BytePos::from(lno))),
	<lno: @L> "false" => Expr::ConstBool(false, file_info.location(BytePos::from(lno))),
	<lno: @L> "true" => Expr::ConstBool(true, file_info.location(BytePos::from(lno))),
	<lno: @L> "null" => Expr::Null(file_info.location(BytePos::from(lno))),
	<lno: @L> <i: Ident> => Expr::VariableRef(i, file_info.location(BytePos::from(lno))),
}

FieldInitializer: FieldInitializer = {
	<Ident> ":" <Expr> "," => FieldInitializer::new(<>),
}

CommaedExprs: Vec<Expr> = {
	<mut c: (<Expr> ",")+> <e: (Expr)?> => {
    		if let Some(s) = e {
    		    c.push(s);
    		}
    		c
    	},
}

AsmInsn: Instruction = {
	<lno: @L> <o: AsmOpcode> => Instruction::from_opcode(o, file_info.location(BytePos::from(lno))),
	<lno: @L> "[" <v:AsmVal> "]" <o:AsmOpcode> => Instruction::from_opcode_imm(o, v, file_info.location(BytePos::from(lno))),
}

AsmOpcode: Opcode = {
	IdentStr => Opcode::from_name(<>),
}

AsmVal: Value = {
	<UnsignedInteger> => Value::Int(<>),
	"(" <AsmValComma*> ")" => Value::Tuple(<>),
}

AsmValComma: Value = {
	<AsmVal> "," => <>,
}

IdentStr: &'input str = {
	r"[a-zA-Z_][a-zA-Z_01-9]*" => <>,
};

UnsignedInteger: Uint256 = {
	"0" => Uint256::from_usize(0),
	r"[1-9][0-9]*" => Uint256::from_string(<>).unwrap(),
	r"0x[0-9a-fA-F]+" => Uint256::from_string_hex(&<>[2..]).unwrap()
}

SignedInteger: Uint256 = {
	"0s" => Uint256::from_usize(0),
	r"[1-9][0-9]*s" => Uint256::from_signed_string(<>).unwrap(),
}
